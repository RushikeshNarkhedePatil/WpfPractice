<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PRISM</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:JetBrains.Annotations.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
        <member name="T:PRISM.clsParseCommandLine">
            <summary>
            This class can be used to parse the text following the program name when a
            program is started from the command line
            </summary>
            <remarks>
            <para>
            NET Standard does not have Environment.CommandLine, which means making this functional under NET Standard is non-trivial and API-breaking.
            Instead use the CommandLineParser class.
            </para>
            <para>
            This class is not marked as obsolete since it is used in numerous applications
            </para>
            </remarks>
        </member>
        <member name="F:PRISM.clsParseCommandLine.DEFAULT_SWITCH_CHAR">
            <summary>
            Default switch char
            </summary>
        </member>
        <member name="F:PRISM.clsParseCommandLine.ALTERNATE_SWITCH_CHAR">
            <summary>
            Alternate switch char
            </summary>
        </member>
        <member name="F:PRISM.clsParseCommandLine.DEFAULT_SWITCH_PARAM_CHAR">
            <summary>
            Default character between the switch name and a value to associate with the parameter
            </summary>
        </member>
        <member name="P:PRISM.clsParseCommandLine.NeedToShowHelp">
            <summary>
            If true, we need to show the syntax to the user due to a switch error, invalid switch, or the presence of /? or /help
            </summary>
        </member>
        <member name="P:PRISM.clsParseCommandLine.NoParameters">
            <summary>
            This will be true after calling ParseCommandLine if the command line has no arguments (either non-switch or switch based)
            </summary>
        </member>
        <member name="P:PRISM.clsParseCommandLine.ParameterCount">
            <summary>
            Number of switches
            </summary>
        </member>
        <member name="P:PRISM.clsParseCommandLine.NonSwitchParameterCount">
            <summary>
            Number of parameters that are not preceded by a switch
            </summary>
        </member>
        <member name="P:PRISM.clsParseCommandLine.DebugMode">
            <summary>
            Set to true to see extra debug information
            </summary>
        </member>
        <member name="M:PRISM.clsParseCommandLine.InvalidParametersPresent(System.Collections.Generic.List{System.String})">
            <summary>
            Compares the parameter names in parameterList with the parameters at the command line
            </summary>
            <param name="parameterList">Parameter list</param>
            <returns>True if any of the parameters are not present in parameterList()</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.InvalidParametersPresent(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compares the parameter names in parameterList with the parameters at the command line
            </summary>
            <param name="parameterList">Parameter list</param>
            <returns>True if any of the parameters are not present in parameterList()</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.InvalidParametersPresent(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Compares the parameter names in parameterList with the parameters at the command line
            </summary>
            <param name="parameterList">Parameter list</param>
            <param name="caseSensitive">True to perform case-sensitive matching of the parameter name</param>
            <returns>True if any of the parameters are not present in parameterList()</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.InvalidParametersPresent(System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Validate that the user-provided parameters are in the validParameters list
            </summary>
            <param name="validParameters"></param>
            <param name="caseSensitive"></param>
        </member>
        <member name="M:PRISM.clsParseCommandLine.InvalidParameters(System.Collections.Generic.List{System.String})">
            <summary>
            Retrieve a list of the user-provided parameters that are not in validParameters
            </summary>
            <param name="validParameters"></param>
        </member>
        <member name="M:PRISM.clsParseCommandLine.InvalidParameters(System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Retrieve a list of the user-provided parameters that are not in validParameters
            </summary>
            <param name="validParameters"></param>
            <param name="caseSensitive"></param>
        </member>
        <member name="M:PRISM.clsParseCommandLine.IsParameterPresent(System.String)">
            <summary>
            Look for parameter on the command line
            </summary>
            <param name="paramName">Parameter name</param>
            <returns>True if present, otherwise false</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.ParseCommandLine">
            <summary>
            Parse the parameters and switches at the command line; uses / for the switch character and : for the switch parameter character
            </summary>
            <remarks>
            If /? or /help is found, returns False and sets mShowHelp to True
            If there are no arguments at the command line, returns false, but sets NoArgumentsProvided to true
            </remarks>
            <returns>Returns True if any command line parameters were found; otherwise false</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.ParseCommandLine(System.Char)">
            <summary>
            Parse the parameters and switches at the command line; uses : for the switch parameter character
            </summary>
            <remarks>
            If /? or /help is found, returns False and sets mShowHelp to True
            If there are no arguments at the command line, returns false, but sets NoArgumentsProvided to true
            </remarks>
            <returns>Returns True if any command line parameters were found; otherwise false</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.ParseCommandLine(System.Char,System.Char)">
            <summary>
            Parse the parameters and switches at the command line
            </summary>
            <remarks>
            If /? or /help is found, returns False and sets mShowHelp to True
            If there are no arguments at the command line, returns false, but sets NoArgumentsProvided to true
            </remarks>
            <param name="switchStartChar"></param>
            <param name="switchParameterChar"></param>
            <returns>Returns True if any command line parameters were found; otherwise false</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.PauseAtConsole(System.Int32,System.Int32)">
            <summary>
            Pause the program for the specified number of milliseconds, displaying a period at a set interval while paused
            </summary>
            <param name="millisecondsToPause">Milliseconds to pause; default 5 seconds</param>
            <param name="millisecondsBetweenDots">Seconds between each period; default 1 second</param>
        </member>
        <member name="M:PRISM.clsParseCommandLine.RetrieveNonSwitchParameter(System.Int32)">
            <summary>
            Returns the value of the non-switch parameter at the given index
            </summary>
            <param name="parameterIndex">Parameter index</param>
            <returns>The value of the parameter at the given index; empty string if no value or invalid index</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.RetrieveParameter(System.Int32,System.String@,System.String@)">
            <summary>
            Returns the parameter at the given index
            </summary>
            <param name="parameterIndex">Parameter index</param>
            <param name="paramName">Parameter name (output)</param>
            <param name="paramValue">Value associated with the parameter; empty string if no value (output)</param>
            <returns>True if a parameterIndex is valid; false if >= mSwitches.Count</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.RetrieveValueForParameter(System.String,System.String@)">
            <summary>
            Look for parameter on the command line and returns its value in paramValue
            </summary>
            <param name="paramName">Parameter name</param>
            <param name="paramValue">Value associated with the parameter; empty string if no value (output)</param>
            <returns>True if present, otherwise false</returns>
        </member>
        <member name="M:PRISM.clsParseCommandLine.RetrieveValueForParameter(System.String,System.String@,System.Boolean)">
            <summary>
            Look for parameter on the command line and returns its value in paramValue
            </summary>
            <param name="paramName">Parameter name</param>
            <param name="paramValue">Value associated with the parameter; empty string if no value (output)</param>
            <param name="caseSensitive">True to perform case-sensitive matching of the parameter name</param>
            <returns>True if present, otherwise false</returns>
        </member>
        <member name="T:PRISM.CommandLineParser`1">
            <summary>
            <para>
            Class for keeping parameters flags and properties for command line arguments tied together,
            supporting properties of primitive types (and arrays of primitive types)
            </para>
            <para>
            Supports parameter flags similar to /d -dd --dir, with case sensitivity when needed,
            with the separator between parameter flag and parameter as ' ', ':', or '=',
            and also supports using a parameter flag as a switch (if the associated property is a bool)
            </para>
            <para>
            If an argument is supplied multiple times, it only keeps the last one supplied.
            If the property is an array, multiple values are provided using '-paramName value -paramName value ...' or similar.
            Includes support for showing help with no args supplied, or with argument names of "?" and "help" (can be overridden).
            </para>
            </summary>
            <remarks>
            <para>
            Either call static method ParseArgs like this:
              static int Main(string[] args) {
                var options = new ProgramOptions();
                var asmName = typeof(Program).GetTypeInfo().Assembly.GetName();
                var version = ProgramOptions.GetAppVersion();
                if (!CommandLineParser&lt;ProgramOptions&gt;.ParseArgs(args, options, asmName.Name, version))
                {
                    return -1;
                }
                if (!options.ValidateArgs(out var errorMessage))
                {
                    ConsoleMsgUtils.ShowWarning("Validation error:");
                    ConsoleMsgUtils.ShowWarning(errorMessage);
                    return -1;
                }
            </para>
            <para>
            Or instantiate this class, which allows for suppressing the auto-display of the syntax if an argument error is encountered
              static int Main(string[] args) {
                var asmName = typeof(Program).GetTypeInfo().Assembly.GetName();
                var exeName = Path.GetFileName(Assembly.GetExecutingAssembly().Location);
                var version = ProgramOptions.GetAppVersion();
                var parser = new CommandLineParser&lt;ProgramOptions&gt;(asmName.Name, version)
                {
                    ProgramInfo = "This program ...",
                    ContactInfo = "Program written by ...",
                    UsageExamples = {
                          exeName + @" C:\WorkDir InputFile.txt /Preview",
                          exeName + @" C:\WorkDir InputFile.txt",
                          exeName + @" C:\WorkDir InputFile.txt /Debug",
                    }
                };
                var parseResults = parser.ParseArgs(args);
                var options = parseResults.ParsedResults;
            </para>
            <para>
                if (!parseResults.Success)
                {
                  return -1;
                }
            </para>
            <para>
                if (!options.ValidateArgs(out var errorMessage))
                {
                    parser.PrintHelp();
                    Console.WriteLine();
                    ConsoleMsgUtils.ShowWarning("Validation error:");
                    ConsoleMsgUtils.ShowWarning(errorMessage);
                    return -1;
                }
            </para>
            <para>    options.OutputSetOptions();</para>
            <para>An example class suitable for use when instantiating the CommandLineParser is GenericParserOptions in this project</para>
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:PRISM.CommandLineParser`1.ParseErrorInfo">
            <summary>
            Tracks parameter parsing errors
            </summary>
        </member>
        <member name="F:PRISM.CommandLineParser`1.ParseErrorInfo.IsMissingRequiredParameter">
            <summary>
            Set to true if a required parameter is missing
            </summary>
        </member>
        <member name="F:PRISM.CommandLineParser`1.ParseErrorInfo.Message">
            <summary>
            Error message
            </summary>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseErrorInfo.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
            <param name="isMissingRequiredParameter"></param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseErrorInfo.ToString">
            <summary>
            ToString overload (show the error message)
            </summary>
        </member>
        <member name="T:PRISM.CommandLineParser`1.ParserResults">
            <summary>
            Results from the parsing
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParserResults.Success">
            <summary>
            Parsing status - false if parsing failed
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParserResults.ParseErrors">
            <summary>
            Errors that occurred during parsing
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParserResults.ParamFilePath">
            <summary>
            The path to the parameter file (if one was defined)
            </summary>
            <remarks>This is the parameter file name or path defined by the user; it is not necessarily a full path</remarks>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParserResults.ParsedResults">
            <summary>
            Target object, populated with the parsed arguments when the parsing completes
            </summary>
        </member>
        <member name="F:PRISM.CommandLineParser`1.ParserResults.mParseErrors">
            <summary>
            Modifiable list of parsing errors
            </summary>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParserResults.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="parsed"></param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParserResults.Failed(System.String,System.Boolean)">
            <summary>
            Set the parsing status to failed
            </summary>
            <remarks>This is also called when -CreateParamFile is provided or if not arguments were specified</remarks>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParserResults.AddParseError(System.String,System.Boolean)">
            <summary>
            Add a Parsing error to the parsing error list
            </summary>
            <remarks>This is also called when -CreateParamFile is provided</remarks>
            <param name="message">Error message</param>
            <param name="isMissingRequiredParameter">True if this is a missing required parameter</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParserResults.AddParseError(System.String,System.Object[])">
            <summary>
            Add a Parsing error to the parsing error list
            </summary>
            <param name="format">Format string for string.Format()</param>
            <param name="args">Value to substitute in the format string</param>
            <returns>Error message</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParserResults.OutputErrors(System.Boolean)">
            <summary>
            Print the parsing errors to console
            </summary>
            <param name="skipMissingParamErrors">When true, do not show errors regarding missing required parameters</param>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ContactInfo">
            <summary>
            Developer contact info
            </summary>
            <remarks>If defined, shown at the end of PrintHelp</remarks>
        </member>
        <member name="P:PRISM.CommandLineParser`1.CreateParamFileProvided">
            <summary>
            This is set to true if one of the arguments is -CreateParamFile
            and thus an example parameter file was created or shown at the console
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.EntryAssemblyName">
            <summary>
            Entry assembly name
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ExeVersionInfo">
            <summary>
            Executable version info
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.HideLongParamKeyNamesAtConsole">
            <summary>
            When true, if a parameter has multiple key names, when showing the syntax using PrintHelp,
            hide any whose length is greater than ParamKeysFieldWidth - 2
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParamKeysFieldWidth">
            <summary>
            Field width for the left column (key names)
            </summary>
            <remarks>Minimum allowed value: 10</remarks>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParamDescriptionFieldWidth">
            <summary>
            Field width for the right column (parameter descriptions)
            </summary>
            <remarks>Minimum allowed value: 20</remarks>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParameterFilePath">
            <summary>
            Full path to the parameter file, if a parameter file was defined
            </summary>
            <remarks>
            <para>
            This path will be updated after calling ParseArgs
            </para>
            <para>
            A parameter file is defined, by default, using /ParamFile:ParameterFilePath.conf or -ParamFile ParameterFilePath.conf
            </para>
            <para>
            Additional argument names for specifying the parameter file can be defined
            by calling AddParamFileKey after instantiating the CommandLineParser class
            </para>
            </remarks>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParamFlagCharacters">
            <summary>
            Get or set the characters allowed at the beginning of an argument specifier
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ParamSeparatorCharacters">
            <summary>
            Get or set the characters allowed as separators between an argument specifier and argument value
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ProgramInfo">
            <summary>
            Description of the program's purpose / usage
            </summary>
            <remarks>If defined, shown at the start of PrintHelp (though after any error messages)</remarks>
        </member>
        <member name="P:PRISM.CommandLineParser`1.Results">
            <summary>
            Parsing results. Contains success value, target object, and error list
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.UsageExamples">
            <summary>
            Usage examples to display to the user at the end of the help text
            </summary>
        </member>
        <member name="M:PRISM.CommandLineParser`1.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="entryAsmName">Name of the executing assembly</param>
            <param name="versionInfo">Executable version info</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.#ctor(`0,System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="options">Existing parsed options</param>
            <param name="entryAsmName">Name of the executing assembly</param>
            <param name="versionInfo">Executable version info</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.AddParamFileKey(System.String)">
            <summary>
            Add additional param keys that can be used to specify a parameter file argument, for example "Conf"
            </summary>
            <remarks>The default argument name for parameter files is /ParamFile or -ParamFile</remarks>
            <param name="paramKey"></param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.CreateParamFile(System.String)">
            <summary>
            Writes the values in <see cref="P:PRISM.CommandLineParser`1.Results"/>.ParsedResults as a parameter file
            </summary>
            <param name="paramFilePath">Path for the parameter file</param>
            <returns>True if the write was successful</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseArgs(System.String[],`0,System.String)">
            <summary>
            Parse the arguments into <paramref name="options"/>, returning a bool. Entry assembly name is retrieved via reflection
            </summary>
            <param name="args"></param>
            <param name="options"></param>
            <param name="versionInfo">Executable version info</param>
            <returns>True on success, false if argument parse failed</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseArgs(System.String[],`0,System.String,System.String)">
            <summary>
            Parse the arguments into <paramref name="options"/>, returning a bool
            </summary>
            <param name="args"></param>
            <param name="options"></param>
            <param name="entryAssemblyName">Name of the executable</param>
            <param name="versionInfo">Executable version info</param>
            <returns>True on success, false if argument parse failed</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseArgs(System.String[],System.String)">
            <summary>
            Parse the arguments, returning the parsing results in <see cref="T:PRISM.CommandLineParser`1.ParserResults"/>. Entry assembly name is retrieved via reflection
            </summary>
            <param name="args"></param>
            <param name="versionInfo">Executable version info</param>
            <returns>Parser results</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseArgs(System.String[],System.String,System.String)">
            <summary>
            Parse the arguments, returning the parsing results in <see cref="T:PRISM.CommandLineParser`1.ParserResults"/>
            </summary>
            <param name="args"></param>
            <param name="entryAssemblyName">Name of the executable</param>
            <param name="versionInfo">Executable version info</param>
            <returns>Parser results</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseArgs(System.String[],System.Boolean,System.Boolean)">
            <summary>
            Parse the arguments, returning the parsing results
            </summary>
            <remarks>
            The command line arguments in the args array can be provided in various forms, including:
            -i InputFile.txt
            -i:InputFile.txt
            -i=InputFile.txt
            /d
            -d
            --dir
            </remarks>
            <param name="args">Command line arguments</param>
            <param name="onErrorOutputHelp">When an error occurs, display the error and output the help</param>
            <param name="outputErrors">When an error occurs, output the error</param>
            <returns>Parser results</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ReadParamFile(System.String,System.Collections.Generic.List{System.String}@,System.IO.DirectoryInfo@)">
            <summary>
            Reads a parameter file
            </summary>
            <param name="paramFilePath">Parameter file path</param>
            <param name="paramFileLines">Output: List of parameters read from the parameter file; each line will starts with a dash</param>
            <param name="paramFileDirectory">Output: parameter file directory</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ReadParamFile(System.IO.FileSystemInfo)">
            <summary>
            Reads a parameter file
            </summary>
            <param name="paramFile">Parameter file</param>
            <returns>
            List of parameters read from the parameter file
            Each line will starts with a dash
            </returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.WriteParamFile(System.String)">
            <summary>
            Writes the values in <see cref="P:PRISM.CommandLineParser`1.Results"/>.ParsedResults as a parameter file,
            or show at the console if paramFilePath is an empty string
            </summary>
            <param name="paramFilePath"></param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ParseValueToType(System.Type,PRISM.OptionAttribute,System.String,System.String)">
            <summary>
            Parses a value to the specified type, checking min and max limits
            </summary>
            <param name="propertyType"></param>
            <param name="parseData"></param>
            <param name="argKey"></param>
            <param name="valueToParse"></param>
            <returns>Converted value</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ConvertToType(System.Object,System.Type)">
            <summary>
            Parse most objects normally, but parse enums using Enum.Parse
            </summary>
            <param name="valueToConvert"></param>
            <param name="targetType"></param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ArgsPreprocess(System.Collections.Generic.IReadOnlyList{System.String},System.Boolean)">
            <summary>
            Parse the arguments to a dictionary
            </summary>
            <remarks>
            Arguments loaded from a parameter file will each start with a dash, followed by the argument name, then an equals sign, then the value
            </remarks>
            <param name="args"></param>
            <param name="parsingParamFileArgs">Set this to true if the arguments were loaded from a parameter file</param>
            <returns>
            Dictionary where keys are argument names and values are the setting for the argument
            Values are a list in case the parameter is specified more than once
            </returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.GetPositionalArgName(System.Int32)">
            <summary>
            Generate the special argument name used to track positional arguments
            </summary>
            <param name="argPosition"></param>
            <returns>Argument name</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.HasUnknownArguments(System.Collections.Generic.Dictionary{System.String,PRISM.CommandLineParser{`0}.ArgInfo},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}})">
            <summary>
            Look for any unrecognized command line arguments
            </summary>
            <param name="validArgs">Dictionary of valid arguments read from the template class; includes mDefaultHelpArgs, mDefaultParamFileArgs, and mDefaultCreateExampleParamFileArgs</param>
            <param name="suppliedArgs">Dictionary of user-supplied arguments; keys are argument names and values are the argument value (or values)</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ShowHelp(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Display the help contents, using the information supplied by the Option attributes and the default constructor for the templated class
            </summary>
            <param name="entryAssemblyName">Name of the executable</param>
            <param name="versionInfo">Executable version info</param>
            <param name="paramKeysWidth">Field width for the left column (key names); minimum 10</param>
            <param name="helpDescriptionWidth">Field width for the right column (parameter descriptions); minimum 20</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.PrintHelp(System.Int32,System.Int32)">
            <summary>
            Display the help contents, using the information supplied by the Option attributes and the default constructor for the templated class
            </summary>
            <param name="paramKeysWidth">Field width for the left column (key names); minimum 10</param>
            <param name="helpDescriptionWidth">Field width for the right column (parameter descriptions); minimum 20</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.UpdatePropertyHelpText(System.String,System.String)">
            <summary>
            Update the HelpText for a property at runtime
            </summary>
            <param name="propertyName">Property to update (case-sensitive)</param>
            <param name="helpText">New help text</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.UpdatePropertyHelpText(System.String,System.String,System.String)">
            <summary>
            Change the HelpText for a property at runtime, searching for textToFind and replacing with replacementText
            </summary>
            <param name="propertyName">Property to update (case-sensitive)</param>
            <param name="textToFind">Text to find</param>
            <param name="replacementText">Text to use for a replacement</param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.CreateHelpContents(System.Int32)">
            <summary>
            Create the help text and argument name list for each argument
            </summary>
            <param name="paramKeysWidth">
            Field width for the left column (key names)
            If HideLongParamKeyNamesAtConsole is true, key names longer than this width - 2 will be hidden
            </param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.WrapParagraph(System.String,System.Int32)">
            <summary>
            Wraps the words in textToWrap to the set width (where possible)
            </summary>
            <remarks>Use the 'alert' character ('\a') to create a non-breaking space</remarks>
            <param name="textToWrap">Text to wrap</param>
            <param name="wrapWidth">Max length per line</param>
            <returns>Wrapped paragraph</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.WrapParagraphAsList(System.String,System.Int32)">
            <summary>
            Wraps the words in textToWrap to the set width (where possible)
            </summary>
            <remarks>Use the 'alert' character ('\a') to create a non-breaking space</remarks>
            <param name="textToWrap">Text to wrap</param>
            <param name="wrapWidth">Max length per line</param>
            <returns>Wrapped paragraph as a list of strings</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.GetValidArgs">
            <summary>
            Get the arguments that are valid for the class, dealing with argument name collision and invalid characters as needed
            </summary>
            <remarks>Position arguments are tracked via special flags: ##1##, ##2##, etc.</remarks>
            <returns>Dictionary where key is argument name, and value is Argument Info</returns>
        </member>
        <member name="M:PRISM.CommandLineParser`1.VerifyFileOrDirectoryPath(System.Collections.Generic.KeyValuePair{System.Reflection.PropertyInfo,PRISM.OptionAttribute},System.IO.FileSystemInfo)">
            <summary>
            Look for the file (or directory) specified by the given property (whose type is string)
            If the item does not exist in the working directory, but does exist in paramFileDirectory, auto-update the path
            </summary>
            <param name="prop"></param>
            <param name="paramFileDirectory"></param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.VerifyPathNotQuoted(System.Collections.Generic.KeyValuePair{System.Reflection.PropertyInfo,PRISM.OptionAttribute})">
            <summary>
            Assure that the path is not surrounded by single quotes or by double quotes
            </summary>
            <param name="prop"></param>
        </member>
        <member name="M:PRISM.CommandLineParser`1.RemoveMatchingQuotes(System.String)">
            <summary>
            Assure that the path is not surrounded by single quotes or by double quotes
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:PRISM.CommandLineParser`1.ArgInfo">
            <summary>
            Data about a single spelling of an argument name (name and NAME will be in the same instance)
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ArgInfo.ArgNormalCase">
            <summary>
            The first listed argument name
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ArgInfo.AllArgNormalCase">
            <summary>
            All arguments with the same name that differ only in capitalization
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ArgInfo.CaseSensitive">
            <summary>
            If the name is case sensitive
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ArgInfo.CanBeSwitch">
            <summary>
            If one of the arguments with this spelling is a bool
            </summary>
        </member>
        <member name="P:PRISM.CommandLineParser`1.ArgInfo.IsBuiltInArg">
            <summary>
            If the argument key is internally defined
            </summary>
            <remarks>Examples include: ?, help, ParamFile, and CreateParamFile</remarks>
        </member>
        <member name="M:PRISM.CommandLineParser`1.ArgInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.CommandLineParser`1.GetPropertiesAttributes">
            <summary>
            Parse the properties of the templated class
            </summary>
            <returns>PropertyInfo and the OptionAttribute instance for each property that has the attribute</returns>
        </member>
        <member name="T:PRISM.OptionAttribute">
            <summary>
            Attribute class to flag properties that are command line arguments
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.HelpText">
            <summary>
            Text displayed on the help screen
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.Required">
            <summary>
            True if the argument is required
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.ParamKeys">
            <summary>
            Valid command line argument name (or names)
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.ArgPosition">
            <summary>
            Maps a given unnamed argument to this parameter
            Defaults to 0 meaning not mapped to any unnamed arguments
            </summary>
            <remarks>
            For example, in MyUtility.exe InputFilePath.txt OutputFilePath.txt
            InputFilePath.txt is at position 1 and
            OutputFilePath.txt is at position 2
            </remarks>
        </member>
        <member name="P:PRISM.OptionAttribute.HelpShowsDefault">
            <summary>
            If the help screen should show the default value for an argument (value pulled from the default constructor)
            </summary>
            <remarks>Defaults to true</remarks>
        </member>
        <member name="P:PRISM.OptionAttribute.DefaultValueFormatString">
            <summary>
            Format string for adding default values to end of help text. If this is not set, and <see cref="P:PRISM.OptionAttribute.HelpShowsDefault"/>
            is true, the default will be displayed as " (Default: [value][, min (if set)][, max (if set)])".
            Use "{0}" for default value, "{1}" for min, and "{2}" for max. Use '\a' for a non-breaking space.
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.Min">
            <summary>
            Minimum value, for a numeric argument
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.Max">
            <summary>
            Maximum value, for a numeric argument
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.DoNotListEnumValues">
            <summary>
            If the property is an enum, the enum values are listed by default
            </summary>
            <remarks>Set this to 'true' to not list the enum values</remarks>
        </member>
        <member name="P:PRISM.OptionAttribute.Hidden">
            <summary>
            Set to 'true' to hide the argument from the help out
            </summary>
            <remarks>This is useful for supporting obsolete arguments</remarks>
        </member>
        <member name="P:PRISM.OptionAttribute.IsInputFilePath">
            <summary>
            Set to 'true' for properties that specify an input file path (or input directory path)
            </summary>
            <remarks>
            <para>
            If the path stored in this parameter is surrounded by double quotes or by single quotes, those quotes will be auto-removed
            </para>
            <para>
            Furthermore, if a parameter file is specified (using -ParamFile:Options.conf), the command line parser
            will process IsInputFilePath properties to look for files (or directories) in the working directory
            </para>
            <para>
            If the file (or directory) is not found, the parser will also look for the file (or directory) in the directory with the parameter file,
            and if the item is found there, the path stored in the property will be updated
            </para>
            </remarks>
        </member>
        <member name="P:PRISM.OptionAttribute.ArgExistsProperty">
            <summary>
            If the argument is specified, the given boolean property will be set to "true"
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.ArgExistsPropertyInfo">
            <summary>
            If <see cref="P:PRISM.OptionAttribute.ArgExistsProperty"/> is specified, and refers to a valid boolean property, this will be set to that property
            </summary>
        </member>
        <member name="P:PRISM.OptionAttribute.SecondaryArg">
            <summary>
            When true, this is a secondary (not primary) argument and will be commented out in example parameter files created by CreateParamFile
            </summary>
        </member>
        <member name="M:PRISM.OptionAttribute.#ctor(System.String[])">
            <summary>
            Constructor supporting any number of param keys
            </summary>
            <remarks>Not CLS compliant</remarks>
            <param name="paramKeys">Must supply at least one key for the argument, and it must be distinct within the class</param>
        </member>
        <member name="M:PRISM.OptionAttribute.#ctor(System.String)">
            <summary>
            Constructor, taking a single paramKey or a multiple param keys separated by a '|'
            </summary>
            <remarks>CLS compliant</remarks>
            <param name="paramKey">Must supply at least one key for the argument, and it must be distinct within the class; multiple keys can be specified, separated by a '|'</param>
        </member>
        <member name="M:PRISM.OptionAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Constructor supporting up to 4 param keys
            </summary>
            <remarks>CLS compliant</remarks>
            <param name="paramKey1"></param>
            <param name="paramKey2"></param>
            <param name="paramKey3"></param>
            <param name="paramKey4"></param>
        </member>
        <member name="M:PRISM.OptionAttribute.ToString">
            <summary>
            ToString overload (show the first supported argument name)
            </summary>
        </member>
        <member name="T:PRISM.EnumExtensions">
            <summary>
            Some extension methods for working with enums
            </summary>
        </member>
        <member name="M:PRISM.EnumExtensions.GetDescriptionAttribute(System.Enum,System.Type)">
            <summary>
            Get the string from the DescriptionAttribute of an enum value
            </summary>
            <remarks>From https://stackoverflow.com/questions/1799370/getting-attributes-of-enums-value
            </remarks>
        </member>
        <member name="T:PRISM.GenericParserOptions">
            <summary>
            This class demonstrates how to decorate properties in a class so that the CommandLineParser can use them to match command line arguments
            </summary>
        </member>
        <member name="M:PRISM.GenericParserOptions.OutputSetOptions">
            <summary>
            Display the current options at the console
            </summary>
        </member>
        <member name="M:PRISM.GenericParserOptions.ValidateArgs(System.String@)">
            <summary>
            Validate the options
            </summary>
            <param name="errorMessage"></param>
        </member>
        <member name="T:PRISM.AppSettings.KeyValueParamFileLine">
            <summary>
            Line of data from a Key=Value parameter file, stored in<see cref="P:PRISM.AppSettings.KeyValueParamFileLine.Text"/>
            </summary>
            <remarks>
            The class optionally also tracks the parameter name and value, using <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.ParamName"/> and <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.ParamValue"/>
            </remarks>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileLine.LineNumber">
            <summary>
            Line number in the parameter file
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileLine.Text">
            <summary>
            Text of the line from the parameter file (including the comment, if any)
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileLine.ParamName">
            <summary>
            Parameter name if this line contains a parameter, otherwise an empty string
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileLine.ParamValue">
            <summary>
            Parameter value if this line contains a parameter, otherwise an empty string
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileLine.Comment">
            <summary>
            Comment text; may be an empty string
            </summary>
            <remarks>If a comment is defined, this includes the leading # comment character</remarks>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileLine.HasParameter">
            <summary>
            True if ParamName has text, otherwise false
            </summary>
            <remarks>If ParamName has text but ParamValue is empty, this still returns true</remarks>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.#ctor(System.Int32,System.String,System.Boolean)">
            <summary>
            Constructor that takes a line number and line text
            </summary>
            <param name="lineNumber"></param>
            <param name="lineText"></param>
            <param name="parseKeyValuePair">When true, parse lineText to determine the key name and value</param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.#ctor(PRISM.AppSettings.KeyValueParamFileLine)">
            <summary>
            Constructor that just takes an instance of this class
            </summary>
            <param name="paramFileLine"></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.StoreParameter(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Associate a parameter with this data line
            </summary>
            <param name="paramName">Parameter name</param>
            <param name="paramValue">Parameter value</param>
            <param name="comment">Optional comment</param>
            <param name="updateTextProperty">When true, update <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.Text"/></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.StoreParameter(System.Collections.Generic.KeyValuePair{System.String,System.String},System.String,System.Boolean)">
            <summary>
            Associate a parameter with this data line
            </summary>
            <param name="paramInfo">Parameter</param>
            <param name="comment">Optional comment</param>
            <param name="updateTextProperty">When true, update <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.Text"/></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.UpdateTextUsingStoredData">
            <summary>
            Update property <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.Text"/> using <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.ParamName"/>, <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.ParamValue"/>, and <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.Comment"/>
            </summary>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.UpdateValue(System.String,System.Boolean)">
            <summary>
            Update the value for this parameter
            </summary>
            <param name="value"></param>
            <param name="updateTextProperty">When true, update <see cref="P:PRISM.AppSettings.KeyValueParamFileLine.Text"/></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileLine.ToString">
            <summary>
            Return the text of the line from the parameter file (including the comment, if any)
            </summary>
        </member>
        <member name="T:PRISM.AppSettings.KeyValueParamFileReader">
            <summary>
            Class for reading parameter files with Key=Value settings (as used by MS-GF+, MSPathFinder, and TopPIC)
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileReader.ErrorMessage">
            <summary>
            Most recent error message
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileReader.ParamFileName">
            <summary>
            Parameter file path
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileReader.ParamFilePath">
            <summary>
            Parameter file path (as passed to the constructor)
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileReader.ParamFileNotFound">
            <summary>
            This will be set to true if the parameter file was not found
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.KeyValueParamFileReader.ToolName">
            <summary>
            Tool name (for inclusion in error messages)
            </summary>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.#ctor(System.String,System.String)">
            <summary>
            Constructor that takes tool name and parameter file path
            </summary>
            <remarks>
            paramFilePath can be blank if you plan to call ParseKeyValueParameterList
            </remarks>
            <param name="toolName">Tool name (for logging)</param>
            <param name="paramFilePath">Parameter file path</param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor that takes a working directory path and parameter file name
            </summary>
            <remarks>
            Parameter file name and working directory path will be validated in ParseKeyValueParameterFile
            workDirPath and paramFileName can be blank if you plan to call ParseKeyValueParameterList
            </remarks>
            <param name="toolName">Tool name (for logging)</param>
            <param name="workDirPath">Directory with the parameter file</param>
            <param name="paramFileName">Parameter file name</param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.ConvertParamsToArgs(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.SortedSet{System.String},System.String)">
            <summary>
            Convert the parameter info into a command line
            </summary>
            <remarks>Returns an empty string if multiple parameters resolve to the same argument name</remarks>
            <param name="paramFileEntries">Parameter names and values read from tool's parameter file</param>
            <param name="paramToArgMapping">Dictionary mapping parameter names to argument names</param>
            <param name="paramNamesToSkip">Parameter names in paramFileEntries to skip</param>
            <param name="argumentPrefix">Argument prefix; typically -- or -</param>
            <returns>String with command line arguments</returns>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.GetKeyValueSetting(System.String,System.Boolean)">
            <summary>
            Parse settingText to extract the key name and value (separated by an equals sign)
            </summary>
            <remarks>
            If the line starts with # it is treated as a comment line and an empty key/value pair will be returned
            If the line contains a # sign in the middle, the comment text is stored in output argument comment
            </remarks>
            <param name="settingText"></param>
            <param name="removeComment">
            When true, if the value of the setting has a # delimited comment, remove it
            When false, the value of the setting will include the comment
            (default false)
            </param>
            <returns>Key/Value pair</returns>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.GetKeyValueSetting(System.String,System.String@,System.Boolean)">
            <summary>
            Parse settingText to extract the key name and value (separated by an equals sign)
            </summary>
            <remarks>
            <para>
            If the line starts with #, it is treated as a comment line and an empty key/value pair will be returned
            </para>
            <para>
            If the line contains a # sign in the middle, the comment text will be removed from the value if removeComment is true
            </para>
            <para>
            In either case, output argument comment will include the comment
            </para>
            </remarks>
            <param name="settingText">Text to parse</param>
            <param name="comment">Output: Comment text, if any (including the # sign)</param>
            <param name="removeComment">
            When true, if the value of the setting has a # delimited comment, remove it
            When false, the value of the setting will include the comment
            (default true, since this method has output argument comment)
            </param>
            <returns>Key/Value pair</returns>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.GetParameterValue(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String,System.String)">
            <summary>
            Get the value associated with the given parameter
            </summary>
            <param name="paramFileEntries"></param>
            <param name="paramName"></param>
            <param name="valueIfMissing"></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.GetParameterValue(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String,System.Boolean)">
            <summary>
            Get the boolean value associated with the given parameter
            </summary>
            <remarks>Will return valueIfMissing if the parameter is missing or does not contain "true" or "false"</remarks>
            <param name="paramFileEntries"></param>
            <param name="paramName"></param>
            <param name="valueIfMissing"></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.GetParameterValue(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String,System.Int32)">
            <summary>
            Get the integer value associated with the given parameter
            </summary>
            <remarks>Will return valueIfMissing if the parameter is missing or does not contain an integer</remarks>
            <param name="paramFileEntries"></param>
            <param name="paramName"></param>
            <param name="valueIfMissing"></param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.ParamIsEnabled(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String,System.Boolean)">
            <summary>
            Returns true if paramFileEntries contains parameter paramName and the parameter's value is True or a positive integer
            </summary>
            <param name="paramFileEntries"></param>
            <param name="paramName"></param>
            <param name="caseSensitiveParamName">When true, require a case-sensitive match to the parameter names in paramFileEntries</param>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.ParseKeyValueParameterFile(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}}@,System.Boolean)">
            <summary>
            Read a parameter file with Key=Value settings (as used by MS-GF+, MSPathFinder, and TopPIC)
            </summary>
            <param name="paramFileEntries">Output: List of setting names and values read from the parameter file</param>
            <param name="removeComments">When true, remove # delimited comments from setting values</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.ParseKeyValueParameterFileGetAllLines(System.Collections.Generic.List{PRISM.AppSettings.KeyValueParamFileLine}@,System.Boolean)">
            <summary>
            Read a parameter file with Key=Value settings (as used by MS-GF+, MSPathFinder, and TopPIC)
            </summary>
            <param name="paramFileLines">Output: contents of the parameter file, including parsed keys and values</param>
            <param name="removeComments">When true, remove # delimited comments from setting values</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.ParseKeyValueParameterFileWork(System.Collections.Generic.List{PRISM.AppSettings.KeyValueParamFileLine}@,System.Boolean)">
            <summary>
            Read a parameter file with Key=Value settings (as used by MS-GF+, MSPathFinder, and TopPIC)
            </summary>
            <param name="paramFileLines">Output: contents of the parameter file (each item in the list has the line number and the full data line)</param>
            <param name="removeComments">When true, remove # delimited comments from setting values</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.AppSettings.KeyValueParamFileReader.ParseKeyValueParameterList(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}}@,System.Boolean)">
            <summary>
            Parse Key=Value settings defined in a list of strings
            </summary>
            <param name="parameterList">List of Key=Value settings to parse</param>
            <param name="paramFileEntries">Output: List of setting names and values read from the parameter file</param>
            <param name="removeComments">When true, remove # delimited comments from setting values</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="T:PRISM.AppSettings.MgrSettings">
            <summary>
            Class for loading, storing and accessing manager parameters
            </summary>
            <remarks>
            <para>
            Loads initial settings from the local config file (AppName.exe.config)
            </para>
            <para>
            If MgrActive_Local is true, loads additional manager settings
            from the manager control database (when using a derived class)
            </para>
            </remarks>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.DEACTIVATED_LOCALLY">
            <summary>
            Status message for when the manager is deactivated locally
            </summary>
            <remarks>Used when MgrActive_Local is False in AppName.exe.config</remarks>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.MGR_PARAM_MGR_CFG_DB_CONN_STRING">
            <summary>
            Manager parameter: manager config database connection string
            </summary>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.DEFAULT_DMS_CONN_STRING">
            <summary>
            Manager parameter: DMS database connection string
            </summary>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.MGR_PARAM_MGR_ACTIVE_LOCAL">
            <summary>
            Manager parameter: manager active
            </summary>
            <remarks>Defined in AppName.exe.config</remarks>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.MGR_PARAM_MGR_NAME">
            <summary>
            Manager parameter: manager name
            </summary>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.MGR_PARAM_USING_DEFAULTS">
            <summary>
            Manager parameter: using defaults flag
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.MgrSettings.ErrMsg">
            <summary>
            Error message
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.MgrSettings.ManagerName">
            <summary>
            Manager name
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.MgrSettings.ParamsLoadedFromDB">
            <summary>
            This will be true after the manager settings have been successfully loaded from the manager control database
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.MgrSettings.MgrParams">
            <summary>
            Dictionary of manager parameters
            </summary>
        </member>
        <member name="P:PRISM.AppSettings.MgrSettings.TraceMode">
            <summary>
            When true, show additional messages at the console
            </summary>
        </member>
        <member name="F:PRISM.AppSettings.MgrSettings.CriticalErrorEvent">
            <summary>
            Important error event (only raised if ParamsLoadedFromDB is false)
            </summary>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.#ctor">
            <summary>
            Constructor
            </summary>
            <remarks>Call LoadSettings after instantiating this class</remarks>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetConfigFileName">
            <summary>
            Specifies the full name and path for the application config file
            </summary>
            <returns>String containing full name and path</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetConfigFilePath">
            <summary>
            Specifies the full name and path for the application config file
            </summary>
            <returns>String containing full name and path</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.LoadSettings(System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>
            Initialize manager settings using the local settings, then load additional settings from the database
            </summary>
            <param name="localSettings">Manager settings from the AppName.exe.config file or from Properties.Settings.Default</param>
            <param name="loadSettingsFromDB">When true, also load settings from the database</param>
            <returns>True if successful; False on error</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.CheckInitialSettings(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Tests initial settings retrieved from config file
            </summary>
            <param name="paramDictionary"></param>
            <returns>
            True if settings were loaded and MgrActive_Local is true (or MgrActive_Local is missing)
            False if MgrActive_Local is false or if UsingDefaults is true
            </returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetXmlConfigFileSetting(System.Collections.Generic.IReadOnlyList{System.String},System.String,System.String@)">
            <summary>
            Extract the value for the given setting from the given config files
            </summary>
            <remarks>Uses a simple text reader in case the file has malformed XML</remarks>
            <param name="configFilePaths">List of config files to check (in order)</param>
            <param name="settingName">Setting to find</param>
            <param name="settingValue">Output: the setting, if found</param>
            <returns>True if found, otherwise false</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetXmlConfigFileSetting(System.String,System.String,System.Boolean@,System.String@)">
            <summary>
            Extract the value for the given setting from the given config file
            </summary>
            <remarks>Uses a simple text reader in case the file has malformed XML</remarks>
            <param name="configFilePath">Config file path</param>
            <param name="settingName">Setting to find</param>
            <param name="configFileExists">Output: true if the file exists</param>
            <param name="settingValue">Output: the setting, if found</param>
            <returns>True if found, otherwise false</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.HandleParameterNotDefined(System.String)">
            <summary>
            Reports errors caused by required parameters that are missing
            </summary>
            <param name="parameterName"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.LoadMgrSettingsFromDB(System.Boolean,System.Int32)">
            <summary>
            Gets manager config settings from manager control DB (Manager_Control)
            </summary>
            <remarks>Performs retries if necessary</remarks>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.LoadMgrSettingsFromDBWork(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String}@,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Load manager settings from the database
            </summary>
            <param name="managerName">Manager name or manager group name</param>
            <param name="managerNameForConnectionString">Manager name to include in the database connection string</param>
            <param name="mgrSettingsFromDB">Output: manager settings</param>
            <param name="logConnectionErrors">When true, log connection errors</param>
            <param name="returnErrorIfNoParameters">When true, return an error if no parameters defined</param>
            <param name="retryCount">Number of times to retry (in case of a problem)</param>
            <returns>True if successful, otherwise false</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.LoadMgrSettingsFromFile(System.String)">
            <summary>
            Read settings from file AppName.exe.config
            If the file path ends with ".exe.config", other files with similar names are also read afterward
            (matching RegEx "AppName\.exe\..+config$")
            </summary>
            <remarks>Uses an XML reader instead of Properties.Settings.Default (to allow for non-standard .exe.config files)</remarks>
            <param name="configFilePath">Path to config file</param>
            <returns>Dictionary of settings as key/value pairs; null on error</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.LoadMgrSettingsFromFile(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Read settings from file AppName.exe.config
            </summary>
            <remarks>Uses an XML reader instead of Properties.Settings.Default (to allow for non-standard .exe.config files)</remarks>
            <param name="configFilePath">Path to config file</param>
            <param name="existingSettings">Existing settings dictionary; new settings will add to the existing, and overwrite any that match</param>
            <returns>Dictionary of settings as key/value pairs; null on error</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.ParseXMLSettings(System.Collections.IEnumerable,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Parse a list of XML nodes from AppName.exe.config or ManagerSettingsLocal.xml
            </summary>
            <param name="settingNodes">XML nodes, of the form </param>
            <param name="traceEnabled">If true, display trace statements</param>
            <param name="existingSettings">Existing settings dictionary; new settings will add to the existing, and overwrite any that match</param>
            <returns>Dictionary of settings</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.ShowDictionaryTrace(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Show contents of a dictionary
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.ShowTrace(System.String)">
            <summary>
            If TraceMode is true, show a message at the console, preceded by a time stamp
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.ShowTraceMessage(System.String)">
            <summary>
            Show a message at the console, preceded with a timestamp
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.StoreParameters(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String},System.String,System.Boolean)">
            <summary>
            Store manager settings, optionally skipping existing parameters
            </summary>
            <param name="mgrSettings">Manager settings</param>
            <param name="managerOrGroupName">Manager name or manager group name</param>
            <param name="skipExistingParameters">When true, skip existing parameters</param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetParam(System.String)">
            <summary>
            Gets a manager parameter
            </summary>
            <param name="itemKey"></param>
            <returns>Parameter value if found, otherwise an empty string</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetParam(System.String,System.String)">
            <summary>
            Gets a manager parameter
            </summary>
            <param name="itemKey">Parameter name</param>
            <param name="valueIfMissing">Value to return if the parameter does not exist</param>
            <returns>Parameter value if found, otherwise valueIfMissing</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetParam(System.String,System.Boolean)">
            <summary>
            Gets a manager parameter
            </summary>
            <param name="itemKey">Parameter name</param>
            <param name="valueIfMissing">Value to return if the parameter does not exist</param>
            <returns>Parameter value if found, otherwise valueIfMissing</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.GetParam(System.String,System.Int32)">
            <summary>
            Gets a manager parameter
            </summary>
            <param name="itemKey">Parameter name</param>
            <param name="valueIfMissing">Value to return if the parameter does not exist</param>
            <returns>Parameter value if found, otherwise valueIfMissing</returns>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.SetParam(System.String,System.String)">
            <summary>
            Adds or updates a manager parameter
            </summary>
            <param name="itemKey"></param>
            <param name="itemValue"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.OnCriticalErrorEvent(System.String)">
            <summary>
            Report an important error
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.ReportError(System.String,System.Boolean)">
            <summary>
            Raises a CriticalErrorEvent if criticalError is true and ParamsLoadedFromDB is false
            Otherwise, raises a normal error event
            </summary>
            <param name="errorMessage"></param>
            <param name="criticalError"></param>
        </member>
        <member name="M:PRISM.AppSettings.MgrSettings.ReportError(System.String,System.Exception)">
            <summary>
            Raises an error event that includes an exception
            </summary>
            <param name="errorMessage"></param>
            <param name="ex"></param>
        </member>
        <member name="T:PRISM.XMLFileReader">
            <summary>
            Tools for manipulating XML settings files
            </summary>
        </member>
        <member name="F:PRISM.XMLFileReader.mSectionNames">
            <summary>
            Cached list of section names
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReader.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the XMLFileReader (non case-sensitive)
            </summary>
            <param name="xmlFilename">XML file name</param>
            <param name="isCaseSensitive"></param>
            <param name="notifyOnException">When true, raise event InformationMessage if an exception occurs</param>
        </member>
        <member name="P:PRISM.XMLFileReader.XmlFilePath">
            <summary>
            Path of the XML settings file
            </summary>
        </member>
        <member name="P:PRISM.XMLFileReader.Initialized">
            <summary>
            This is set to True once the XML settings file has been successfully read
            </summary>
        </member>
        <member name="P:PRISM.XMLFileReader.CaseSensitive">
            <summary>
            This is True if setting names are case sensitive
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReader.SetNameCase(System.String)">
            <summary>
            Adjust the case of a setting name
            </summary>
            <param name="aName">Setting name</param>
            <returns>Returns the name as-is if CaseSensitive is true; otherwise, changes the name to lowercase</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetRoot">
            <summary>
            Get the root element of the XML document
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReader.GetLastSection">
            <summary>
            Get the last section in mSectionNames
            </summary>
            <returns>The last section as System.Xml.XmlElement</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetSection(System.String)">
            <summary>
            Get a section by name
            </summary>
            <param name="sectionName">Section name</param>
            <returns>The section as an XmlElement if found, otherwise null</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetItem(System.String,System.String)">
            <summary>
            Get the XML element for the given key in the given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Setting name</param>
            <returns>XML element, or null if no match</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.SetXMLSection(System.String,System.String)">
            <summary>
            Copies a section
            </summary>
            <param name="oldSection">The name of the section to copy</param>
            <param name="newSection">The new section name</param>
            <returns>True if success, false if the old section was not found or if newSection is an empty string</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.SetXMLValue(System.String,System.String,System.String)">
            <summary>
            Store the value of a setting in the given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Key name</param>
            <param name="newValue">Value for the key</param>
            <returns>True if success, false </returns>
        </member>
        <member name="M:PRISM.XMLFileReader.DeleteSection(System.String)">
            <summary>
            Delete a section by name
            </summary>
            <param name="sectionName">Section name</param>
            <returns>True if success, false if the section was not found</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.DeleteItem(System.String,System.String)">
            <summary>
            Delete an item from a section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Key name</param>
            <returns>True if success, false if the section and/or key was not found</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.SetXmlKey(System.String,System.String,System.String)">
            <summary>
            Stores the value for a given key in the given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Key name</param>
            <param name="newValue">The new value for the "key"</param>
            <returns>True if successful, otherwise false</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetXMLValue(System.String,System.String)">
             <summary>
             Get the value for the given key in the given section
             </summary>
             <param name="sectionName">Section name</param>
             <param name="keyName">Key name</param>
            <returns>The string in the "value" attribute of the key</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetXmlSectionComments(System.String)">
             <summary>
             Get the comments for a section name
             </summary>
             <param name="sectionName">Section name</param>
            <returns>List of comments</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.SetXMLComments(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Set the comments for a section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="comments">List of comments</param>
            <returns>True if successful, otherwise false</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.UpdateSections">
            <summary>
            Update the cached section names
            </summary>
        </member>
        <member name="P:PRISM.XMLFileReader.AllSections">
            <summary>
            Retrieve the section names
            </summary>
            <returns>List of section names</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetItemsInSection(System.String,PRISM.XMLFileReader.XMLItemTypeEnum)">
            <summary>
            Gets a list of items of the given type, in the given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="itemType">Item type</param>
            <returns>List of items</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.AllKeysInSection(System.String)">
            <summary>
            Gets a list of keys in a section
            </summary>
            <param name="sectionName">Section name</param>
            <returns>List key names</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.AllValuesInSection(System.String)">
            <summary>
            Gets a list of values in a section
            </summary>
            <param name="sectionName">Section name</param>
            <returns>List of values</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.AllItemsInSection(System.String)">
            <summary>
            Gets a list of items in a section (as key=value pairs)
            </summary>
            <param name="sectionName">Section name</param>
            <returns>List of items</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.GetCustomIniAttribute(System.String,System.String,System.String)">
            <summary>
            Gets the value of the given attribute for the given section and key
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Key name</param>
            <param name="attributeName">Attribute name</param>
            <returns>Attribute value, as a string</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.SetCustomIniAttribute(System.String,System.String,System.String,System.String)">
            <summary>
            Defines a custom attribute name
            If attributeValue is null, removes the attribute
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Key name</param>
            <param name="attributeName">Attribute name</param>
            <param name="attributeValue">Value for the attribute</param>
            <returns>True if successful, otherwise false</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.CreateSection(System.String)">
            <summary>
            Creates a section
            </summary>
            <param name="sectionName">Section name</param>
            <returns>True if successful, false if sectionName is empty or an error occurs</returns>
        </member>
        <member name="M:PRISM.XMLFileReader.ManualParseXmlOrIniFile(System.String)">
            <summary>
            Manually read a XML or .INI settings file line-by-line, extracting out any settings in the expected format
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:PRISM.XMLFileReader.ParseLineManual(System.String,System.Xml.XmlDocument)">
            <summary>
            Manually parses a line to extract the settings information
            Supports the traditional .Ini file format
            Also supports the 'key="KeyName" value="Value"' method used in XML settings files
            If successful, adds attributes to the doc variable</summary>
            <param name="dataLine">Data line</param>
            <param name="doc">XmlDocument to track</param>
            <returns>True if success, false if not a recognized line format</returns>
        </member>
        <member name="P:PRISM.XMLFileReader.OutputFilename">
            <summary>
            Output file name used by the Save method
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReader.Save">
            <summary>
            Save the settings to the XML file specified by OutputFilename
            </summary>
        </member>
        <member name="P:PRISM.XMLFileReader.XmlDoc">
            <summary>
            Gets the System.Xml.XmlDocument
            </summary>
        </member>
        <member name="P:PRISM.XMLFileReader.XML">
            <summary>
            Converts an XML document to a string
            </summary>
            <returns>The XML document formatted as a string</returns>
        </member>
        <member name="T:PRISM.XMLFileReaderNotInitializedException">
            <summary>
            Exception thrown when a method is accessed before the reader has been initialized
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReaderNotInitializedException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReaderNotInitializedException.#ctor(System.String)">
            <summary>
            Constructor that takes a messages
            </summary>
        </member>
        <member name="M:PRISM.XMLFileReaderNotInitializedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor that takes a message and inner exception
            </summary>
        </member>
        <member name="P:PRISM.XMLFileReaderNotInitializedException.Message">
            <summary>
            Returns a message describing this exception
            </summary>
        </member>
        <member name="T:PRISM.XmlSettingsFileAccessor">
            <summary>
            This class can be used to read or write settings in an Xml settings file
            Based on a class from the DMS Analysis Manager software written by Dave Clark and Gary Kiebel (PNNL, Richland, WA)
            Additional features added by Matthew Monroe for the Department of Energy (PNNL, Richland, WA) in October 2003
            </summary>
        </member>
        <member name="P:PRISM.XmlSettingsFileAccessor.XMLFilePath">
            <summary>
            XML file path
            </summary>
            <remarks>Call LoadSettings to initialize, even if simply saving settings</remarks>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.#ctor">
            <summary>
            Constructor
            </summary>
            <remarks>Call LoadSettings to initialize, even if simply saving settings</remarks>
        </member>
        <member name="T:PRISM.XmlSettingsFileAccessor.CachedSectionInfo">
            <summary>
            Stores the section name whose keys are cached
            </summary>
            <remarks>The section name is capitalized identically to that actually present in the Xml file</remarks>
        </member>
        <member name="F:PRISM.XmlSettingsFileAccessor.mXMLFileAccessor">
            <summary>
            XML file reader
            </summary>
        </member>
        <member name="F:PRISM.XmlSettingsFileAccessor.mSectionNames">
            <summary>
            When mCaseSensitive = False, SectionNames stores mapping between lowercase section name and actual section name stored in file
            If section is present more than once in file, only grabs the last occurrence of the section
            When mCaseSensitive = True, the mappings in SectionNames are effectively not used
            </summary>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.LoadSettings">
            <summary>
            Loads the settings for the defined Xml Settings File; assumes names are not case sensitive
            </summary>
            <returns>True if successfully loaded, otherwise false</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.LoadSettings(System.String)">
            <summary>
            Loads the settings for the defined Xml Settings File; assumes names are not case sensitive
            </summary>
            <param name="XmlSettingsFilePath">The path to the XML settings file</param>
            <returns>True if successfully loaded, otherwise false</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.LoadSettings(System.String,System.Boolean)">
            <summary>
            Loads the settings for the defined Xml Settings File
            </summary>
            <remarks>If case sensitive names are in place, all section and key names must be lowercase</remarks>
            <param name="XmlSettingsFilePath">The path to the XML settings file</param>
            <param name="isCaseSensitive">Case sensitive names if True. Non-case sensitive if false</param>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.ManualParseXmlOrIniFile(System.String)">
            <summary>
            Parse an XML settings file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SaveSettings">
            <summary>
            Saves the settings for the defined Xml Settings File
            </summary>
            <remarks>You must call LoadSettings to initialize the class prior to setting any values</remarks>
            <returns>True if successfully saved, otherwise false</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SectionPresent(System.String)">
            <summary>
            Checks if a section is present in the settings file
            </summary>
            <param name="sectionName">The name of the section to look for</param>
            <returns>True if the section is present</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.CacheKeyNames(System.String)">
            <summary>
            Examines the Key Names for the given section, storing them in mCachedSection
            </summary>
            <remarks>This is done so that this class will know the correct capitalization for the key names</remarks>
            <param name="sectionName"></param>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.CacheSectionNames">
            <summary>
            Examines the Section Names in the XML file
            </summary>
            <remarks>This is done so that this class will know the correct capitalization for the section names</remarks>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetCachedKeyName(System.String,System.String)">
            <summary>
            Looks up the correct capitalization for the given key in the given section
            </summary>
            <param name="sectionName"></param>
            <param name="keyName"></param>
            <returns>Key name if found, or an empty string</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetCachedSectionName(System.String)">
            <summary>
            Determines the correct capitalization for sectionName
            </summary>
            <param name="sectionName"></param>
            <returns>Name if found, or an empty string</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.String,System.Boolean@)">
            <summary>
            Get the value of the given parameter in section "sectionName"
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>The string tracked by the "value" attribute</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Boolean,System.Boolean@)">
            <summary>
            Get the boolean value of the given parameter in section "sectionName"
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>True if the "value" attribute is "true"; Otherwise, returns boolean False</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Int16)">
            <summary>
            Get the value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>A short</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Int32)">
            <summary>
            Get the value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>An integer</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Int64)">
            <summary>
            Get the value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>A long</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Single)">
            <summary>
            Get the value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>A float</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Double)">
            <summary>
            Get the value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>A double</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.String)">
            <summary>
            Get the string value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>A string</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Boolean)">
            <summary>
            Get the boolean value for a given parameter in a given section
            </summary>
            <param name="sectionName">Section name</param>
            <param name="keyName">Parameter name</param>
            <param name="valueIfMissing">Value if missing</param>
            <returns>A boolean</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Int16,System.Boolean@)">
            <summary>
            Get the numeric value for a given parameter in a given section
            </summary>
            <remarks>If "value" is "true" returns -1; if "value" is "false" returns 0</remarks>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>
            The numeric value of the "value" attribute as a short
            </returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Int32,System.Boolean@)">
            <summary>
            Get the numeric value for a given parameter in a given section
            </summary>
            <remarks>If "value" is "true" returns -1; if "value" is "false" returns 0</remarks>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>
            The numeric value of the "value" attribute as an integer
            </returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Int64,System.Boolean@)">
            <summary>
            Get the numeric value for a given parameter in a given section
            </summary>
            <remarks>If "value" is "true" returns -1; if "value" is "false" returns 0</remarks>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>
            The numeric value of the "value" attribute as a long
            </returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Single,System.Boolean@)">
            <summary>
            Get the numeric value for a given parameter in a given section
            </summary>
            <remarks>If "value" is "true" returns -1; if "value" is "false" returns 0</remarks>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>
            The numeric value of the "value" attribute as a float
            </returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.GetParam(System.String,System.String,System.Double,System.Boolean@)">
            <summary>
            Get the numeric value for a given parameter in a given section
            </summary>
            <remarks>If "value" is "true" returns -1; if "value" is "false" returns 0</remarks>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="valueIfMissing">Value to return if "sectionName" or "keyName" is missing</param>
            <param name="valueNotPresent">Output: True if "sectionName" or "keyName" is missing</param>
            <returns>
            The numeric value of the "value" attribute as a double
            </returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetIniFilePath(System.String)">
            <summary>
            Legacy method name; calls SetXMLFilePath
            </summary>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetXMLFilePath(System.String)">
            <summary>
            Sets the path to the Xml Settings File
            </summary>
            <param name="XmlSettingsFilePath">The path to the XML settings file</param>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.String)">
            <summary>
            Sets a new string value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.Boolean)">
            <summary>
            Sets a new boolean value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.Int16)">
            <summary>
            Sets a new short value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.Int32)">
            <summary>
            Sets a new integer value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.Int64)">
            <summary>
            Sets a new Long value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.Single)">
            <summary>
            Sets a new float value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.SetParam(System.String,System.String,System.Double)">
            <summary>
            Sets a new double value for the "value" attribute
            </summary>
            <param name="sectionName">The name of the section</param>
            <param name="keyName">The name of the key</param>
            <param name="newValue">The new value for the "value"</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.XmlSettingsFileAccessor.RenameSection(System.String,System.String)">
            <summary>
            Rename a section
            </summary>
            <param name="sectionNameOld">The name of the old XML section name</param>
            <param name="sectionNameNew">The new name for the XML section</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="T:PRISM.DatabaseUtils.DataTableUtils">
            <summary>
            Methods for appending columns to a data table
            </summary>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnToTable``1(System.Data.DataTable,System.String,System.Type,``0,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Append a column of the given type to the DataTable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dataTable"></param>
            <param name="columnName"></param>
            <param name="columnType"></param>
            <param name="defaultValue"></param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table</param>
            <param name="isUnique"></param>
            <param name="autoIncrement"></param>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnDateToTable(System.Data.DataTable,System.String,System.DateTime,System.Boolean,System.Boolean)">
            <summary>
            Append a date column to the data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="columnName">Column name</param>
            <param name="defaultDate">Default value</param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table</param>
            <param name="isUnique">True if the value in each row of the column must be unique</param>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnDoubleToTable(System.Data.DataTable,System.String,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Append a double column to the data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="columnName">Column name</param>
            <param name="defaultValue">Default value</param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table</param>
            <param name="isUnique"></param>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnFloatToTable(System.Data.DataTable,System.String,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Append a float (single) column to the data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="columnName">Column name</param>
            <param name="defaultValue">Default value</param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table</param>
            <param name="isUnique"></param>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnIntegerToTable(System.Data.DataTable,System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Append an integer column to the data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="columnName">Column name</param>
            <param name="defaultValue">Default value (ignored if autoIncrement is true)</param>
            <param name="autoIncrement">True if this is an auto incremented value</param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table (forced to true if autoIncrement is true)</param>
            <param name="isUnique">True if the value in each row of the column must be unique</param>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnLongToTable(System.Data.DataTable,System.String,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Append a long integer column to the data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="columnName">Column name</param>
            <param name="defaultValue">Default value (ignored if autoIncrement is true)</param>
            <param name="autoIncrement">True if this is an auto incremented value</param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table (forced to true if autoIncrement is true)</param>
            <param name="isUnique">True if the value in each row of the column must be unique</param>
        </member>
        <member name="M:PRISM.DatabaseUtils.DataTableUtils.AppendColumnStringToTable(System.Data.DataTable,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Append a string column to the data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="columnName">Column name</param>
            <param name="defaultValue">Default value</param>
            <param name="isReadOnly">True if the column value cannot be updated after a row is added to a table</param>
            <param name="isUnique">True if the value in each row of the column must be unique</param>
        </member>
        <member name="T:PRISM.DBTools">
            <summary>
            Tools to retrieve data from a database
            </summary>
        </member>
        <member name="F:PRISM.DBTools.DEFAULT_SP_TIMEOUT_SEC">
            <summary>
            Default timeout length, in seconds, when waiting for a query to finish running
            </summary>
        </member>
        <member name="F:PRISM.DBTools.mTimeoutSeconds">
            <summary>
            Timeout length, in seconds, when waiting for a query to finish running
            </summary>
        </member>
        <member name="P:PRISM.DBTools.ConnectStr">
            <summary>
            Database connection string
            </summary>
        </member>
        <member name="P:PRISM.DBTools.TimeoutSeconds">
            <summary>
            Timeout length, in seconds, when waiting for a query to finish executing
            </summary>
        </member>
        <member name="M:PRISM.DBTools.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="connectionString">Database connection string</param>
        </member>
        <member name="M:PRISM.DBTools.GetString(System.Object)">
            <summary>
            Converts an database field value to a string, checking for null values
            This is intended to be used with DataSet objects retrieved via a SqlDataAdapter
            </summary>
            <param name="dbValue">Value from database</param>
            <returns>If dbValue is DBNull, returns "", otherwise returns the string representation of dbValue</returns>
        </member>
        <member name="M:PRISM.DBTools.GetFloat(System.Object)">
            <summary>
            Converts an database field value to a float (single), checking for null values
            This is intended to be used with DataSet objects retrieved via a SqlDataAdapter
            </summary>
            <remarks>An exception will be thrown if the value is not numeric</remarks>
            <param name="dbValue">Value from database</param>
            <returns>If dbValue is DBNull, returns 0.0, otherwise returns the string representation of dbValue</returns>
        </member>
        <member name="M:PRISM.DBTools.GetDouble(System.Object)">
            <summary>
            Converts an database field value to a double, checking for null values
            This is intended to be used with DataSet objects retrieved via a SqlDataAdapter
            </summary>
            <remarks>An exception will be thrown if the value is not numeric</remarks>
            <param name="dbValue">Value from database</param>
            <returns>If dbValue is DBNull, returns 0.0, otherwise returns the string representation of dbValue</returns>
        </member>
        <member name="M:PRISM.DBTools.GetInteger(System.Object)">
            <summary>
            Converts an database field value to an integer (Int32), checking for null values
            This is intended to be used with DataSet objects retrieved via a SqlDataAdapter
            </summary>
            <remarks>An exception will be thrown if the value is not numeric</remarks>
            <param name="dbValue">Value from database</param>
            <returns>If dbValue is DBNull, returns 0, otherwise returns the string representation of dbValue</returns>
        </member>
        <member name="M:PRISM.DBTools.GetLong(System.Object)">
            <summary>
            Converts an database field value to a long integer (Int64), checking for null values
            This is intended to be used with DataSet objects retrieved via a SqlDataAdapter
            </summary>
            <remarks>An exception will be thrown if the value is not numeric</remarks>
            <param name="dbValue">Value from database</param>
            <returns>If dbValue is DBNull, returns 0, otherwise returns the string representation of dbValue</returns>
        </member>
        <member name="M:PRISM.DBTools.GetColumnMapping(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Get a mapping from column name to column index, based on column order
            </summary>
            <remarks>Use in conjunction with GetColumnValue, e.g. GetColumnValue(resultRow, columnMap, "ID")</remarks>
            <param name="columns"></param>
            <returns>Mapping from column name to column index</returns>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String)">
            <summary>
            Get the string value for the specified column
            </summary>
            <remarks>The returned value could be null, but note that GetQueryResults converts all Null strings to string.Empty</remarks>
            <param name="resultRow">Row of results, as returned by GetQueryResults</param>
            <param name="columnMap">Map of column name to column index, as returned by GetColumnMapping</param>
            <param name="columnName">Column Name</param>
            <returns>String value</returns>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String,System.Int32)">
            <summary>
            Get the integer value for the specified column, or the default value if the value is empty or non-numeric
            </summary>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String,System.Int32,System.Boolean@)">
            <summary>
            Get the integer value for the specified column, or the default value if the value is empty or non-numeric
            </summary>
            <param name="resultRow">Row of results, as returned by GetQueryResults</param>
            <param name="columnMap">Map of column name to column index, as returned by GetColumnMapping</param>
            <param name="columnName">Column Name</param>
            <param name="defaultValue">Default value</param>
            <param name="validNumber">Output: set to true if the column contains an integer</param>
            <returns>Integer value</returns>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String,System.Double)">
            <summary>
            Get the double value for the specified column, or the default value if the value is empty or non-numeric
            </summary>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String,System.Double,System.Boolean@)">
            <summary>
            Get the double value for the specified column, or the default value if the value is empty or non-numeric
            </summary>
            <param name="resultRow">Row of results, as returned by GetQueryResults</param>
            <param name="columnMap">Map of column name to column index, as returned by GetColumnMapping</param>
            <param name="columnName">Column Name</param>
            <param name="defaultValue">Default value</param>
            <param name="validNumber">Output: set to true if the column contains a double (or integer)</param>
            <returns>Double value</returns>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String,System.DateTime)">
            <summary>
            Get the date value for the specified column, or the default value if the value is empty or non-numeric
            </summary>
        </member>
        <member name="M:PRISM.DBTools.GetColumnValue(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.String,System.DateTime,System.Boolean@)">
            <summary>
            Get the date value for the specified column, or the default value if the value is empty or non-numeric
            </summary>
            <param name="resultRow">Row of results, as returned by GetQueryResults</param>
            <param name="columnMap">Map of column name to column index, as returned by GetColumnMapping</param>
            <param name="columnName">Column Name</param>
            <param name="defaultValue">Default value</param>
            <param name="validNumber">Output: set to true if the column contains a valid date</param>
            <returns>True or false</returns>
        </member>
        <member name="M:PRISM.DBTools.OnInfoMessage(System.Object,System.Data.SqlClient.SqlInfoMessageEventArgs)">
            <summary>
            This method is an event handler for InfoMessage event
            </summary>
            <remarks>
            The errors and warnings sent from the SQL server are caught here
            </remarks>
        </member>
        <member name="M:PRISM.DBTools.GetDiscDataSet(System.String,System.Data.DataSet@,System.Int32@)">
            <summary>
            This method gets a disconnected DataSet as specified by the SQL statement
            </summary>
            <param name="sqlQuery">A SQL string</param>
            <param name="DS">A DataSet</param>
            <param name="rowCount">A row counter</param>
            <returns>Returns a disconnected DataSet as specified by the SQL statement</returns>
        </member>
        <member name="M:PRISM.DBTools.GetQueryResults(System.String,System.Collections.Generic.List{System.Collections.Generic.List{System.String}}@,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Run a query against a SQL Server database, return the results as a list of strings
            </summary>
            <remarks>
            Uses the connection string passed to the constructor of this class
            Null values are converted to empty strings
            Numbers are converted to their string equivalent
            By default, retries the query up to 3 times
            </remarks>
            <param name="sqlQuery">Query to run</param>
            <param name="results">Results (list of list of strings)</param>
            <param name="callingFunction">Name of the calling method (for logging purposes)</param>
            <param name="retryCount">Number of times to retry (in case of a problem)</param>
            <param name="maxRowsToReturn">Maximum rows to return; 0 to return all rows</param>
            <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.DBTools.UpdateDatabase(System.String,System.Int32@)">
            <summary>
            This method updates a database table as specified in the SQL statement
            </summary>
            <param name="SQL">A SQL string</param>
            <param name="affectedRows">Affected Rows to be updated</param>
            <returns>Returns Boolean showing if the database was updated</returns>
        </member>
        <member name="T:PRISM.ExecuteDatabaseSP">
            <summary>
            Tools to execute a stored procedure
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.RET_VAL_OK">
            <summary>
            Return value indicating everything is OK
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.RET_VAL_EXCESSIVE_RETRIES">
            <summary>
            Typically caused by timeout expired
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.RET_VAL_DEADLOCK">
            <summary>
            Typically caused by transaction (Process ID 143) was deadlocked on lock resources with another process and has been chosen as the deadlock victim
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.DEFAULT_SP_RETRY_COUNT">
            <summary>
            Default number of times to retry calling the stored procedure
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.DEFAULT_SP_RETRY_DELAY_SEC">
            <summary>
            Default delay, in seconds, when retrying a stored procedure call
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.DEFAULT_SP_TIMEOUT_SEC">
            <summary>
            Default timeout length, in seconds, when waiting for a stored procedure to finish executing
            </summary>
        </member>
        <member name="F:PRISM.ExecuteDatabaseSP.mTimeoutSeconds">
            <summary>
            Timeout length, in seconds, when waiting for a stored procedure to finish executing
            </summary>
        </member>
        <member name="P:PRISM.ExecuteDatabaseSP.DBconnectionString">
            <summary>
            Database connection string
            </summary>
        </member>
        <member name="P:PRISM.ExecuteDatabaseSP.DebugMessagesEnabled">
            <summary>
            Set to True to raise debug events
            </summary>
        </member>
        <member name="P:PRISM.ExecuteDatabaseSP.TimeoutSeconds">
            <summary>
            Timeout length, in seconds, when waiting for a stored procedure to finish executing
            </summary>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.#ctor(System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.OnInfoMessage(System.Object,System.Data.SqlClient.SqlInfoMessageEventArgs)">
            <summary>
            Event handler for InfoMessage event
            </summary>
            <remarks>Errors and warnings from SQL Server are caught here</remarks>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.ExecuteSP(System.Data.SqlClient.SqlCommand,System.Collections.Generic.List{System.Collections.Generic.List{System.String}}@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Method for executing a db stored procedure if a data table is to be returned
            </summary>
            <param name="spCmd">SQL command object containing stored procedure params</param>
            <param name="results">If SP successful, contains Results (list of list of strings)</param>
            <param name="retryCount">Maximum number of times to attempt to call the stored procedure</param>
            <param name="maxRowsToReturn">Maximum rows to return; 0 for no limit</param>
            <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
            <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.ExecuteSP(System.Data.SqlClient.SqlCommand)">
            <summary>
            Method for executing a db stored procedure, assuming no data table is returned; will retry the call to the procedure up to DEFAULT_SP_RETRY_COUNT=3 times
            </summary>
            <param name="spCmd">SQL command object containing stored procedure params</param>
            <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.ExecuteSP(System.Data.SqlClient.SqlCommand,System.Int32)">
            <summary>
            Method for executing a db stored procedure, assuming no data table is returned
            </summary>
            <param name="spCmd">SQL command object containing stored procedure params</param>
            <param name="maxRetryCount">Maximum number of times to attempt to call the stored procedure</param>
            <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.ExecuteSP(System.Data.SqlClient.SqlCommand,System.Int32,System.Int32)">
            <summary>
            Method for executing a db stored procedure, assuming no data table is returned
            </summary>
            <param name="spCmd">SQL command object containing stored procedure params</param>
            <param name="maxRetryCount">Maximum number of times to attempt to call the stored procedure</param>
            <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
            <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.ExecuteSP(System.Data.SqlClient.SqlCommand,System.Int32,System.String@)">
            <summary>
            Method for executing a db stored procedure when a data table is not returned
            </summary>
            <remarks>No logging is performed by this procedure</remarks>
            <param name="spCmd">SQL command object containing stored procedure params</param>
            <param name="maxRetryCount">Maximum number of times to attempt to call the stored procedure</param>
            <param name="errorMessage">Error message (output)</param>
            <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        </member>
        <member name="M:PRISM.ExecuteDatabaseSP.ExecuteSP(System.Data.SqlClient.SqlCommand,System.Int32,System.String@,System.Int32)">
            <summary>
            Method for executing a db stored procedure when a data table is not returned
            </summary>
            <remarks>No logging is performed by this procedure</remarks>
            <param name="spCmd">SQL command object containing stored procedure params</param>
            <param name="maxRetryCount">Maximum number of times to attempt to call the stored procedure</param>
            <param name="errorMessage">Error message (output)</param>
            <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
            <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        </member>
        <member name="T:PRISM.ProgressData">
            <summary>
            Add functionality to progress reporting using <see cref="T:System.IProgress`1"/>,
            including facilitating child process progress as a subset of overall progress
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.Status">
            <summary>
            Status string - for reporting textual information about the current task
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.StatusInternal">
            <summary>
            Internal status string - for tracking nested progress status
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.ProgressObj">
            <summary>
            Referenced <see cref="T:System.IProgress`1"/> object, that all updates are pushed out to
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.ThrowExceptionOnBackwardsProgress">
            <summary>
            When true, anything that will cause progress to go backwards will cause an exception;
            otherwise, such changes are silently handled to prevent backwards progress
            Should not be true in general release code
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.PreventBackwardsProgress">
            <summary>
            When set to true, logic is used that will prevent progress from jumping backwards
            (errors are silently ignored; see <see cref="P:PRISM.ProgressData.ThrowExceptionOnBackwardsProgress"/> to trigger exceptions instead)
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.Percent">
            <summary>
            The current percent progress of the task. Updated using <see cref="M:PRISM.ProgressData.Report(System.Double,System.String)"/> or variants
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.IsPartialRange">
            <summary>
            Controls whether the progress reporting will be grouped into ranges
            </summary>
            <remarks>
            Setting this to "true" will reset MinPercentage and MaxPercentage to 0
            </remarks>
        </member>
        <member name="P:PRISM.ProgressData.MinPercentage">
            <summary>
            Must be less than current MaxPercentage
            </summary>
            <remarks>Will set IsPartialRange to true</remarks>
        </member>
        <member name="P:PRISM.ProgressData.MaxPercentage">
            <summary>
            Must be greater than current MinPercentage
            </summary>
            <remarks>Will set IsPartialRange to true</remarks>
        </member>
        <member name="P:PRISM.ProgressData.UpdateFrequencySeconds">
            <summary>
            Throttling for console output - used with ShouldUpdate() to provide a simple throttle to reduce the console output
            </summary>
        </member>
        <member name="P:PRISM.ProgressData.LastUpdated">
            <summary>
            Last output time, for throttling updates for console output
            </summary>
            <remarks>static for the case of multiple ProgressData objects being fed to "Progress.Report()"</remarks>
        </member>
        <member name="P:PRISM.ProgressData.HasUsedPartialRange">
            <summary>
            Track if a partial range (not 0-100%) has been set previously. This should never be set to false outside of object construction
            </summary>
        </member>
        <member name="F:PRISM.ProgressData._hasUsedPartialRangeWithAReallyLongAndNastyNameSoThatNoOneEverWantsToUseUtBesidesWhereItIsSupposedToBeUsed">
            <summary>
            Backing variable for HasUsedPartialRange. ONLY USE INSIDE OF HasUsedPartialRange GETTER/SETTER
            </summary>
        </member>
        <member name="M:PRISM.ProgressData.#ctor(System.IProgress{PRISM.ProgressData},System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="progress">The progress object that "ProgressData.Report" should call "Report" on</param>
            <param name="preventBackwardsProgress">Set to false to disable the logic preventing reverse progress</param>
        </member>
        <member name="M:PRISM.ProgressData.StepRange(System.Double,System.String)">
            <summary>
            Change to a new range block
            </summary>
            <remarks>Will set IsPartialRange to true</remarks>
            <remarks>If current max percent is 100, the new max percent can be any value between 0 and 100</remarks>
            <param name="newMaxPercentage">New max percent for range, must be greater than current max percent</param>
            <param name="newStatus">Updated status string, null for no update</param>
        </member>
        <member name="M:PRISM.ProgressData.CheckSetMinMaxRange(System.Double,System.Double)">
            <summary>
            Perform validity checks on new min/max percent values, and then set them accordingly
            </summary>
            <param name="newMin"></param>
            <param name="newMax"></param>
        </member>
        <member name="M:PRISM.ProgressData.UpdatePercent(System.Double)">
            <summary>
            Update percent, and return object. For single-lining a progress update and report with <see cref="M:System.IProgress`1.Report(`0)"/>
            </summary>
            <param name="pct"></param>
        </member>
        <member name="M:PRISM.ProgressData.ShouldUpdate">
            <summary>
            This method is used to limit output frequency, when outputting to console
            </summary>
        </member>
        <member name="M:PRISM.ProgressData.Report(System.String)">
            <summary>
            Updates the status, then calls the stored progress object's "Report"
            </summary>
            <param name="newStatus">Updated status string</param>
        </member>
        <member name="M:PRISM.ProgressData.Report(System.Double,System.String)">
            <summary>
            Updates the percent, then calls the stored progress object's "Report"
            </summary>
            <param name="pct">percent progress, 0 to 100</param>
            <param name="newStatus">Updated status string, null for no update</param>
        </member>
        <member name="M:PRISM.ProgressData.ReportDecimal(System.Double,System.String)">
            <summary>
            Updates the percent, then calls the stored progress object's "Report"
            </summary>
            <param name="pct">percent progress, 0 to 1</param>
            <param name="newStatus">Updated status string, null for no update</param>
        </member>
        <member name="M:PRISM.ProgressData.Report(System.Double,System.Double,System.String)">
            <summary>
            Updates the percent, then calls the stored progress object's "Report"
            </summary>
            <param name="count">The count progress, or numerator</param>
            <param name="total">The total number of objects to be counted, or denominator</param>
            <param name="newStatus">Updated status string, null for no update</param>
        </member>
        <member name="T:PRISM.DataUtils.StringSimilarityTool">
            <summary>
            This class implements a string comparison algorithm based on character pair similarity
            Original algorithm developed by Simon White in 1992: http://www.catalysoft.com/articles/StrikeAMatch.html
            Converted to C# by Michael La Voie in 2009: https://stackoverflow.com/a/1663745/1179467
            Expanded by Matthew Monroe in 2019 to support single letter words (or digits)
            </summary>
        </member>
        <member name="M:PRISM.DataUtils.StringSimilarityTool.CompareStrings(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Compares two strings based on letter pair matches
            </summary>
            <param name="text1"></param>
            <param name="text2"></param>
            <param name="removeNumbers">When true, remove digits from the text before comparing</param>
            <param name="removeSymbolsAndWhitespace">When true, remove symbols (anything not a letter or number) and whitespace from the text before comparing</param>
            <param name="caseSensitive">When true, require matching capitalization</param>
            <returns>Similarity score, ranging from 0.0 to 1.0 where 1.0 is a perfect match</returns>
        </member>
        <member name="M:PRISM.DataUtils.StringSimilarityTool.CombineAllMatches(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Concatenate all RegEx matches in text
            </summary>
            <param name="matcher"></param>
            <param name="text"></param>
        </member>
        <member name="M:PRISM.DataUtils.StringSimilarityTool.LetterPairs(System.String)">
            <summary>
            Generates an array containing every two consecutive letters in the input string
            </summary>
            <remarks>If the text is a single character, returns an array of length 1 with that single character</remarks>
            <param name="text"></param>
            <returns>List of pairs</returns>
        </member>
        <member name="M:PRISM.DataUtils.StringSimilarityTool.WordLetterPairs(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets all letter pairs for each individual word in the string
            </summary>
            <param name="textBob"></param>
            <param name="removeNumbers">When true, remove digits from the text before comparing</param>
            <param name="removeSymbolsAndWhitespace">When true, remove symbols (anything not a letter or number) and whitespace from the text before comparing</param>
            <param name="caseSensitive">When true, require matching capitalization</param>
            <returns>List of word letter pairs</returns>
        </member>
        <member name="T:PRISM.DataUtils.StringToValueUtils">
            <summary>
            Utilities for parsing values from strings
            </summary>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.CBoolSafe(System.String,System.Boolean)">
            <summary>
            Converts a string value of True or False to a boolean equivalent
            </summary>
            <remarks>Returns false if unable to convert</remarks>
            <param name="value"></param>
            <param name="defaultValue">Boolean value to return if value is empty or cannot be converted</param>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.CDoubleSafe(System.String,System.Double)">
            <summary>
            Converts value to an integer
            </summary>
            <param name="value"></param>
            <param name="defaultValue">Double to return if value is not numeric</param>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.CFloatSafe(System.String,System.Single)">
            <summary>
            Converts value to a float
            </summary>
            <param name="value"></param>
            <param name="defaultValue">Float to return if value is not numeric</param>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.CIntSafe(System.String,System.Int32)">
            <summary>
            Converts value to an integer
            </summary>
            <param name="value"></param>
            <param name="defaultValue">Integer to return if value is not numeric</param>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.CShortSafe(System.String,System.Int16)">
            <summary>
            Converts value to a short integer
            </summary>
            <param name="value"></param>
            <param name="defaultValue">Short to return if value is not numeric</param>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.IsNumber(System.String)">
            <summary>
            Check whether a string can be converted to a double
            </summary>
            <param name="value"></param>
            <returns>True if successful, otherwise false</returns>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.TryGetValue(System.String[],System.Int32,System.String@)">
            <summary>
            Tries to retrieve the string value at index columnIndex in dataColumns[]
            </summary>
            <param name="dataColumns">Array of strings</param>
            <param name="columnIndex">Column index</param>
            <param name="value">Output: string in the given column; empty string if columnIndex is out of range</param>
            <returns>
            True if success; False if columnIndex is less than 0 or columnIndex is out of range for the dataColumns array
            </returns>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.TryGetValueInt(System.String[],System.Int32,System.Int32@)">
            <summary>
            Tries to convert the text at index columnIndex of dataColumns[] to an integer
            </summary>
            <param name="dataColumns">Array of strings</param>
            <param name="columnIndex">Column index</param>
            <param name="value">Output: integer in the given column; 0 if columnIndex is out of range or cannot be converted to an integer</param>
            <returns>
            True if success; False if columnIndex is less than 0, columnIndex is out of range for the dataColumns array,
            or the text cannot be converted to an integer
            </returns>
        </member>
        <member name="M:PRISM.DataUtils.StringToValueUtils.TryGetValueFloat(System.String[],System.Int32,System.Single@)">
            <summary>
            Tries to convert the text at index columnIndex of dataColumns[] to a float
            </summary>
            <param name="dataColumns">Array of strings</param>
            <param name="columnIndex">Column index</param>
            <param name="value">Output: float in the given column; 0 if columnIndex is out of range or cannot be converted to a float</param>
            <returns>
            True if success; False if columnIndex is less than 0, columnIndex is out of range for the dataColumns array,
            or the text cannot be converted to a float
            </returns>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessDirectoriesBase">
            <summary>
            This class can be used as a base class for classes that process a directory or directories
            </summary>
            <remarks>
            This class contains simple error codes that can be set from any derived classes;
            the derived classes can also set their own local error codes
            </remarks>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes">
            <summary>
            Error code enums
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.NoError">
            <summary>
            No error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.InvalidInputDirectoryPath">
            <summary>
            Invalid input directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.InvalidInputFolderPath">
            <summary>
            Invalid input directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.InvalidOutputDirectoryPath">
            <summary>
            Invalid output directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.InvalidOutputFolderPath">
            <summary>
            Invalid output directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.ParameterFileNotFound">
            <summary>
            Parameter file not found
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.InvalidParameterFile">
            <summary>
            Invalid parameter file
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.FilePathError">
            <summary>
            File path error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.LocalizedError">
            <summary>
            Localized error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes.UnspecifiedError">
            <summary>
            Unspecified error
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessDirectoriesBase.ErrorCode">
            <summary>
            Error code reflecting processing outcome
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessDirectoriesBase.DirectoriesProcessed">
            <summary>
            Number of directories processed successfully when using ProcessAndRecurseDirectories or ProcessDirectoriesWildcard
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessDirectoriesBase.DirectoryProcessErrors">
            <summary>
            Number of directories that could not be processed when using ProcessAndRecurseDirectories or ProcessDirectoriesWildcard
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.CleanupPaths(System.String@,System.String@)">
            <summary>
            Cleanup file/directory paths
            </summary>
            <param name="inputFileOrDirectoryPath"></param>
            <param name="outputDirectoryPath"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.CleanupDirectoryPaths(System.String@,System.String@)">
            <summary>
            Make sure inputDirectoryPath points to a valid directory and validate the output directory (defining it if null or empty)
            </summary>
            <remarks>Create outputDirectoryPath if it does not exist</remarks>
            <param name="inputDirectoryPath"></param>
            <param name="outputDirectoryPath"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.GetBaseClassErrorMessage">
            <summary>
            Get the base class error message, or an empty string if no error
            </summary>
            <returns>Error message</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesWildcard(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Process one or more directories
            </summary>
            <param name="inputDirectoryPath">Match spec for finding directories, can contain * and ?</param>
            <param name="outputDirectoryAlternatePath">Alternate output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="resetErrorCode">If True, reset ErrorCode</param>
            <returns> True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectory(System.String)">
            <summary>
            Process a single directory
            </summary>
            <param name="inputDirectoryPath">Input directory path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectory(System.String,System.String,System.String)">
            <summary>
            Process a single directory
            </summary>
            <param name="inputDirectoryPath">Input directory path</param>
            <param name="outputDirectoryAlternatePath">Alternate output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectory(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Process a single directory
            </summary>
            <param name="inputDirectoryPath">Input directory path</param>
            <param name="outputDirectoryAlternatePath">Alternate directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="resetErrorCode">If true, reset the error code</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessAndRecurseDirectories(System.String,System.Int32)">
            <summary>
            Process directories and subdirectories
            </summary>
            <param name="inputDirectoryPath"></param>
            <param name="maxLevelsToRecurse"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.ProcessAndRecurseDirectories(System.String,System.String,System.String,System.Int32)">
            <summary>
            Process directories and subdirectories
            </summary>
            <remarks>Calls ProcessDirectories for all matching directories in inputDirectoryPath</remarks>
            <param name="inputDirectoryPath">Input directory path (supports wildcards)</param>
            <param name="outputDirectoryAlternatePath">Alternate directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="maxLevelsToRecurse">
            When 0 or negative, recurse infinitely
            When 1, only process the current directory
            When 2, process the current directory and files in its subdirectories
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessDirectoriesBase.SetBaseClassErrorCode(PRISM.FileProcessor.ProcessDirectoriesBase.ProcessDirectoriesErrorCodes)">
            <summary>
            Update the base class error code
            </summary>
            <param name="newErrorCode"></param>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesBase">
            <summary>
            This class can be used as a base class for classes that process a file or files, and create
            new output files in an output directory.  Note that this class contains simple error codes that
            can be set from any derived classes.  The derived classes can also set their own local error codes
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes">
            <summary>
            Error code enums
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.NoError">
            <summary>
            No error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.InvalidInputFilePath">
            <summary>
            Invalid input file path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.InvalidOutputDirectoryPath">
            <summary>
            Invalid output directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.ParameterFileNotFound">
            <summary>
            Parameter file not found
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.InvalidParameterFile">
            <summary>
            Invalid parameter file
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.FilePathError">
            <summary>
            File path error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.LocalizedError">
            <summary>
            Localized error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes.UnspecifiedError">
            <summary>
            Unspecified error
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes">
            <summary>
            Error code enums
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.NoError">
            <summary>
            No error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.InvalidInputFilePath">
            <summary>
            Invalid input file path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.InvalidOutputDirectoryPath">
            <summary>
            Invalid output directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.InvalidOutputFolderPath">
            <summary>
            Invalid output directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.ParameterFileNotFound">
            <summary>
            Parameter file not found
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.InvalidParameterFile">
            <summary>
            Invalid parameter file
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.FilePathError">
            <summary>
            File path error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.LocalizedError">
            <summary>
            Localized error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesBase.eProcessFilesErrorCodes.UnspecifiedError">
            <summary>
            Unspecified error
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesBase.ErrorCode">
            <summary>
            Error code reflecting processing outcome
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesBase.FilesProcessed">
            <summary>
            Number of files processed successfully when using ProcessFilesAndRecurseDirectories or ProcessFilesWildcard
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesBase.FileProcessErrors">
            <summary>
            Number of files that could not be processed when using ProcessFilesAndRecurseDirectories or ProcessFilesWildcard
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.CleanupPaths(System.String@,System.String@)">
            <summary>
            Cleanup file/directory paths
            </summary>
            <param name="inputFileOrDirectoryPath"></param>
            <param name="outputDirectoryPath"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.CleanupFilePaths(System.String@,System.String@)">
            <summary>
            Make sure inputFilePath points to a valid file and validate the output directory (defining it if null or empty)
            </summary>
            <param name="inputFilePath"></param>
            <param name="outputDirectoryPath"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.CleanupInputFilePath(System.String@)">
            <summary>
            Make sure inputFilePath points to a valid file
            </summary>
            <param name="inputFilePath"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.GetBaseClassErrorMessage">
            <summary>
            Get the base class error message, or an empty string if no error
            </summary>
            <returns>Error message</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.GetDefaultExtensionsToParse">
            <summary>
            Get the default file extensions to parse
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesWildcard(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Process one or more files
            </summary>
            <param name="inputFilePath">Match spec for finding files, can contain * and ?</param>
            <param name="outputDirectoryPath">Output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="resetErrorCode">If True, reset ErrorCode</param>
            <returns> True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFile(System.String)">
            <summary>
            Process a single file
            </summary>
            <param name="inputFilePath">Input file path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFile(System.String,System.String)">
            <summary>
            Process a single file
            </summary>
            <param name="inputFilePath">Input file path</param>
            <param name="outputDirectoryPath">Output directory path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFile(System.String,System.String,System.String)">
            <summary>
            Process a single file
            </summary>
            <param name="inputFilePath">Input file path</param>
            <param name="outputDirectoryPath">Output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFile(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Process a single file
            </summary>
            <param name="inputFilePath">Input file path</param>
            <param name="outputDirectoryPath">Output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="resetErrorCode">If true, reset the error code</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesAndRecurseDirectories(System.String,System.String,System.String)">
            <summary>
            Process files in a directory and in its subdirectories
            </summary>
            <param name="inputFilePathOrDirectory">
            Input directory or directory (supports wildcards)
            If a directory path, or if empty, processes files with known entries in the working directory
            If a file path, will process matching files, ignoring the default extensions and ignoring extensionsToParse
            </param>
            <param name="outputDirectoryPath">Output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesAndRecurseDirectories(System.String,System.String,System.Int32)">
            <summary>
            Process files in a directory and in its subdirectories
            </summary>
            <param name="inputFilePathOrDirectory">
            Input directory or directory (supports wildcards)
            If a directory path, or if empty, processes files with known entries in the working directory
            If a file path, will process matching files, ignoring the default extensions and ignoring extensionsToParse
            </param>
            <param name="outputDirectoryPath">Output directory path</param>
            <param name="maxLevelsToRecurse">
            When 0 or negative, recurse infinitely
            When 1, only process the current directory
            When 2, process the current directory and files in its subdirectories
            </param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesAndRecurseDirectories(System.String,System.String,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Process files in a directory and in its subdirectories
            </summary>
            <param name="inputFilePathOrDirectory">
            Input directory or directory (supports wildcards)
            If a directory path, or if empty, processes files with known entries in the working directory
            If a file path, will process matching files, ignoring the default extensions and ignoring extensionsToParse
            </param>
            <param name="outputDirectoryPath">Output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="extensionsToParse">List of file extensions to parse</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesAndRecurseDirectories(System.String,System.String,System.String,System.Boolean,System.String,System.Int32)">
            <summary>
            Process files in a directory and in its subdirectories
            </summary>
            <param name="inputFilePathOrDirectory">
            Input directory or directory (supports wildcards)
            If a directory path, or if empty, processes files with known entries in the working directory
            If a file path, will process matching files, ignoring the default extensions and ignoring extensionsToParse
            </param>
            <param name="outputDirectoryNameOrPath">
            If outputDirectoryAlternatePath is empty, this is the output directory path
            If outputDirectoryAlternatePath is defined, this is the output directory name
            </param>
            <param name="outputDirectoryAlternatePath">Output directory alternate path</param>
            <param name="recreateDirectoryHierarchyInAlternatePath">Recreate directory hierarchy in alternate path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="maxLevelsToRecurse">
            When 0 or negative, recurse infinitely
            When 1, only process the current directory
            When 2, process the current directory and files in its subdirectories
            </param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.ProcessFilesAndRecurseDirectories(System.String,System.String,System.String,System.Boolean,System.String,System.Int32,System.Collections.Generic.IList{System.String})">
            <summary>
            Process files in a directory and in its subdirectories
            </summary>
            <remarks>
            The extensions should be of the form ".TXT" or ".RAW" (i.e. a period then the extension)
            If any of the extensions is "*" or ".*", all files will be processed
            </remarks>
            <param name="inputFilePathOrDirectory">
            Input file or directory (supports wildcards)
            If a directory path, or if empty, processes files with known entries in the working directory
            If a file path, will process matching files, ignoring the default extensions and ignoring extensionsToParse
            </param>
            <param name="outputDirectoryNameOrPath">
            If outputDirectoryAlternatePath is empty, this is the output directory path
            If outputDirectoryAlternatePath is defined, this is the output directory name
            </param>
            <param name="outputDirectoryAlternatePath">Output directory alternate path</param>
            <param name="recreateDirectoryHierarchyInAlternatePath">Recreate directory hierarchy in alternate path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="maxLevelsToRecurse">
            When 0 or negative, recurse infinitely
            When 1, only process the current directory
            When 2, process the current directory and files in its subdirectories
            </param>
            <param name="extensionsToParse">List of file extensions to parse</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.RecurseDirectoriesWork(System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Collections.Generic.IList{System.String},System.Int32,System.Int32)">
            <summary>
            Process files in a directory and in its subdirectories
            </summary>
            <param name="inputDirectoryPath">Path to the directory with files to process</param>
            <param name="fileNameMatch">File name or file spec to process</param>
            <param name="outputDirectoryNameOrPath">
            If outputDirectoryAlternatePath is empty, this is the output directory path
            If outputDirectoryAlternatePath is defined, this is the output directory name
            </param>
            <param name="parameterFilePath">Optional parameter file path; loading of parameters is handled by classes that inherit this base class</param>
            <param name="outputDirectoryAlternatePath">Output directory alternate path; primarily useful if recreateDirectoryHierarchyInAlternatePath is true</param>
            <param name="recreateDirectoryHierarchyInAlternatePath">Recreate directory hierarchy in alternate path</param>
            <param name="extensionsToParse">
            List of file extensions to process
            If the list is empty, or if it contains "*" or ".*", process all files
            Otherwise, a list of extensions to process, e.g. ".txt" and ".tsv"
            </param>
            <param name="recursionLevel">Current level of recursion</param>
            <param name="maxLevelsToRecurse">
            When 0 or negative, recurse infinitely
            When 1, only process the current directory
            When 2, process the current directory and files in its subdirectories
            </param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesBase.SetBaseClassErrorCode(PRISM.FileProcessor.ProcessFilesBase.ProcessFilesErrorCodes)">
            <summary>
            Update the base class error code
            </summary>
            <param name="newErrorCode"></param>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase">
            <summary>
            Base class for both ProcessFilesBase and ProcessDirectoriesBase
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants">
            <summary>
            Message type enums
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants.Debug">
            <summary>
            Debugging message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants.Normal">
            <summary>
            Normal message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants.ErrorMsg">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants.Warning">
            <summary>
            Warning message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants.Suppress">
            <summary>
            Message that should not be output
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.eMessageTypeConstants">
            <summary>
            Message type enums
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.eMessageTypeConstants.Debug">
            <summary>
            Debugging message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.eMessageTypeConstants.Normal">
            <summary>
            Normal message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.eMessageTypeConstants.ErrorMsg">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.eMessageTypeConstants.Warning">
            <summary>
            Warning message
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.eMessageTypeConstants.Suppress">
            <summary>
            Message that should not be output
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel">
            <summary>
            Log levels, specifying the severity of messages to be logged
            </summary>
            <remarks>
            Logging methods in this class support duplicateHoldoffHours
            In contrast, Logging.FileLogger does not support skipping duplicate log messages
            </remarks>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel.Suppress">
            <summary>
            Output suppressed messages with everything else
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel.Debug">
            <summary>
            All messages
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel.Normal">
            <summary>
            All normal, warning, and error messages
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel.Warning">
            <summary>
            Warning and error messages
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel.Error">
            <summary>
            Error messages only
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mFileDate">
            <summary>
            File date (program date)
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFileBasePath">
            <summary>
            Base path for the log file
            </summary>
            <remarks>Only used if the log file path is auto-defined</remarks>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFilePath">
            <summary>
            Log file path (relative or absolute path)
            </summary>
            <remarks>Leave blank to auto-define</remarks>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFileRolloverTime">
            <summary>
            Time when the a new log file should be created (12 am tomorrow)
            </summary>
            <remarks>Only used if mLogFileUsesDateStamp is true</remarks>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFileUsesDateStamp">
            <summary>
            True if the auto-defined log file should have the current date appended to the name
            </summary>
            <remarks>Only used if LogFilePath is initially blank</remarks>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFile">
            <summary>
            Log file writer
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mOutputDirectoryPath">
            <summary>
            Output directory path
            </summary>
            <remarks>This variable is updated when CleanupFilePaths() is called</remarks>
        </member>
        <member name="E:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressReset">
            <summary>
            Progress was reset
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressResetEventHandler">
            <summary>
            Delegate to indicate that progress was reset
            </summary>
        </member>
        <member name="E:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressComplete">
            <summary>
            Processing is complete
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressCompleteEventHandler">
            <summary>
            Delegate to indicate that processing is complete
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mProgressPercentComplete">
            <summary>
            Percent complete, value between 0 and 100, but can contain decimal percentage values
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogDataCache">
            <summary>
            Keys in this dictionary are the log type and message (separated by an underscore)
            Values are the most recent time the message was logged
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.AbortProcessing">
            <summary>
            True if processing should be aborted
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ArchiveOldLogFiles">
            <summary>
            When true, auto-move old log files to a subdirectory based on the log file date
            </summary>
            <remarks>Only valid if the log file name was auto-defined (meaning LogFilePath was initially blank)</remarks>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.FileVersion">
            <summary>
            Version of the executing assembly
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.FileDate">
            <summary>
            File date (aka program date)
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.IgnoreErrorsWhenUsingWildcardMatching">
            <summary>
            This option applies when processing files or directories matched with a wildcard
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogFilePath">
            <summary>
            Log file path (relative or absolute path)
            </summary>
            <remarks>Leave blank to auto-define using the executable name and today's date</remarks>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogDirectoryPath">
            <summary>
            Log directory path (ignored if LogFilePath is rooted)
            </summary>
            <remarks>
            If blank, mOutputDirectoryPath will be used
            If mOutputDirectoryPath is also blank, the log file is created in the same directory as the executing assembly
            </remarks>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogFolderPath">
            <summary>
            Log directory path (ignored if LogFilePath is rooted)
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogMessagesToFile">
            <summary>
            True to log messages to a file
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressStepDescription">
            <summary>
            Description of the current task
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressPercentComplete">
            <summary>
            Percent complete, value between 0 and 100, but can contain decimal percentage values
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowMessages">
            <summary>
            Deprecated property (previously, when true, events would be raised but when false, exceptions would be thrown)
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ReThrowEvents">
            <summary>
            When true, if an error occurs, a message will be logged, then the event will be re-thrown
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LoggingLevel">
            <summary>
            Minimum severity of messages to log
            </summary>
        </member>
        <member name="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ProgressOutputLevel">
            <summary>
            The severity of progress output; normally only used to suppress progress output in logs by setting this to <see cref="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogLevel.Suppress"/>
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.AbortProcessingNow">
            <summary>
            Abort processing as soon as possible
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ArchiveOldLogFilesNow">
            <summary>
            Look for log files over 32 days old that can be moved into a subdirectory
            </summary>
            <remarks>Only valid if the log file name was auto-defined</remarks>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.CleanupPaths(System.String@,System.String@)">
            <summary>
            Cleanup paths
            </summary>
            <param name="inputFileOrDirectoryPath"></param>
            <param name="outputDirectoryPath"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.CloseLogFileNow">
            <summary>
            Close the log file
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ComputeIncrementalProgress(System.Single,System.Single,System.Single)">
            <summary>
            Computes the incremental progress that has been made beyond currentTaskProgressAtStart,
            based on the number of items processed and the next overall progress level
            </summary>
            <param name="currentTaskProgressAtStart">Progress at the start of the current task (value between 0 and 100)</param>
            <param name="currentTaskProgressAtEnd">Progress at the start of the current task (value between 0 and 100)</param>
            <param name="subTaskProgress">Progress of the current task (value between 0 and 100)</param>
            <returns>Overall progress (value between 0 and 100)</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ComputeIncrementalProgress(System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Computes the incremental progress that has been made beyond currentTaskProgressAtStart,
            based on the number of items processed and the next overall progress level
            </summary>
            <param name="currentTaskProgressAtStart">Progress at the start of the current task (value between 0 and 100)</param>
            <param name="currentTaskProgressAtEnd">Progress at the start of the current task (value between 0 and 100)</param>
            <param name="currentTaskItemsProcessed">Number of items processed so far during this task</param>
            <param name="currentTaskTotalItems">Total number of items to process during this task</param>
            <returns>Overall progress (value between 0 and 100)</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ConfigureLogFilePath(System.String)">
            <summary>
            Sets the log file path (<see cref="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFilePath"/>),
            according to data in <see cref="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFilePath"/>,
            <see cref="F:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.mLogFileUsesDateStamp"/>, and <see cref="P:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogDirectoryPath"/>
            </summary>
            <remarks>
            If mLogFilePath is empty and logFileBaseName is empty, will use the name of the entry or executing assembly
            This method is private; Use protected method UpdateAutoDefinedLogFilePath to update the auto-defined log file path
            </remarks>
            <param name="logFileBaseName">Base name for the log file (ignored if mLogFilePath is defined)</param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.CreateSettingsFileIfMissing(System.String,System.String)">
            <summary>
            Verifies that the specified .XML settings file exists in the user's local settings directory
            </summary>
            <remarks>Will return True if the master settings file does not exist</remarks>
            <param name="applicationName">Application name</param>
            <param name="settingsFileName">Settings file name</param>
            <returns>True if the file already exists or was created, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.CreateSettingsFileIfMissing(System.String)">
            <summary>
            Verifies that the specified .XML settings file exists in the user's local settings directory
            </summary>
            <remarks>Will return True if the master settings file does not exist</remarks>
            <param name="settingsFilePathLocal">Full path to the local settings file, for example C:\Users\username\AppData\Roaming\AppName\SettingsFileName.xml</param>
            <returns>True if the file already exists or was created, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GarbageCollectNow">
            <summary>
            Perform garbage collection
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GarbageCollectNow(System.Int32)">
            <summary>
            Perform garbage collection
            </summary>
            <param name="maxWaitTimeMSec"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GarbageCollectWaitForGC">
            <summary>
            Force the garbage collector to run, waiting up to 1 second for it to finish
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetAppDataDirectoryPath(System.String)">
            <summary>
            Returns the full path to the directory into which this application should read/write settings file information
            </summary>
            <remarks>For example, C:\Users\username\AppData\Roaming\AppName</remarks>
            <param name="appName"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetAppDirectoryPath">
            <summary>
            Returns the full path to the directory that contains the currently executing .Exe or .Dll
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetAppPath">
            <summary>
            Returns the full path to the executing .Exe or .Dll
            </summary>
            <returns>File path</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetAppVersion(System.String)">
            <summary>
            Returns the .NET assembly version followed by the program date
            </summary>
            <param name="programDate"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetDateBasedLogFilePath(System.DateTime)">
            <summary>
            Append the timestamp for the given date to mLogFileBasePath
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetEntryOrExecutingAssembly">
            <summary>
            Returns the entry assembly, if it is unavailable, returns the executing assembly
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetErrorMessage">
            <summary>
            Get the current error message
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetVersionForExecutingAssembly">
            <summary>
            Gets the version for the entry assembly, if available
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.GetSettingsFilePathLocal(System.String,System.String)">
            <summary>
            Returns the full path to this application's local settings file
            </summary>
            <remarks>For example, C:\Users\username\AppData\Roaming\AppName\SettingsFileName.xml</remarks>
            <param name="applicationName"></param>
            <param name="settingsFileName"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.HandleException(System.String,System.Exception,System.Int32,System.Int32)">
            <summary>
            Log an error message with the exception message
            Re-throw the exception if ReThrowEvents is true
            </summary>
            <param name="baseMessage">Base error message</param>
            <param name="ex">Exception</param>
            <param name="duplicateHoldoffHours">Do not log the message if it was previously logged within this many hours</param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.InitializeLogFile">
            <summary>
            Initialize the log file
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.LogMessage(System.String,PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants,System.Int32,System.Int32,System.Exception)">
            <summary>
            Log a message then raise a Status, Warning, or Error event
            </summary>
            <remarks>
            Note that CleanupPaths() will update mOutputDirectoryPath, which is used here if mLogDirectoryPath is blank
            Thus, be sure to call CleanupPaths (or update mLogDirectoryPath) before the first call to LogMessage
            </remarks>
            <param name="message">Message</param>
            <param name="messageType">Message type</param>
            <param name="duplicateHoldoffHours">Do not log the message if it was previously logged within this many hours</param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </param>
            <param name="ex">If logging an exception, the exception object</param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ResetLogFileName">
            <summary>
            Reset the base log file name to an empty string and reset the cached log file dates
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ResetProgress">
            <summary>
            Reset progress
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ResetProgress(System.String)">
            <summary>
            Reset progress, updating the current processing step
            </summary>
            <param name="progressStepDescription"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowDebug(System.String,System.Boolean,System.Int32)">
            <summary>
            Show a debug message, optionally logging the message to the log file
            </summary>
            <param name="message">Message to show</param>
            <param name="allowLogToFile"></param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the debug event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowErrorMessage(System.String,System.Int32,System.Int32)">
            <summary>
            Show an error message and write it to the log file
            </summary>
            <param name="message">Message to show</param>
            <param name="duplicateHoldoffHours"></param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the error event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowErrorMessage(System.String,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Show an error message, optionally logging the message to the log file
            </summary>
            <param name="message">Message</param>
            <param name="allowLogToFile">When true, allow the message to be logged</param>
            <param name="duplicateHoldoffHours">Do not log the message if it was previously logged within this many hours</param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowMessage(System.String,System.Int32,System.Int32)">
            <summary>
            Show a status message and write it to the log file
            </summary>
            <param name="message">Message to show</param>
            <param name="duplicateHoldoffHours"></param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the message event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowMessage(System.String,System.Boolean,System.Int32,PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.MessageTypeConstants,System.Int32)">
            <summary>
            Show a status message, optionally logging the message to the log file
            </summary>
            <param name="message">Message to show</param>
            <param name="allowLogToFile">When true, write to the log file (if the message severity is >= LoggingLevel)</param>
            <param name="duplicateHoldoffHours"></param>
            <param name="messageType"></param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowWarning(System.String,System.Int32,System.Int32)">
            <summary>
            Show a warning
            </summary>
            <param name="message">Message to show</param>
            <param name="duplicateHoldoffHours"></param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the warning event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.ShowWarning(System.String,System.Boolean,System.Int32)">
            <summary>
            Show a warning
            </summary>
            <param name="message">Message to show</param>
            <param name="allowLogToFile"></param>
            <param name="emptyLinesBeforeMessage">
            Number of empty lines to write to the console before displaying a message
            This is only applicable if WriteToConsoleIfNoListener is true and the warning event has no listeners
            </param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.UpdateAutoDefinedLogFilePath(System.String,System.String,System.Boolean)">
            <summary>
            Auto-define the log file path using the given log directory path and base log file name
            </summary>
            <param name="logDirectoryPath">
            Log directory path; if blank, mOutputDirectoryPath will be used
            If mOutputDirectoryPath is also blank, the log file is created in the same directory as the executing assembly
            </param>
            <param name="logFileBaseName">
            Base name for the log file
            If blank, will use the name of the entry or executing assembly (without any extension)
            </param>
            <param name="archiveOldLogFiles">When true, archive old log files immediately</param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.UpdateProgress(System.String)">
            <summary>
            Update the current progress description
            </summary>
            <param name="progressStepDescription"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.UpdateProgress(System.Single)">
            <summary>
            Update progress percent complete
            </summary>
            <param name="percentComplete"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.UpdateProgress(System.String,System.Single)">
            <summary>
            Update progress description and percent complete
            </summary>
            <param name="progressStepDescription"></param>
            <param name="percentComplete"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrDirectoriesBase.OperationComplete">
            <summary>
            Raise event ProgressComplete
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFilesOrFoldersBase">
            <summary>
            Old base class for ProcessFilesBase and ProcessFoldersBase
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrFoldersBase.GetAppDataFolderPath(System.String)">
            <summary>
            Returns the full path to the folder into which this application should read/write settings file information
            </summary>
            <remarks>For example, C:\Users\username\AppData\Roaming\AppName</remarks>
            <param name="appName"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFilesOrFoldersBase.GetAppFolderPath">
            <summary>
            Returns the full path to the folder that contains the currently executing .Exe or .Dll
            </summary>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFoldersBase">
            <summary>
            This class can be used as a base class for classes that process a directory or directories
            </summary>
            <remarks>
            This class contains simple error codes that can be set from any derived classes;
            the derived classes can also set their own local error codes
            </remarks>
        </member>
        <member name="T:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes">
            <summary>
            Error code enums
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.NoError">
            <summary>
            No error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.InvalidInputFolderPath">
            <summary>
            Invalid input directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.InvalidOutputFolderPath">
            <summary>
            Invalid output directory path
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.ParameterFileNotFound">
            <summary>
            Parameter file not found
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.InvalidParameterFile">
            <summary>
            Invalid parameter file
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.FilePathError">
            <summary>
            File path error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.LocalizedError">
            <summary>
            Localized error
            </summary>
        </member>
        <member name="F:PRISM.FileProcessor.ProcessFoldersBase.eProcessFoldersErrorCodes.UnspecifiedError">
            <summary>
            Unspecified error
            </summary>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.CleanupFolderPaths(System.String@,System.String@)">
            <summary>
            Make sure inputFolderPath points to a valid directory and validate the output directory (defining it if null or empty)
            </summary>
            <remarks>Create outputFolderPath if it does not exist</remarks>
            <param name="inputFolderPath"></param>
            <param name="outputFolderPath"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.ProcessFoldersWildcard(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Process one or more folders (aka directories)
            </summary>
            <param name="inputFolderPath">Match spec for finding directories, can contain * and ?</param>
            <param name="outputFolderAlternatePath">Alternate output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="resetErrorCode">If True, reset ErrorCode</param>
            <returns> True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.ProcessFolder(System.String)">
            <summary>
            Process a single directory
            </summary>
            <param name="inputFolderPath">Input directory path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.ProcessFolder(System.String,System.String,System.String)">
            <summary>
            Process a single directory
            </summary>
            <param name="inputFolderPath">Input directory path</param>
            <param name="outputFolderAlternatePath">Alternate output directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.ProcessFolder(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Process a single directory
            </summary>
            <param name="inputFolderPath">Input directory path</param>
            <param name="outputFolderAlternatePath">Alternate directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="resetErrorCode">If true, reset the error code</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.ProcessAndRecurseFolders(System.String,System.Int32)">
            <summary>
            Process directories and subdirectories
            </summary>
            <param name="inputFolderPath"></param>
            <param name="recurseFoldersMaxLevels"></param>
        </member>
        <member name="M:PRISM.FileProcessor.ProcessFoldersBase.ProcessAndRecurseFolders(System.String,System.String,System.String,System.Int32)">
            <summary>
            Process directories and subdirectories
            </summary>
            <remarks>Calls ProcessFolders for all matching directories in inputFolderPath</remarks>
            <param name="inputFolderPath">Input directory path (supports wildcards)</param>
            <param name="outputFolderAlternatePath">Alternate directory path</param>
            <param name="parameterFilePath">Parameter file path</param>
            <param name="recurseFoldersMaxLevels">If 0 or negative, recurse infinitely</param>
        </member>
        <member name="T:PRISM.Crc32">
            <summary>
            Implementation of Crc32 in https://tools.ietf.org/html/rfc1952
            </summary>
        </member>
        <member name="F:PRISM.Crc32.crcTable">
            <summary>
            Table of CRCs of all 8-bit messages
            </summary>
        </member>
        <member name="F:PRISM.Crc32.crcTableComputed">
            <summary>
            Set to true once the crcTable has been populated
            </summary>
        </member>
        <member name="M:PRISM.Crc32.MakeCrcTable">
            <summary>
            Populate crcTable, which will allow for quickly computing CRC values
            </summary>
        </member>
        <member name="M:PRISM.Crc32.UpdateCrc(System.UInt32,System.Collections.Generic.IEnumerable{System.Byte})">
             <summary>
             Update a running CRC using the enumerable byte buffer;
             the crc should be initialized to zero.
             </summary>
             <remarks>
             Pre- and post-conditioning (one's complement) is performed within this method so it shouldn't be done by the caller
             </remarks>
             <example>
             uint crc = 0;
            
             while (readBuffer(buffer, length) != 0)
             {
                 crc = UpdateCrc(crc, buffer, length);
             }
             if (crc != originalCrc) error();
             </example>
             <param name="crc"></param>
             <param name="buf"></param>
        </member>
        <member name="M:PRISM.Crc32.Crc(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Return the CRC32 of the enumerable byte buffer
            </summary>
            <param name="buf"></param>
        </member>
        <member name="M:PRISM.Crc32.Crc(System.IO.Stream)">
            <summary>
            Return the CRC32 of the byte stream
            </summary>
            <param name="stream">Byte stream</param>
        </member>
        <member name="T:PRISM.DirectoryScanner">
            <summary>
            Performs a recursive search of a directory tree looking for file names that match a set of regular expressions
            </summary>
        </member>
        <member name="E:PRISM.DirectoryScanner.FoundFile">
            <summary>
            A file was found when scanning the directory
            </summary>
        </member>
        <member name="T:PRISM.DirectoryScanner.FoundFileEventHandler">
            <summary>
            Event is raised whenever a matching file is found
            </summary>
            <remarks>This event is most useful for implementing a progress indicator</remarks>
            <param name="fileName">The found file's full path</param>
        </member>
        <member name="M:PRISM.DirectoryScanner.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor: Initializes a new instance of the DirectoryScanner class
            </summary>
            <param name="dirs">An array of directory paths to scan</param>
        </member>
        <member name="M:PRISM.DirectoryScanner.#ctor(System.Collections.Generic.List{System.String})">
            <summary>
            Constructor: Initializes a new instance of the DirectoryScanner class
            </summary>
            <param name="dirs">A list of directory paths to scan</param>
        </member>
        <member name="M:PRISM.DirectoryScanner.PerformScan(System.String[])">
            <summary>
            Performs a recursive search of a directory tree looking for file names that match a set of regular expressions
            </summary>
            <param name="searchPatterns">An array of regular expressions to use in the search</param>
            <returns>A list of the file paths found; empty list if no matches</returns>
        </member>
        <member name="T:PRISM.FileSyncUtils">
            <summary>
            Methods for copying files to/from a remote server, including creating a .hashcheck file and a .lastused file
            </summary>
        </member>
        <member name="F:PRISM.FileSyncUtils.LASTUSED_FILE_EXTENSION">
            <summary>
            Extension for .LastUsed files that track when a data file was last used
            </summary>
        </member>
        <member name="M:PRISM.FileSyncUtils.#ctor(System.String)">
            <summary>
            Constructor that takes a manager name
            </summary>
            <remarks>Will instantiate a new instance of clsFileTools</remarks>
            <param name="managerName"></param>
        </member>
        <member name="M:PRISM.FileSyncUtils.#ctor(PRISM.FileTools)">
            <summary>
            Constructor that takes a clsFileTools instance
            </summary>
            <param name="fileTools"></param>
        </member>
        <member name="M:PRISM.FileSyncUtils.CopyFileToLocal(System.String,System.String,System.String@,System.Int32,PRISM.HashUtilities.HashTypeConstants)">
            <summary>
            Copy a file from a remote path and store it locally, including creating a .hashcheck file and a .lastused file
            If the file exists and the SHA-1 hash matches, do not re-copy the file
            </summary>
            <param name="sourceFilePath">Source file path</param>
            <param name="targetDirectoryPath">Target directory path</param>
            <param name="errorMessage">Output: error message</param>
            <param name="recheckIntervalDays">
            If the .hashcheck file is more than this number of days old, re-compute the hash value of the local file and compare to the hashcheck file
            Set to 0 to check the hash on every call to this method
            </param>
            <param name="hashType">Hash type for newly created .hashcheck files</param>
        </member>
        <member name="M:PRISM.FileSyncUtils.DeleteHashCheckFileForDataFile(System.IO.FileInfo)">
            <summary>
            Delete the .hashcheck file for the given data file
            Does nothing if the data file does not have a .hashcheck file
            </summary>
            <param name="dataFile"></param>
        </member>
        <member name="M:PRISM.FileSyncUtils.UpdateLastUsedFile(System.IO.FileInfo)">
            <summary>
            Update the .lastused file for the given data file
            </summary>
            <param name="dataFile"></param>
        </member>
        <member name="M:PRISM.FileSyncUtils.ValidateFileVsHashcheck(System.String,System.String@,PRISM.HashUtilities.HashInfoType,System.Int32)">
            <summary>
            Validate that the hash value of a local file matches the expected hash info, creating the .hashcheck file if missing
            </summary>
            <param name="localFilePath">Local file path</param>
            <param name="errorMessage">Output: error message</param>
            <param name="expectedHashInfo">Expected hash info</param>
            <param name="recheckIntervalDays">
            If the .hashcheck file is more than this number of days old, re-compute the hash value of the local file and compare to the hashcheck file
            Set to 0 to check the hash on every call to this method
            </param>
        </member>
        <member name="M:PRISM.FileSyncUtils.ValidateFileVsHashcheck(System.String,System.String@,System.String,PRISM.HashUtilities.HashTypeConstants)">
            <summary>
            Validate that the hash value of a local file matches the expected hash value
            </summary>
            <param name="localFilePath">Local file path</param>
            <param name="errorMessage">Output: error message</param>
            <param name="expectedHash">Expected hash value</param>
            <param name="expectedHashType">Hash type (CRC32, MD5, or SHA1)</param>
            <returns>True if the file is valid, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileSyncUtils.ValidateFileVsHashcheck(System.String,System.String,System.String@,PRISM.HashUtilities.HashTypeConstants,System.Int32)">
            <summary>
            Validate that the hash value of a local file matches the expected hash info, creating the .hashcheck file if missing
            </summary>
            <remarks>
            Will create the .hashcheck file if missing
            Will also update the .lastused file for the local file
            </remarks>
            <param name="localFilePath">Local file path</param>
            <param name="hashCheckFilePath">Hashcheck file for the given data file (auto-defined if blank)</param>
            <param name="errorMessage">Output: error message</param>
            <param name="expectedHashType">Hash type that is presumed to be in the hashcheck file</param>
            <param name="recheckIntervalDays">
            If the .hashcheck file is more than this number of days old, re-compute the hash value of the local file and compare to the hashcheck file
            Set to 0 to check the hash on every call to this method
            </param>
            <returns>True if the file is valid, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileSyncUtils.ValidateFileVsHashcheck(System.String,System.String,System.String@,PRISM.HashUtilities.HashInfoType,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Validate that the hash value of a local file matches the expected hash info, creating the .hashcheck file if missing
            </summary>
            <remarks>
            Will create the .hashcheck file if missing
            Will also update the .lastused file for the local file
            </remarks>
            <param name="localFilePath">Local file path</param>
            <param name="hashCheckFilePath">Hashcheck file for the given data file (auto-defined if blank)</param>
            <param name="errorMessage">Output: error message</param>
            <param name="expectedHashInfo">Expected hash info (e.g. based on a remote file)</param>
            <param name="checkDate">If True, compares UTC modification time; times must agree within 2 seconds</param>
            <param name="computeHash">If true, compute the file hash every recheckIntervalDays (or every time if recheckIntervalDays is 0)</param>
            <param name="checkSize">If true, compare the actual file size to that in the hashcheck file</param>
            <param name="recheckIntervalDays">
            If the .hashcheck file is more than this number of days old, re-compute the hash value of the local file and compare to the hashcheck file
            Set to 0 to check the hash on every call to this method
            </param>
            <returns>True if the file is valid, otherwise false</returns>
        </member>
        <member name="M:PRISM.FileSyncUtils.ValidateFileVsHashcheck(System.String,System.String,System.String@,System.Boolean,System.Boolean,System.Boolean,PRISM.HashUtilities.HashTypeConstants)">
            <summary>
            Looks for a .hashcheck file for the specified data file; returns false if not found
            If found, compares the stored values to the actual values (size, modification_date_utc, and hash)
            </summary>
            <remarks>The .hashcheck file has the same name as the data file, but with ".hashcheck" appended</remarks>
            <param name="localFilePath">Data file to check</param>
            <param name="hashCheckFilePath">Hashcheck file for the given data file (auto-defined if blank)</param>
            <param name="errorMessage">Output: error message</param>
            <param name="checkDate">If True, compares UTC modification time; times must agree within 2 seconds</param>
            <param name="computeHash">If true, compute the file hash (every time); if false, only compare file size and date</param>
            <param name="checkSize">If true, compare the actual file size to that in the hashcheck file</param>
            <param name="assumedHashType">Hash type to assume if the .hashcheck file does not have a hashtype entry</param>
            <returns>True if the hashcheck file exists and the actual file matches the expected values; false if a mismatch, if .hashcheck is missing, or if a problem</returns>
        </member>
        <member name="T:PRISM.FileTools">
            <summary>
            Tools to manipulate paths and directories
            </summary>
        </member>
        <member name="E:PRISM.FileTools.CopyingFile">
            <summary>
            File copy starting event
            </summary>
        </member>
        <member name="T:PRISM.FileTools.CopyingFileEventHandler">
            <summary>
            Event is raised before copying begins
            </summary>
            <param name="filename">The file's full path</param>
        </member>
        <member name="E:PRISM.FileTools.ResumingFileCopy">
            <summary>
            Event is raised before copying begins (when resuming a file copy)
            </summary>
        </member>
        <member name="T:PRISM.FileTools.ResumingFileCopyEventHandler">
            <summary>
            Event is raised before copying begins (when resuming a file copy)
            </summary>
            <param name="filename">The file's full path</param>
        </member>
        <member name="E:PRISM.FileTools.FileCopyProgress">
            <summary>
            Event is raised before copying begins
            </summary>
        </member>
        <member name="T:PRISM.FileTools.FileCopyProgressEventHandler">
            <summary>
            Event is raised before copying begins
            </summary>
            <param name="filename">The file name (not full path)</param>
            <param name="percentComplete">Percent complete (value between 0 and 100)</param>
        </member>
        <member name="E:PRISM.FileTools.WaitingForLockQueue">
            <summary>
            Event raised while waiting for the lock queue
            </summary>
        </member>
        <member name="T:PRISM.FileTools.WaitingForLockQueueEventHandler">
            <summary>
            Reports the source and target paths, plus the source and target backlog
            </summary>
            <param name="sourceFilePath">Source file path</param>
            <param name="targetFilePath">Target file path</param>
            <param name="backlogSourceMB">Source computer backlog, in MB</param>
            <param name="backlogTargetMB">Target computer backlog, in MB</param>
        </member>
        <member name="E:PRISM.FileTools.WaitingForLockQueueNotifyLockFilePaths">
            <summary>
            Event raised after waiting for 5 minutes
            </summary>
        </member>
        <member name="T:PRISM.FileTools.WaitingForLockQueueNotifyLockFilePathsEventHandler">
            <summary>
            Information about lock files associated with the current wait
            </summary>
            <param name="sourceLockFilePath">Source lock file path</param>
            <param name="targetLockFilePath">Target lock file path</param>
            <param name="adminBypassMessage">Message that describes deleting the lock files to abort the wait</param>
        </member>
        <member name="E:PRISM.FileTools.LockQueueTimedOut">
            <summary>
            Event is raised if we wait to long for our turn in the lock file queue
            </summary>
        </member>
        <member name="T:PRISM.FileTools.LockQueueTimedOutEventHandler">
            <summary>
            Event is raised if we wait to long for our turn in the lock file queue
            </summary>
            <param name="sourceFilePath"></param>
            <param name="targetFilePath"></param>
            <param name="waitTimeMinutes"></param>
        </member>
        <member name="E:PRISM.FileTools.LockQueueWaitComplete">
            <summary>
            Event is raised when we are done waiting for our turn in the lock file queue
            </summary>
        </member>
        <member name="T:PRISM.FileTools.LockQueueWaitCompleteEventHandler">
            <summary>
            Event is raised when we are done waiting for our turn in the lock file queue
            </summary>
            <param name="sourceFilePath"></param>
            <param name="targetFilePath"></param>
            <param name="waitTimeMinutes"></param>
        </member>
        <member name="F:PRISM.FileTools.DATE_TIME_FORMAT">
            <summary>
            Standard date/time formatting
            </summary>
        </member>
        <member name="F:PRISM.FileTools.DEFAULT_CHUNK_SIZE_MB">
            <summary>
            Used by CopyFileWithResume and CopyDirectoryWithResume when copying a file byte-by-byte and supporting resuming the copy if interrupted
            </summary>
        </member>
        <member name="F:PRISM.FileTools.DEFAULT_FLUSH_THRESHOLD_MB">
            <summary>
            Used by CopyFileWithResume; defines how often the data is flushed out to disk; must be larger than the ChunkSize
            </summary>
        </member>
        <member name="F:PRISM.FileTools.LOCKFILE_MINIMUM_SOURCE_FILE_SIZE_MB">
            <summary>
            Minimum source file size (in MB) for the lock queue to be used
            </summary>
        </member>
        <member name="T:PRISM.FileTools.CopyStatus">
            <summary>
            Copy status codes
            </summary>
        </member>
        <member name="F:PRISM.FileTools.CopyStatus.Idle">
            <summary>
            Not copying a file
            </summary>
        </member>
        <member name="F:PRISM.FileTools.CopyStatus.NormalCopy">
            <summary>
            File is being copied via .NET and cannot be resumed
            </summary>
        </member>
        <member name="F:PRISM.FileTools.CopyStatus.BufferedCopy">
            <summary>
            File is being copied in chunks and can be resumed
            </summary>
        </member>
        <member name="F:PRISM.FileTools.CopyStatus.BufferedCopyResume">
            <summary>
            Resuming copying a file in chunks
            </summary>
        </member>
        <member name="T:PRISM.FileTools.FileOverwriteMode">
            <summary>
            File overwrite options
            </summary>
        </member>
        <member name="F:PRISM.FileTools.FileOverwriteMode.DoNotOverwrite">
            <summary>
            Do not overwrite
            </summary>
            <remarks>An exception will be thrown if you try to overwrite an existing file</remarks>
        </member>
        <member name="F:PRISM.FileTools.FileOverwriteMode.AlwaysOverwrite">
            <summary>
            Always overwrite
            </summary>
        </member>
        <member name="F:PRISM.FileTools.FileOverwriteMode.OverwriteIfSourceNewer">
            <summary>
            OverWrite if source date newer (or if same date but length differs)
            </summary>
        </member>
        <member name="F:PRISM.FileTools.FileOverwriteMode.OverWriteIfDateOrLengthDiffer">
            <summary>
            OverWrite if any difference in size or date; note that newer files in target directory will get overwritten since their date doesn't match
            </summary>
        </member>
        <member name="M:PRISM.FileTools.BackupFileBeforeCopy(System.String)">
            <summary>
            Renames targetFilePath to have _Old1 before the file extension
            Also looks for and renames other backed up versions of the file (those with _Old2, _Old3, etc.)
            Use this method to backup old versions of a file before copying a new version to a target directory
            Keeps up to 9 old versions of a file
            </summary>
            <param name="targetFilePath">Full path to the file to backup</param>
            <returns>True if the file was successfully renamed (also returns True if the target file does not exist)</returns>
        </member>
        <member name="M:PRISM.FileTools.BackupFileBeforeCopy(System.String,System.Int32)">
            <summary>
            Renames targetFilePath to have _Old1 before the file extension
            Also looks for and renames other backed up versions of the file (those with _Old2, _Old3, etc.)
            Use this method to backup old versions of a file before copying a new version to a target directory
            </summary>
            <param name="targetFilePath">Full path to the file to backup</param>
            <param name="versionCountToKeep">Maximum backup copies of the file to keep</param>
            <returns>True if the file was successfully renamed (also returns True if the target file does not exist)</returns>
        </member>
        <member name="M:PRISM.FileTools.BytesToHumanReadable(System.Int64)">
            <summary>
            Convert a size, bytes, to a string representation
            For example, 165342 will return 161.5 KB
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:PRISM.FileTools.CompactPathString(System.String,System.Int32)">
            <summary>
            Shorten pathToCompact to a maximum length of maxLength
            Examples:
            C:\...\B..\Finance..
            C:\...\W..\Business\Finances.doc
            C:\My Doc..\Word\Business\Finances.doc
            </summary>
            <param name="pathToCompact"></param>
            <param name="maxLength">Maximum length of the shortened path</param>
            <returns>Shortened path</returns>
        </member>
        <member name="P:PRISM.FileTools.CopyChunkSizeMB">
            <summary>
            Copy chunk size, in MB
            </summary>
            <remarks>Used by CopyFileWithResume</remarks>
        </member>
        <member name="P:PRISM.FileTools.CopyFlushThresholdMB">
            <summary>
            Copy flush threshold, in MB
            Cached data is written to disk when this threshold is reached
            </summary>
            <remarks>Used by CopyFileWithResume</remarks>
        </member>
        <member name="P:PRISM.FileTools.CurrentCopyStatus">
            <summary>
            Current copy status
            </summary>
        </member>
        <member name="P:PRISM.FileTools.CurrentSourceFile">
            <summary>
            Current source file path
            </summary>
        </member>
        <member name="P:PRISM.FileTools.DebugLevel">
            <summary>
            Debug level controls the level of sending messages by raising StatusEvent events
            </summary>
            <remarks>1 results in fewer messages; 2 for additional messages, 3 for all messages</remarks>
        </member>
        <member name="P:PRISM.FileTools.ManagerName">
            <summary>
            Manager name (used when creating lock files)
            </summary>
        </member>
        <member name="M:PRISM.FileTools.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.FileTools.#ctor(System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="managerName">Manager name</param>
            <param name="debugLevel">1 results in fewer messages; 2 for additional messages, 3 for all messages</param>
        </member>
        <member name="M:PRISM.FileTools.CheckTerminator(System.String,System.Boolean,System.Char)">
            <summary>
            Modifies input directory path string depending on optional settings
            Overload for all parameters specified
            </summary>
            <param name="directoryPath">The input directory path</param>
            <param name="addTerm">Specifies whether the directory path string ends with the specified directory separation character</param>
            <param name="termChar">The specified directory separation character</param>
            <returns>The modified directory path</returns>
        </member>
        <member name="M:PRISM.FileTools.CheckTerminator(System.String,System.Boolean)">
            <summary>
            Adds or removes the DOS path separation character from the end of the directory path
            </summary>
            <param name="directoryPath">The input directory path</param>
            <param name="addTerm">Specifies whether the directory path string ends with the specified directory separation character</param>
            <returns>The modified directory path</returns>
        </member>
        <member name="M:PRISM.FileTools.CheckTerminator(System.String,System.String)">
            <summary>
            Assures the directory path ends with the specified path separation character
            </summary>
            <param name="directoryPath">The input directory path</param>
            <param name="termChar">The specified directory separation character</param>
            <returns>The modified directory path</returns>
        </member>
        <member name="M:PRISM.FileTools.CheckTerminator(System.String)">
            <summary>
            Assures the directory path ends with the current system's path separation character
            </summary>
            <param name="directoryPath">The input directory path</param>
            <returns>The modified directory path</returns>
        </member>
        <member name="M:PRISM.FileTools.CheckTerminatorEx(System.String,System.Boolean,System.Char)">
            <summary>
            Modifies input directory path string depending on addTerm
            </summary>
            <remarks>addTerm=True forces the path to end with specified termChar while addTerm=False will remove termChar from the end if present</remarks>
            <param name="directoryPath">The input directory path</param>
            <param name="addTerm">Specifies whether the directory path should end with the specified directory separation character</param>
            <param name="termChar">The specified directory separation character</param>
            <returns>The modified directory path</returns>
        </member>
        <member name="M:PRISM.FileTools.ConstructCompressedGZipFilePath(System.IO.FileInfo,System.String,System.String)">
            <summary>
            Construct the path to the .gz file to create, possibly overriding the target directory and/or target filename
            </summary>
            <param name="fileToCompress"></param>
            <param name="compressedDirectoryPath"></param>
            <param name="compressedFileName"></param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String)">
            <summary>
            Copies a source directory to the destination directory; does not allow overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.String)">
            <summary>
            Copies a source directory to the destination directory; does not allow overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="managerName"></param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Copies a source directory to the destination directory; does not allow overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Boolean)">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
            <param name="managerName"></param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Boolean,System.Collections.Generic.List{System.String})">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
            <param name="readOnly">The value to be assigned to the read-only attribute of the destination file</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Boolean,System.Boolean,System.Collections.Generic.List{System.String})">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
            <param name="readOnly">The value to be assigned to the read-only attribute of the destination file</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectory(System.String,System.String,System.Boolean,System.Boolean,System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
            <param name="readOnly">The value to be assigned to the read-only attribute of the destination file</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
            <param name="managerName"></param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryEx(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.IReadOnlyCollection{System.String},System.String)">
            <summary>
            Copies a source directory to the destination directory; allows overwriting
            </summary>
            <remarks>Usage: CopyDirectory("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourcePath">The source directory path</param>
            <param name="destPath">The destination directory path</param>
            <param name="overWrite">true if the destination file can be overwritten; otherwise, false</param>
            <param name="setAttribute">true if the read-only attribute of the destination file is to be modified, false otherwise</param>
            <param name="readOnly">The value to be assigned to the read-only attribute of the destination file</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
            <param name="managerName">Name of the calling program; used when calling CopyFileUsingLocks</param>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryWithResume(System.String,System.String)">
            <summary>
            Copies a source directory to the destination directory.
            Overwrites existing files if they differ in modification time or size.
            Copies large files in chunks and allows resuming copying a large file if interrupted.
            </summary>
            <remarks>Usage: CopyDirectoryWithResume("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourceDirectoryPath">The source directory path</param>
            <param name="targetDirectoryPath">The destination directory path</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryWithResume(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Copies a source directory to the destination directory.
            Overwrites existing files if they differ in modification time or size.
            Copies large files in chunks and allows resuming copying a large file if interrupted.
            </summary>
            <remarks>Usage: CopyDirectoryWithResume("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourceDirectoryPath">The source directory path</param>
            <param name="targetDirectoryPath">The destination directory path</param>
            <param name="recurse">True to copy subdirectories</param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryWithResume(System.String,System.String,System.Boolean,PRISM.FileTools.FileOverwriteMode,System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Copies a source directory to the destination directory.
            OverWrite behavior is governed by fileOverwriteMode.
            Copies large files in chunks and allows resuming copying a large file if interrupted.
            </summary>
            <remarks>Usage: CopyDirectoryWithResume("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourceDirectoryPath">The source directory path</param>
            <param name="targetDirectoryPath">The destination directory path</param>
            <param name="recurse">True to copy subdirectories</param>
            <param name="fileOverwriteMode">Behavior when a file already exists at the destination</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryWithResume(System.String,System.String,System.Boolean,PRISM.FileTools.FileOverwriteMode,System.Int32@,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Copies a source directory to the destination directory.
            OverWrite behavior is governed by fileOverwriteMode.
            Copies large files in chunks and allows resuming copying a large file if interrupted.
            </summary>
            <remarks>Usage: CopyDirectoryWithResume("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourceDirectoryPath">The source directory path</param>
            <param name="targetDirectoryPath">The destination directory path</param>
            <param name="recurse">True to copy subdirectories</param>
            <param name="fileOverwriteMode">Behavior when a file already exists at the destination</param>
            <param name="fileCountSkipped">Number of files skipped (output)</param>
            <param name="fileCountResumed">Number of files resumed (output)</param>
            <param name="fileCountNewlyCopied">Number of files newly copied (output)</param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryWithResume(System.String,System.String,System.Boolean,PRISM.FileTools.FileOverwriteMode,System.Collections.Generic.List{System.String},System.Int32@,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Copies a source directory to the destination directory.
            OverWrite behavior is governed by fileOverwriteMode.
            Copies large files in chunks and allows resuming copying a large file if interrupted.
            </summary>
            <remarks>Usage: CopyDirectoryWithResume("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourceDirectoryPath">The source directory path</param>
            <param name="targetDirectoryPath">The destination directory path</param>
            <param name="recurse">True to copy subdirectories</param>
            <param name="fileOverwriteMode">Behavior when a file already exists at the destination</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
            <param name="fileCountSkipped">Number of files skipped (output)</param>
            <param name="fileCountResumed">Number of files resumed (output)</param>
            <param name="fileCountNewlyCopied">Number of files newly copied (output)</param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyDirectoryWithResume(System.String,System.String,System.Boolean,PRISM.FileTools.FileOverwriteMode,System.Boolean,System.Boolean,System.Collections.Generic.List{System.String},System.Int32@,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Copies a source directory to the destination directory.
            OverWrite behavior is governed by fileOverwriteMode.
            Copies large files in chunks and allows resuming copying a large file if interrupted.
            </summary>
            <remarks>Usage: CopyDirectoryWithResume("C:\Misc", "D:\MiscBackup")</remarks>
            <param name="sourceDirectoryPath">The source directory path</param>
            <param name="targetDirectoryPath">The destination directory path</param>
            <param name="recurse">True to copy subdirectories</param>
            <param name="fileOverwriteMode">Behavior when a file already exists at the destination</param>
            <param name="setAttribute">True if the read-only attribute of the destination file is to be modified, false otherwise</param>
            <param name="readOnly">The value to be assigned to the read-only attribute of the destination file</param>
            <param name="fileNamesToSkip">List of file names to skip when copying the directory (and subdirectories); can optionally contain full path names to skip</param>
            <param name="fileCountSkipped">Number of files skipped (output)</param>
            <param name="fileCountResumed">Number of files resumed (output)</param>
            <param name="fileCountNewlyCopied">Number of files newly copied (output)</param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFile(System.String,System.String)">
            <summary>
            Copies a source file to the destination file; does not allow overwriting
            </summary>
            <param name="sourcePath">The source file path</param>
            <param name="destPath">The destination file path</param>
        </member>
        <member name="M:PRISM.FileTools.CopyFile(System.String,System.String,System.Boolean)">
            <summary>
            Copies a source file to the destination file
            </summary>
            <param name="sourcePath">The source file path</param>
            <param name="destPath">The destination file path</param>
            <param name="overWrite">True to overwrite</param>
        </member>
        <member name="M:PRISM.FileTools.CopyFile(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Copies a source file to the destination file
            </summary>
            <param name="sourcePath">The source file path</param>
            <param name="destPath">The destination file path</param>
            <param name="overWrite">True to overwrite</param>
            <param name="backupDestFileBeforeCopy">True to backup the destination file before copying</param>
        </member>
        <member name="M:PRISM.FileTools.CopyFile(System.String,System.String,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Copies a source file to the destination file; allows overwriting
            </summary>
            <param name="sourcePath">The source file path</param>
            <param name="destPath">The destination file path</param>
            <param name="overWrite">True if the destination file can be overwritten; otherwise, false</param>
            <param name="backupDestFileBeforeCopy">True to backup the destination file before copying</param>
            <param name="versionCountToKeep">Number of backup copies to keep</param>
        </member>
        <member name="M:PRISM.FileTools.CopyFileEx(System.String,System.String,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Copies a source file to the destination file; allows overwriting
            </summary>
            <remarks>
            <para>
            This method is unique in that it allows you to specify a destination path where
            some of the directories do not already exist; it will create them if they don't
            </para>
            <para>
            The last parameter specifies whether a file already present in the
            destination directory will be overwritten
            </para>
            <para>
            Requires Imports System.IO
            Usage: CopyFile("C:\Misc\Bob.txt", "D:\MiscBackup\Bob.txt")
            </para>
            </remarks>
            <param name="sourcePath">The source file path</param>
            <param name="destPath">The destination file path</param>
            <param name="overWrite">True if the destination file can be overwritten; otherwise, false</param>
            <param name="backupDestFileBeforeCopy">True to backup the destination file before copying</param>
            <param name="versionCountToKeep">Number of backup copies to keep</param>
        </member>
        <member name="M:PRISM.FileTools.CopyFileNative(System.String,System.String,System.Boolean)">
            <summary>
            Try to copy a file using File.Copy
            If the copy fails due to the path length being 260 characters or longer,
            and if we're running Windows, use CopyFileW in kernel32.dll instead
            </summary>
            <param name="sourcePath"></param>
            <param name="destPath"></param>
            <param name="overwrite"></param>
        </member>
        <member name="M:PRISM.FileTools.CopyFileUsingLocks(System.String,System.String,System.Boolean)">
            <summary>
            Copy the source file to the target path; do not overwrite existing files
            </summary>
            <remarks>If the file exists, will not copy the file but will still return true</remarks>
            <param name="sourceFilePath">Source file path</param>
            <param name="targetFilePath">Target file path</param>
            <param name="overWrite">True to overwrite existing files</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFileUsingLocks(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Copy the source file to the target path
            </summary>
            <remarks>If the file exists yet overWrite is false, will not copy the file but will still return true</remarks>
            <param name="sourceFilePath">Source file path</param>
            <param name="targetFilePath">Target file path</param>
            <param name="managerName">Manager name (included in the lock file name)</param>
            <param name="overWrite">True to overWrite existing files</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFileUsingLocks(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>
            Copy the source file to the target path
            </summary>
            <remarks>If the file exists yet overWrite is false, will not copy the file but will still return true</remarks>
            <param name="sourceFile">Source file object</param>
            <param name="targetFilePath">Target file path</param>
            <param name="overWrite">True to overWrite existing files</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFileUsingLocks(System.IO.FileInfo,System.String,System.String,System.Boolean)">
            <summary>
            Copy the source file to the target path
            </summary>
            <remarks>If the file exists yet overWrite is false, will not copy the file but will still return true</remarks>
            <param name="sourceFile">Source file object</param>
            <param name="targetFilePath">Target file path</param>
            <param name="managerName">Manager name (included in the lock file name)</param>
            <param name="overWrite">True to overWrite existing files</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFileUsingLocks(System.String,System.String,System.IO.FileInfo,System.String,System.String,System.Boolean)">
            <summary>
            Copy the source file to the target path
            </summary>
            <remarks>If the file exists yet overWrite is false, will not copy the file but will still return true</remarks>
            <param name="lockDirectoryPathSource">Path to the lock directory for the source file; can be an empty string</param>
            <param name="lockDirectoryPathTarget">Path to the lock directory for the target file; can be an empty string</param>
            <param name="sourceFile">Source file object</param>
            <param name="targetFilePath">Target file path</param>
            <param name="managerName">Manager name (included in the lock file name)</param>
            <param name="overWrite">True to overWrite existing files</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFileWithResume(System.String,System.String,System.Boolean@,System.Boolean)">
            <summary>
            Copy a file using chunks, thus allowing for resuming
            </summary>
            <param name="sourceFilePath"></param>
            <param name="targetFilePath"></param>
            <param name="copyResumed"></param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CopyFileWithResume(System.IO.FileInfo,System.String,System.Boolean@,System.Boolean)">
            <summary>
            Copy sourceFile to targetDirectory
            Copies the file using chunks, thus allowing for resuming
            </summary>
            <param name="sourceFile"></param>
            <param name="targetFilePath"></param>
            <param name="copyResumed">Output parameter; true if copying was resumed</param>
            <param name="ignoreFileLocks">When true, copy the file even if another program has it open for writing</param>
            <returns>True if success; false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.CreateDirectoryIfNotExists(System.String)">
            <summary>
            Attempts to create a directory only if it doesn't exist
            </summary>
            <remarks>Also creates parent directories if missing (shows a warning if an error, but continues)</remarks>
            <param name="directoryPath"></param>
        </member>
        <member name="M:PRISM.FileTools.CreateLockFile(System.IO.DirectoryInfo,System.Int64,System.IO.FileInfo,System.String,System.String)">
            <summary>
            Create a lock file in the specified lock directory
            </summary>
            <param name="lockDirectory"></param>
            <param name="lockFileTimestamp"></param>
            <param name="sourceFile"></param>
            <param name="targetFilePath"></param>
            <param name="managerName"></param>
            <returns>Full path to the lock file; empty string if an error or if lockDirectory is null</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteDirectory(System.String)">
            <summary>
            Deletes the specified directory and all subdirectories
            </summary>
            <param name="directoryPath"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteDirectory(System.String,System.Boolean)">
            <summary>
            Deletes the specified directory and all subdirectories
            </summary>
            <param name="directoryPath"></param>
            <param name="ignoreErrors"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteDirectoryFiles(System.String)">
            <summary>
            Deletes the specified directory and all subdirectories; does not delete the target directory
            </summary>
            <remarks>Deletes each file individually.  Deletion errors are reported but are not treated as a fatal error</remarks>
            <param name="directoryPath"></param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteDirectoryFiles(System.String,System.Boolean)">
            <summary>
            Deletes the specified directory and all subdirectories
            </summary>
            <remarks>Deletes each file individually.  Deletion errors are reported but are not treated as a fatal error</remarks>
            <param name="directoryPath"></param>
            <param name="deleteDirectoryIfEmpty">Set to True to delete the directory, if it is empty</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteFileIgnoreErrors(System.String)">
            <summary>
            Delete the specified file
            </summary>
            <remarks>
            <para>
            If the initial attempt fails, checks the ReadOnly bit and tries again
            </para>
            <para>
            If not ReadOnly, performs a garbage collection (minimum 500 msec between GC calls)
            </para>
            </remarks>
            <param name="filePath"></param>
            <returns>True if successfully deleted (or if the file doesn't exist); false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteFileNative(System.IO.FileInfo)">
            <summary>
            Try to delete a file using File.Delete
            If the delete fails due to the path length being 260 characters or longer,
            and if we're running Windows, use DeleteFileW in kernel32.dll instead
            </summary>
            <param name="targetFile"></param>
        </member>
        <member name="M:PRISM.FileTools.DeleteFileWithRetry(System.IO.FileInfo,System.String@)">
            <summary>
            Delete the file, retrying up to 3 times
            </summary>
            <param name="fileToDelete">File to delete</param>
            <param name="errorMessage">Output message: error message if unable to delete the file</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.DeleteFileWithRetry(System.IO.FileInfo,System.Int32,System.String@)">
            <summary>
            Delete the file, retrying up to retryCount times
            </summary>
            <param name="fileToDelete">File to delete</param>
            <param name="retryCount">Maximum number of times to retry the deletion, waiting 500 msec, then 750 msec between deletion attempts</param>
            <param name="errorMessage">Output message: error message if unable to delete the file</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.FindLockFiles(System.IO.DirectoryInfo,System.Int64)">
            <summary>
            Finds lock files with a timestamp less than
            </summary>
            <param name="lockDirectory"></param>
            <param name="lockFileTimestamp"></param>
        </member>
        <member name="M:PRISM.FileTools.GenerateLockFileName(System.Int64,System.IO.FileInfo,System.String)">
            <summary>
            Generate the lock file name, which starts with a msec-based timestamp,
            then has the source file size (in MB),
            then has information on the machine creating the file
            </summary>
            <param name="lockFileTimestamp"></param>
            <param name="sourceFile"></param>
            <param name="managerName"></param>
        </member>
        <member name="M:PRISM.FileTools.GetDirectorySize(System.String)">
            <summary>
            Get the directory size
            </summary>
            <param name="directoryPath">The path to the directory</param>
            <returns>The directory size</returns>
        </member>
        <member name="M:PRISM.FileTools.GetDirectorySize(System.String,System.Int64@,System.Int64@)">
            <summary>
            Get the directory size, file count, and directory count for the entire directory tree
            </summary>
            <param name="directoryPath">The path to the directory</param>
            <param name="fileCount">The number of files in the entire directory tree</param>
            <param name="subDirectoryCount">The number of directories in the entire directory tree</param>
            <returns>The directory size</returns>
        </member>
        <member name="M:PRISM.FileTools.GetDirectorySizeEx(System.String,System.Int64@,System.Int64@)">
            <summary>
            Get the directory size, file count, and directory count for the entire directory tree
            </summary>
            <param name="directoryPath">The path to the directory</param>
            <param name="fileCount">The number of files in the entire directory tree</param>
            <param name="subDirectoryCount">The number of directories in the entire directory tree</param>
            <returns>The directory size</returns>
        </member>
        <member name="M:PRISM.FileTools.GetLockFolder(System.IO.FileInfo)">
            <summary>
            Given a file path, return the lock file directory if it exists
            </summary>
            <remarks>Lock directories are only returned for remote shares (shares that start with \\)</remarks>
            <param name="dataFile"></param>
            <returns>Lock directory path if it exists</returns>
        </member>
        <member name="M:PRISM.FileTools.GetLockDirectory(System.IO.FileInfo)">
            <summary>
            Given a file path, return the lock file directory if it exists
            </summary>
            <remarks>Lock directories are only returned for remote shares (shares that start with \\)</remarks>
            <param name="dataFile"></param>
            <returns>Lock directory path if it exists</returns>
        </member>
        <member name="M:PRISM.FileTools.GetLockDirectoryPath(System.IO.FileInfo)">
            <summary>
            Given a file path, return the lock file directory path (does not verify that it exists)
            </summary>
            <remarks>Lock directories are only returned for remote shares (shares that start with \\)</remarks>
            <param name="dataFile"></param>
            <returns>Lock directory path</returns>
        </member>
        <member name="M:PRISM.FileTools.GetLockFileTimeStamp">
            <summary>
            Get the time stamp to be used when naming a lock file
            </summary>
        </member>
        <member name="M:PRISM.FileTools.GetServerShareBase(System.String)">
            <summary>
            Returns the first portion of a network share path, for example \\MyServer is returned for \\MyServer\Share\Filename.txt
            </summary>
            <remarks>Treats \\picfs as a special share since DMS-related files are at \\picfs\projects\DMS</remarks>
            <param name="serverSharePath"></param>
        </member>
        <member name="M:PRISM.FileTools.GZipCompress(System.IO.FileInfo,System.String,System.String)">
            <summary>
            Compress a file using the built-in GZipStream (stores minimal GZip metadata)
            </summary>
            <param name="fileToCompress">File to compress</param>
            <param name="compressedDirectoryPath">Path to directory where compressed file should be created</param>
            <param name="compressedFileName">Name of compressed file</param>
        </member>
        <member name="M:PRISM.FileTools.GZipCompressWithMetadata(System.IO.FileInfo,System.String,System.String,System.Boolean,System.String,System.Boolean)">
            <summary>
            Compress a file, using a special implementation to add supported metadata to the file (like last modified time and file name)
            </summary>
            <param name="fileToCompress">file to compress</param>
            <param name="compressedDirectoryPath">path to directory where the gzipped file should be created</param>
            <param name="compressedFileName">name for the gzipped file</param>
            <param name="doNotStoreFileName">if true, the filename is not stored in the gzip metadata (so contained file name depends on gzip file name)</param>
            <param name="comment">optional comment to add to gzip metadata (generally not used by decompression programs)</param>
            <param name="addHeaderCrc">if true, a CRC16 hash of the header information is written to the gzip metadata</param>
        </member>
        <member name="M:PRISM.FileTools.GZipDecompress(System.IO.FileInfo,System.String,System.String)">
            <summary>
            Decompress a gzip file
            </summary>
            <param name="fileToDecompress">File to decompress</param>
            <param name="decompressedDirectoryPath">Path to directory where the decompressed file should be created</param>
            <param name="decompressedFileName">Name of decompressed file</param>
        </member>
        <member name="M:PRISM.FileTools.GZipDecompressWithMetadata(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>
            Decompress a file, keeping the correct stored timestamp on the decompressed file and the stored file name
            </summary>
            <param name="fileToDecompress">GZip file to decompress</param>
            <param name="decompressedDirectoryPath">Path to directory where the decompressed file should be created</param>
            <param name="doNotUseStoredFileName">If true, the output file name will use the gzip filename (excluding .gz) even when the filename is available in the gzip metadata</param>
            <returns>Path to the decompressed file</returns>
        </member>
        <member name="M:PRISM.FileTools.IsVimSwapFile(System.String)">
            <summary>
            Returns true if the file is _.swp or starts with a . and ends with .swp
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:PRISM.FileTools.MoveDirectory(System.String,System.String,System.Boolean)">
            <summary>
            Move a directory
            </summary>
            <param name="sourceDirectoryPath"></param>
            <param name="targetDirectoryPath"></param>
            <param name="overwriteFiles"></param>
        </member>
        <member name="M:PRISM.FileTools.MoveDirectory(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Move a directory
            </summary>
            <param name="sourceDirectoryPath"></param>
            <param name="targetDirectoryPath"></param>
            <param name="overwriteFiles"></param>
            <param name="managerName"></param>
        </member>
        <member name="M:PRISM.FileTools.NearlyEqualFileTimes(System.DateTime,System.DateTime)">
            <summary>
            Compares two timestamps (typically the LastWriteTime for a file)
            If they agree within 2 seconds, returns True, otherwise false
            </summary>
            <param name="time1">First file time</param>
            <param name="time2">Second file time</param>
            <returns>True if the times agree within 2.05 seconds</returns>
        </member>
        <member name="M:PRISM.FileTools.RenameFileWithRetry(System.IO.FileInfo,System.String,System.String@,System.Int32)">
            <summary>
            Rename the file, retrying up to retryCount times
            </summary>
            <param name="fileToRename">File to rename</param>
            <param name="newFileName">New file name (just the name, not a full path)</param>
            <param name="errorMessage">Output message: error message if unable to rename the file</param>
            <param name="retryCount">Maximum number of times to retry the rename, waiting 3 sec, then 6 sec between rename attempts</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.RenameFileWithRetry(System.IO.FileInfo,System.IO.FileInfo,System.String@,System.Int32)">
            <summary>
            Rename the file, optionally moving to a different directory
            Retry the rename (or move) up to retryCount times
            </summary>
            <param name="fileToRename">File to rename</param>
            <param name="newFileInfo">FileInfo object for the new file</param>
            <param name="errorMessage">Output message: error message if unable to rename the file</param>
            <param name="retryCount">Maximum number of times to retry the rename, waiting 3 sec, then 6 sec between rename attempts</param>
            <returns>True if successful, false if an error</returns>
        </member>
        <member name="M:PRISM.FileTools.UpdateReadonlyAttribute(System.IO.FileSystemInfo,System.String,System.Boolean)">
            <summary>
            Copies the file attributes from a source file to a target file, explicitly updating the read-only bit based on readOnly
            </summary>
            <param name="sourceFile">Source FileInfo</param>
            <param name="targetFilePath">Target file path</param>
            <param name="readOnly">True to force the ReadOnly bit on, False to force it off</param>
        </member>
        <member name="M:PRISM.FileTools.ValidateFreeDiskSpace(System.String,System.Double,System.Int64,System.String@)">
            <summary>
            Confirms that the drive for the target output file has a minimum amount of free disk space
            </summary>
            <param name="outputFilePath">Path to output file; defines the drive or server share for which we will determine the disk space</param>
            <param name="minimumFreeSpaceMB">
            Minimum free disk space, in MB; defaults to 150 MB if zero or negative
            Takes into account outputFileExpectedSizeMB</param>
            <param name="currentDiskFreeSpaceBytes">
            Amount of free space on the given disk
            Determine on Windows using DiskInfo.GetDiskFreeSpace in PRISMWin.dll
            </param>
            <param name="errorMessage">Output message if there is not enough free space (or if the path is invalid)</param>
            <returns>True if more than minimumFreeSpaceMB is available; otherwise false</returns>
        </member>
        <member name="M:PRISM.FileTools.ValidateFreeDiskSpace(System.String,System.Double,System.Double,System.Int64,System.String@)">
            <summary>
            Confirms that the drive for the target output file has a minimum amount of free disk space
            </summary>
            <remarks>If currentDiskFreeSpaceBytes is negative, this method always returns true (provided the target directory exists)</remarks>
            <param name="outputFilePath">Path to output file; defines the drive or server share for which we will determine the disk space</param>
            <param name="outputFileExpectedSizeMB">Expected size of the output file</param>
            <param name="minimumFreeSpaceMB">
            Minimum free disk space, in MB; defaults to 150 MB if zero or negative.
            Takes into account outputFileExpectedSizeMB.
            </param>
            <param name="currentDiskFreeSpaceBytes">
            Amount of free space on the given disk
            Determine on Windows using DiskInfo.GetDiskFreeSpace in PRISMWin.dll
            </param>
            <param name="errorMessage">Output message if there is not enough free space (or if the path is invalid)</param>
            <returns>True if more than minimumFreeSpaceMB is available; otherwise false</returns>
        </member>
        <member name="M:PRISM.FileTools.WaitForLockFileQueue(System.Int64,System.IO.DirectoryInfo,System.IO.FileInfo,System.Int32)">
            <summary>
            Wait for the lock file queue to drop below a threshold
            </summary>
            <param name="lockFileTimestamp"></param>
            <param name="lockDirectorySource"></param>
            <param name="sourceFile"></param>
            <param name="maxWaitTimeMinutes"></param>
        </member>
        <member name="M:PRISM.FileTools.WaitForLockFileQueue(System.Int64,System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.IO.FileInfo,System.String,System.Int32,System.String,System.String)">
            <summary>
            Wait for the lock file queue to drop below a threshold
            </summary>
            <param name="lockFileTimestamp"></param>
            <param name="lockDirectorySource"></param>
            <param name="lockDirectoryTarget"></param>
            <param name="sourceFile"></param>
            <param name="targetFilePath"></param>
            <param name="maxWaitTimeMinutes"></param>
            <param name="lockFilePathSource"></param>
            <param name="lockFilePathTarget"></param>
        </member>
        <member name="T:PRISM.GZipMetadataStream">
            <summary>
            A stream wrapper for GZip files that makes the GZip file metadata available to read or write
            </summary>
        </member>
        <member name="M:PRISM.GZipMetadataStream.#ctor(System.IO.Stream,System.DateTime,System.String,System.String,System.Boolean)">
            <summary>
            Constructor for writing
            </summary>
            <param name="baseStream">output stream</param>
            <param name="internalLastModified">LastWriteTime for the file being compressed</param>
            <param name="internalFilename">filename of the file being compressed. Do NOT include path components!</param>
            <param name="internalComment">Comment to store to file metadata</param>
            <param name="addHeaderCrc">if true, write a CRC16 for the header to the metadata</param>
        </member>
        <member name="M:PRISM.GZipMetadataStream.#ctor(System.IO.Stream,System.IO.FileInfo,System.String,System.Boolean)">
            <summary>
            Constructor for writing
            </summary>
            <param name="baseStream">output stream</param>
            <param name="inputFile">file being compressed, used for last write time and filename</param>
            <param name="internalComment">Comment to store to file metadata</param>
            <param name="addHeaderCrc">if true, write a CRC16 for the header to the metadata</param>
        </member>
        <member name="M:PRISM.GZipMetadataStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Constructor for reading
            </summary>
            <param name="baseStream">Stream to wrap; must be seek-able (CanSeek == true)</param>
            <param name="checkHeaderCrc"></param>
        </member>
        <member name="P:PRISM.GZipMetadataStream.BaseStream">
            <summary>
            Stream for reading/writing the gzip file
            </summary>
        </member>
        <member name="P:PRISM.GZipMetadataStream.InternalFilename">
            <summary>
            Filename stored in the gzip metadata. 'null' or 'empty' means 'not set'
            </summary>
        </member>
        <member name="P:PRISM.GZipMetadataStream.InternalComment">
            <summary>
            Comment stored in the gzip metadata. 'null' or 'empty' means 'not set'
            </summary>
        </member>
        <member name="P:PRISM.GZipMetadataStream.InternalLastModified">
            <summary>
            Date modified stored in the gzip metadata
            </summary>
            <remarks>
            <para>
            'DateTime.MinValue' or 'DateTime(1970, 1, 1, 0, 0, 0)' mean 'not set'
            </para>
            <para>
            'DateTime.MinValue' is always returned for 'not set' when reading
            </para>
            </remarks>
        </member>
        <member name="P:PRISM.GZipMetadataStream.AddOrCheckHeaderCrc">
            <summary>
            If true, a header CRC16 will be added when writing
            </summary>
        </member>
        <member name="P:PRISM.GZipMetadataStream.HeaderCrc">
            <summary>
            Header CRC16 value stored to or read from the gzip metadata
            </summary>
        </member>
        <member name="P:PRISM.GZipMetadataStream.HeaderCorrupted">
            <summary>
            (Read gzip only) True if the header CRC16 did not match the stored values
            </summary>
        </member>
        <member name="P:PRISM.GZipMetadataStream.HeaderRead">
            <summary>
            (Read gzip only) True if the gzip headers were read. If false, it usually means BaseStream.CanSeek is false
            </summary>
        </member>
        <member name="M:PRISM.GZipMetadataStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:PRISM.GZipMetadataStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:PRISM.GZipMetadataStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:PRISM.GZipMetadataStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PRISM.GZipMetadataStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:PRISM.GZipMetadataStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:PRISM.GZipMetadataStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:PRISM.GZipMetadataStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:PRISM.GZipMetadataStream.Length">
            <inheritdoc />
        </member>
        <member name="P:PRISM.GZipMetadataStream.Position">
            <inheritdoc />
        </member>
        <member name="T:PRISM.HashUtilities">
            <summary>
            Methods for computing checksum hashes for files
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.DATE_TIME_FORMAT">
            <summary>
            Default date/time format
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HASHCHECK_FILE_SUFFIX">
            <summary>
            Hashcheck file suffix
            </summary>
        </member>
        <member name="T:PRISM.HashUtilities.HashTypeConstants">
            <summary>
            Hash type constants
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashTypeConstants.Undefined">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashTypeConstants.CRC32">
            <summary>
            CRC32
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashTypeConstants.MD5">
            <summary>
            MD5, as a hex string
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashTypeConstants.SHA1">
            <summary>
            SHA-1
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashTypeConstants.MD5Base64">
            <summary>
            MD5, as a Base64 encoded string
            </summary>
        </member>
        <member name="T:PRISM.HashUtilities.HashInfoType">
            <summary>
            Hash info, tracking file size, date, hash, and hash type
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashInfoType.FileSize">
            <summary>
            File size, in bytes
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashInfoType.FileDateUtc">
            <summary>
            File modification date (UTC)
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashInfoType.HashType">
            <summary>
            Hash type (typically MD5 or SHA1)
            </summary>
        </member>
        <member name="F:PRISM.HashUtilities.HashInfoType.HashValue">
            <summary>
            Have value
            </summary>
        </member>
        <member name="M:PRISM.HashUtilities.HashInfoType.Clear">
            <summary>
            Reset values to defaults
            </summary>
            <remarks>HashType will be Undefined</remarks>
        </member>
        <member name="M:PRISM.HashUtilities.ByteArrayToString(System.Collections.Generic.IReadOnlyCollection{System.Byte})">
            <summary>
            Converts a byte array into a hex string
            </summary>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeFileHashCrc32(System.String)">
            <summary>
            Computes the CRC32 hash of a file
            </summary>
            <param name="filePath"></param>
            <returns>CRC32 hash, as a string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeFileHashMD5(System.String)">
            <summary>
            Computes the MD5 hash of a file
            </summary>
            <param name="filePath"></param>
            <returns>MD5 hash, as a hex string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeFileHashMD5(System.String,System.String@)">
            <summary>
            Computes the MD5 hash of a file, both as a hex string and as a Base64 encoded string
            </summary>
            <param name="filePath"></param>
            <param name="base64MD5">Output: Base64 encoded MD5 hash</param>
            <returns>MD5 hash, as a hex string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeStringHashMD5(System.String)">
            <summary>
            Computes the MD5 hash of a string
            </summary>
            <param name="text"></param>
            <returns>MD5 hash, as a hex string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeStringHashMD5(System.String,System.String@)">
            <summary>
            Computes the MD5 hash of a string, both as a hex string and as a Base64 encoded string
            </summary>
            <param name="text"></param>
            <param name="base64MD5">Output: Base64 encoded MD5 hash</param>
            <returns>MD5 hash, as a hex string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeFileHash(System.String,PRISM.HashUtilities.HashTypeConstants)">
            <summary>
            Computes the hash of a file
            </summary>
            <param name="filePath"></param>
            <param name="hashType">Hash type</param>
            <returns>Hash value</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeFileHashSha1(System.String)">
            <summary>
            Computes the SHA-1 hash for a file
            </summary>
            <param name="filePath"></param>
            <returns>SHA-1 hash, as a hex string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeStringHashSha1(System.String)">
            <summary>
            Computes the SHA-1 hash for a string
            </summary>
            <param name="text"></param>
            <returns>SHA-1 hash, as a hex string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeCRC32Hash(System.IO.Stream)">
            <summary>
            Computes the CRC32 hash of a given stream
            </summary>
            <param name="data"></param>
            <returns>CRC32 hash, as a string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeMD5Hash(System.IO.Stream,System.String@)">
            <summary>
            Computes the MD5 hash of a given stream
            </summary>
            <param name="data"></param>
            <param name="base64MD5">Output: Base64 encoded MD5 hash</param>
            <returns>MD5 hash, as a string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeSha1Hash(System.IO.Stream)">
            <summary>
            Computes the SHA-1 hash of a given stream
            </summary>
            <param name="data"></param>
            <returns>SHA-1 hash, as a string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeHash(System.Security.Cryptography.HashAlgorithm,System.IO.Stream)">
            <summary>
            Use the given hash algorithm to compute a hash of the data stream
            </summary>
            <param name="hasher"></param>
            <param name="data"></param>
            <returns>Hash string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ComputeHashGetByteArray(System.Security.Cryptography.HashAlgorithm,System.IO.Stream)">
            <summary>
            Use the given hash algorithm to compute a hash of the data stream
            </summary>
            <param name="hasher"></param>
            <param name="data"></param>
            <returns>Hash string</returns>
        </member>
        <member name="M:PRISM.HashUtilities.CreateHashcheckFile(System.String,PRISM.HashUtilities.HashTypeConstants,System.String@,System.String@)">
            <summary>
            Creates a .hashcheck file for the specified file
            The file will be created in the same directory as the data file, and will contain size, modification_date_utc, and hash
            </summary>
            <param name="dataFilePath">File path to hash</param>
            <param name="hashType">Hash type</param>
            <param name="hashValue">Output: the computed file hash</param>
            <param name="warningMessage">Output: warning message</param>
            <returns>The full path to the .hashcheck file; empty string if a problem</returns>
        </member>
        <member name="M:PRISM.HashUtilities.CreateHashcheckFileWithHash(System.String,PRISM.HashUtilities.HashTypeConstants,System.String,System.String@)">
            <summary>
            Creates a .hashcheck file for the specified file
            The file will be created in the same directory as the data file, and will contain size, modification_date_utc, hash, and hashtype
            </summary>
            <param name="dataFilePath">File path to hash</param>
            <param name="hashType">Hash type</param>
            <param name="hashValue">Output: the computed file hash</param>
            <param name="warningMessage">Output: warning message</param>
            <returns>The full path to the .hashcheck file; empty string if a problem</returns>
        </member>
        <member name="M:PRISM.HashUtilities.ReadHashcheckFile(System.String,PRISM.HashUtilities.HashTypeConstants)">
            <summary>
            Read the data in an existing hashcheck file
            </summary>
            <param name="hashCheckFilePath"></param>
            <param name="assumedHashType">
            Hashtype to assume if the .hashcheck file does not have "hashtype" defined and if the hash length is not 8, 32, or 40
            </param>
            <returns>Hash info</returns>
        </member>
        <member name="T:PRISM.NativeIODirectoryTools">
            <summary>
            Methods for copying and deleting directories with path lengths of 260 characters or longer
            These only work on Windows
            </summary>
            <remarks>
            From https://stackoverflow.com/a/39534444/1179467
            </remarks>
        </member>
        <member name="F:PRISM.NativeIODirectoryTools.DIRECTORY_PATH_LENGTH_THRESHOLD">
            <summary>
            Directory path length threshold at which we should switch to NativeIO calls
            </summary>
        </member>
        <member name="M:PRISM.NativeIODirectoryTools.Exists(System.String)">
            <summary>
            Check whether the directory exists
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:PRISM.NativeIODirectoryTools.CreateDirectory(System.String)">
            <summary>
            Create a directory, optionally having a long path
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:PRISM.NativeIODirectoryTools.Delete(System.String,System.Boolean)">
            <summary>
            Delete a directory, optionally having a long path
            </summary>
            <param name="path"></param>
            <param name="recursive"></param>
        </member>
        <member name="M:PRISM.NativeIODirectoryTools.GetDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Find directories that match a search pattern
            </summary>
            <param name="path">Path to the directory to examine</param>
            <param name="searchPattern">Search pattern; use null or * to find all subdirectories</param>
            <param name="searchOption">Whether to search the current directory only, or also search below all subdirectories</param>
            <returns>List of paths</returns>
        </member>
        <member name="M:PRISM.NativeIODirectoryTools.GetFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Find files that match a search pattern
            </summary>
            <param name="path">Path to the directory to examine</param>
            <param name="searchPattern">Search pattern; use null or * to find all subdirectories</param>
            <param name="searchOption">Whether to search the current directory only, or also search below all subdirectories</param>
            <returns>List of paths</returns>
        </member>
        <member name="T:PRISM.NativeIOFileTools">
            <summary>
            Methods for copying and deleting files with path lengths of 260 characters or longer
            These only work on Windows
            </summary>
            <remarks>
            From https://stackoverflow.com/a/39534444/1179467
            </remarks>
        </member>
        <member name="F:PRISM.NativeIOFileTools.FILE_PATH_LENGTH_THRESHOLD">
            <summary>
            File path length threshold at which we should switch to NativeIO calls
            </summary>
        </member>
        <member name="F:PRISM.NativeIOFileTools.WIN32_LONG_PATH_PREFIX">
            <summary>
            Prefix that indicates a Win32 Long Path
            </summary>
        </member>
        <member name="M:PRISM.NativeIOFileTools.Exists(System.String)">
            <summary>
            Check whether the file exists
            </summary>
            <param name="path"></param>
            <returns>True if the file exists, otherwise false</returns>
        </member>
        <member name="M:PRISM.NativeIOFileTools.Copy(System.String,System.String,System.Boolean)">
            <summary>
            Copy the file
            </summary>
            <param name="sourcePath"></param>
            <param name="destPath"></param>
            <param name="overwrite"></param>
        </member>
        <member name="M:PRISM.NativeIOFileTools.Delete(System.String)">
            <summary>
            Delete the file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:PRISM.NativeIOFileTools.GetWin32LongPath(System.String)">
            <summary>
            Format the path as a Win32 long path
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:PRISM.NativeIOFileTools.GetCleanPath(System.String)">
            <summary>
            Remove Win32 long path characters
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:PRISM.NativeIOFileTools.GetFileLength(System.String)">
            <summary>
            Get the size of a file, in bytes
            </summary>
            <param name="filePath"></param>
            <returns>File size, in bytes</returns>
        </member>
        <member name="T:PRISM.NativeIOMethods">
            <summary>
            Methods for working with files and directories with path lengths of 260 characters or longer
            These only work on Windows
            </summary>
            <remarks>
            From https://stackoverflow.com/a/39534444/1179467
            </remarks>
        </member>
        <member name="M:PRISM.NativeIOMethods.CreateDirectory(System.String,System.IntPtr)">
            <summary>
            Win32 IO CreateDirectory
            </summary>
            <param name="lpPathName"></param>
            <param name="lpSecurityAttributes">Use "IntPtr.Zero" for NULL (default) security attributes</param>
        </member>
        <member name="M:PRISM.NativeIOMethods.CreateFile(System.String,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Win32 IO CreateFile
            </summary>
            <param name="lpFileName"></param>
            <param name="dwDesiredAccess"></param>
            <param name="dwShareMode"></param>
            <param name="lpSecurityAttributes">Use "IntPtr.Zero" for NULL (default) security attributes</param>
            <param name="dwCreationDisposition"></param>
            <param name="dwFlagsAndAttributes"></param>
            <param name="hTemplateFile"></param>
        </member>
        <member name="T:PRISM.PathUtils">
            <summary>
            Cross-platform path utilities
            </summary>
        </member>
        <member name="M:PRISM.PathUtils.AssureLinuxPath(System.String)">
            <summary>
            Convert a path to be Linux-compatible (backslash to forward slash
            </summary>
            <param name="pathSpec"></param>
        </member>
        <member name="M:PRISM.PathUtils.AssureWindowsPath(System.String)">
            <summary>
            Convert a path to be Windows-compatible (forward slash to backslash
            </summary>
            <param name="pathSpec"></param>
        </member>
        <member name="M:PRISM.PathUtils.CombinePathsLocalSepChar(System.String,System.String)">
            <summary>
            Combine paths using the system default path separator character
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="M:PRISM.PathUtils.CombineLinuxPaths(System.String,System.String)">
            <summary>
            Combine paths using a forward slash as a path separator character
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="M:PRISM.PathUtils.CombineWindowsPaths(System.String,System.String)">
            <summary>
            Combine paths using a backslash as a path separator character
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="M:PRISM.PathUtils.CombinePaths(System.String,System.String,System.Char)">
            <summary>
            Combine paths using the specified path separator character
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
            <param name="directorySepChar"></param>
        </member>
        <member name="M:PRISM.PathUtils.CompactPathString(System.String,System.Int32)">
            <summary>
            Shorten pathToCompact to a maximum length of maxLength
            Examples:
            C:\...\B..\Finance..
            C:\...\W..\Business\Finances.doc
            C:\My Doc..\Word\Business\Finances.doc
            </summary>
            <param name="pathToCompact"></param>
            <param name="maxLength">Maximum length of the shortened path</param>
            <returns>Shortened path</returns>
        </member>
        <member name="M:PRISM.PathUtils.FindDirectoriesWildcard(System.String,System.Boolean)">
            <summary>
            Find all directories that match the given directory name pattern, optionally recursing
            </summary>
            <remarks>When recursing, skips directories for which the user does not have permission</remarks>
            <param name="pathSpec">Directory/subdirectory search specification, e.g. F:\MSData\15T\*.d</param>
            <param name="recurse">True to recurse</param>
            <returns>List of DirectoryInfo objects (empty list if the directory does not exist)</returns>
        </member>
        <member name="M:PRISM.PathUtils.FindDirectoriesWildcard(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>
            Find all directories that match the given directory name pattern in the given directory, optionally recursing
            </summary>
            <remarks>When recursing, skips directories for which the user does not have permission</remarks>
            <param name="directory">Directory to search</param>
            <param name="directoryMask">Name mask to find, e.g. *.d</param>
            <param name="recurse">True to recurse</param>
            <returns>List of DirectoryInfo objects (empty list if the directory does not exist)</returns>
        </member>
        <member name="M:PRISM.PathUtils.FindFilesWildcard(System.String,System.Boolean)">
            <summary>
            Find all files that match the given file name pattern, optionally recursing
            </summary>
            <remarks>When recursing, skips directories for which the user does not have permission</remarks>
            <param name="pathSpec">Directory/file search specification, e.g. C:\Windows\*.ini</param>
            <param name="recurse">True to recurse</param>
            <returns>List of FileInfo objects (empty list if the directory does not exist)</returns>
        </member>
        <member name="M:PRISM.PathUtils.FindFilesWildcard(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>
            Find all files that match the given file name pattern in the given directory, optionally recursing
            </summary>
            <remarks>When recursing, skips directories for which the user does not have permission</remarks>
            <param name="directory">Directory to search</param>
            <param name="fileMask">Filename mask to find, e.g. *.txt</param>
            <param name="recurse">True to recurse</param>
            <returns>List of FileInfo objects (empty list if the directory does not exist)</returns>
        </member>
        <member name="M:PRISM.PathUtils.FitsMask(System.String,System.String)">
            <summary>
            Check a filename against a file mask (like * or *.txt or MSGF*)
            </summary>
            <remarks>From https://stackoverflow.com/a/725352/1179467/ how-to-determine-if-a-file-matches-a-file-mask</remarks>
            <param name="fileName"></param>
            <param name="fileMask"></param>
            <returns>True if a match, otherwise false</returns>
        </member>
        <member name="M:PRISM.PathUtils.GetCleanPath(System.String)">
            <summary>
            Replace * and ? characters in fileOrDirectoryPath with underscores
            </summary>
            <param name="fileOrDirectoryPath"></param>
        </member>
        <member name="M:PRISM.PathUtils.GetParentDirectoryPath(System.String,System.String@)">
            <summary>
            Return the parent directory of directoryPath
            Supports both Windows paths and Linux paths
            </summary>
            <remarks>Returns \ or / if the path is rooted and the parent is a path</remarks>
            <param name="directoryPath">Directory path to examine</param>
            <param name="directoryName">Name of the directory in directoryPath but without the parent path</param>
            <returns>Parent directory path, or an empty string if no parent</returns>
        </member>
        <member name="M:PRISM.PathUtils.PossiblyQuotePath(System.String)">
            <summary>
            Examines filePath to look for spaces
            </summary>
            <param name="filePath"></param>
            <returns>filePath as-is if no spaces, otherwise filePath surrounded by double quotes </returns>
        </member>
        <member name="M:PRISM.PathUtils.ReplaceFilenameInPath(System.String,System.String)">
            <summary>
            Replace the filename in the path with a new filename
            </summary>
            <param name="existingFilePath"></param>
            <param name="newFileName"></param>
        </member>
        <member name="T:PRISM.ShareConnector">
            <summary>
            Connects to a file share using a password and user name
            </summary>
            <remarks>
            <para>
            The default behavior when connecting to SMB/CIFS file shares is for
            the system to supply the user name and password used to log on to the local machine
            </para>
            <para>
            This class allows you to connect to SMB/CIFS file shares when the use of
            SSPI isn't available and/or when you don't wish to use the default behavior
            </para>
            <para>
            It's quite comparable to the "Connect using a different user name." option in the Map Network Drive
            utility in Windows. Much of this code came from Microsoft Knowledge Base Article - 173011
            </para>
            </remarks>
        </member>
        <member name="T:PRISM.ShareConnector.NetResourceInfo">
            <summary>
            This structure is used to group a bunch of member variables
            </summary>
        </member>
        <member name="F:PRISM.ShareConnector.RESOURCE_USAGE_CONNECTABLE">
            <summary>
            Constant that may be used by NETRESOURCE->dwUsage
            </summary>
        </member>
        <member name="F:PRISM.ShareConnector.RESOURCE_USAGE_CONTAINER">
            <summary>
            Constant that may be used by NETRESOURCE->dwUsage
            </summary>
        </member>
        <member name="M:PRISM.ShareConnector.#ctor(System.String,System.String)">
            <summary>
            This version of the constructor requires you to specify the share name by setting the <see cref="P:PRISM.ShareConnector.Share">Share</see> property
            </summary>
            <remarks>For local user accounts, it is safest to use HostName\username</remarks>
            <param name="userName">Username</param>
            <param name="userPwd">Password</param>
        </member>
        <member name="M:PRISM.ShareConnector.#ctor(System.String,System.String,System.String)">
            <summary>
            This version of the constructor allows you to specify the share name as an argument
            </summary>
            <remarks>For local user accounts, it is safest to use HostName\username</remarks>  ///
            <param name="shareName">The name of the file share to which you will connect</param>
            <param name="userName">Username</param>
            <param name="userPwd">Password</param>
        </member>
        <member name="M:PRISM.ShareConnector.RealNew(System.String,System.String)">
            <summary>
            This routine is called by each of the constructors to make the actual assignments in a consistent fashion
            </summary>
            <param name="userName">Username</param>
            <param name="userPwd">Password</param>
        </member>
        <member name="P:PRISM.ShareConnector.Share">
            <summary>
            Sets the name of the file share to which you will connect
            </summary>
        </member>
        <member name="M:PRISM.ShareConnector.Connect(System.String)">
            <summary>
            Connects to specified share using account/password specified through the constructor and
            the file share name passed as an argument
            </summary>
            <param name="shareName">The name of the file share to which you will connect</param>
        </member>
        <member name="M:PRISM.ShareConnector.Connect">
            <summary>
            Connects to specified share using account/password specified through the constructor
            <remarks>
            Requires you to have specified the share name by setting the <see cref="P:PRISM.ShareConnector.Share">Share</see> property
            </remarks>
            </summary>
        </member>
        <member name="M:PRISM.ShareConnector.DefineShareName(System.String)">
            <summary>
            Updates class variable with the specified share path
            </summary>
            <remarks>If the path ends in a forward slash then the slash will be removed</remarks>
            <param name="shareName"></param>
        </member>
        <member name="M:PRISM.ShareConnector.RealConnect">
            <summary>
            Connects to specified share using account/password specified previously
            </summary>
        </member>
        <member name="M:PRISM.ShareConnector.Disconnect">
            <summary>
            Disconnects the file share
            </summary>
        </member>
        <member name="P:PRISM.ShareConnector.ErrorMessage">
            <summary>
            Gets the error message returned by the Connect and Disconnect methods
            </summary>
        </member>
        <member name="T:PRISM.ZipTools">
            <summary>
            Routines for calling an external zipping program like 7-zip.exe
            </summary>
            <remarks>
            There are routines to create an archive, extract files from an existing archive,
            and verify an existing archive
            </remarks>
        </member>
        <member name="F:PRISM.ZipTools.mWaitInterval">
            <summary>
            Interval, in milliseconds, to sleep between checking the status of a zip or unzip task
            </summary>
        </member>
        <member name="F:PRISM.ZipTools.mLogger">
            <summary>
            Logging class
            </summary>
        </member>
        <member name="M:PRISM.ZipTools.MakeZipFile(System.String,System.String,System.String)">
            <summary>
            Create a zip file
            </summary>
            <param name="cmdOptions">The zip program command line arguments</param>
            <param name="outputFile">The file path of the output zip file</param>
            <param name="inputSpec">The files and/or directories to archive</param>
        </member>
        <member name="M:PRISM.ZipTools.UnzipFile(System.String,System.String,System.String)">
            <summary>
            Extract files from a zip file
            </summary>
            <param name="cmdOptions">The zip program command line arguments</param>
            <param name="zipFilePath">The file path of the zip file from which to extract files</param>
            <param name="outputDirectoryPath">The path where you want to put the extracted files</param>
        </member>
        <member name="P:PRISM.ZipTools.CreateNoWindow">
            <summary>
            Defines whether a window is displayed when calling the zipping program
            </summary>
        </member>
        <member name="P:PRISM.ZipTools.WindowStyle">
            <summary>
            Window style to use when CreateNoWindow is False
            </summary>
        </member>
        <member name="P:PRISM.ZipTools.WorkDir">
            <summary>
            The working directory for the zipping process
            </summary>
        </member>
        <member name="P:PRISM.ZipTools.ZipFilePath">
            <summary>
            The path to the zipping program
            </summary>
        </member>
        <member name="M:PRISM.ZipTools.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the ZipTools class
            </summary>
            <param name="workDir">The working directory for the zipping process</param>
            <param name="zipFilePath">The path to the zipping program</param>
        </member>
        <member name="M:PRISM.ZipTools.VerifyZippedFile(System.String)">
            <summary>
            Verifies the integrity of a zip file
            </summary>
            <param name="zipFilePath">The file path of the zip file to verify</param>
        </member>
        <member name="M:PRISM.ZipTools.RegisterEventLogger(PRISM.Logging.BaseLogger)">
            <summary>
            Associate a logger with this class
            </summary>
        </member>
        <member name="M:PRISM.ZipTools.RegisterEventLogger(PRISM.ILogger)">
            <summary>
            Associate an event logger with this class
            </summary>
        </member>
        <member name="P:PRISM.ZipTools.NotifyOnEvent">
            <summary>
            Gets or Sets notify on event
            </summary>
        </member>
        <member name="P:PRISM.ZipTools.NotifyOnException">
            <summary>
            Gets or Sets notify on exception
            </summary>
        </member>
        <member name="T:PRISM.logMsgType">
            <summary>
            The type of log message
            </summary>
        </member>
        <member name="F:PRISM.logMsgType.logNormal">
            <summary>
            The message is informational
            </summary>
        </member>
        <member name="F:PRISM.logMsgType.logError">
            <summary>
            The message represents an error
            </summary>
        </member>
        <member name="F:PRISM.logMsgType.logWarning">
            <summary>
            The message represents a warning
            </summary>
        </member>
        <member name="F:PRISM.logMsgType.logDebug">
            <summary>
            The message is only for debugging purposes
            </summary>
        </member>
        <member name="F:PRISM.logMsgType.logNA">
            <summary>
            The message does not apply
            </summary>
        </member>
        <member name="F:PRISM.logMsgType.logHealth">
            <summary>
            The message is an indicator of (in)correct operation
            </summary>
        </member>
        <member name="T:PRISM.ILogger">
            <summary>
            Defines the logging interface
            </summary>
        </member>
        <member name="P:PRISM.ILogger.CurrentLogFilePath">
            <summary>
            Current log file path
            </summary>
        </member>
        <member name="P:PRISM.ILogger.MostRecentLogMessage">
            <summary>
            Most recent log message
            </summary>
        </member>
        <member name="P:PRISM.ILogger.MostRecentErrorMessage">
            <summary>
            Most recent error
            </summary>
        </member>
        <member name="M:PRISM.ILogger.PostEntries(System.Collections.Generic.List{PRISM.clsLogEntry})">
            <summary>
            Posts a message to the log
            </summary>
            <param name="messages">The messages to post</param>
        </member>
        <member name="M:PRISM.ILogger.PostEntry(System.String,PRISM.logMsgType,System.Boolean)">
            <summary>
            Posts a message to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="entryType">The ILogger error type</param>
            <param name="localOnly">If true, only post the message to the local log file, not the database; only used by clsDBLogger</param>
        </member>
        <member name="M:PRISM.ILogger.PostError(System.String,System.Exception,System.Boolean)">
            <summary>
            Posts an error to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="e">The exception associated with the error</param>
            <param name="localOnly">
            Only used by clsDBLogger
            When true, only post the message to the local log file
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="T:PRISM.clsFileLogger">
            <summary>
            Provides logging to a local file
            </summary>
            <remarks>
            The actual log file name changes daily and is of the form "filePath_mm-dd-yyyy.txt"
            </remarks>
        </member>
        <member name="F:PRISM.clsFileLogger.FILENAME_DATE_STAMP">
            <summary>
            Default filename timestamp format string
            </summary>
        </member>
        <member name="F:PRISM.clsFileLogger.mProgramName">
            <summary>
            Program name
            </summary>
            <remarks>Auto-determined using Assembly.GetEntryAssembly</remarks>
        </member>
        <member name="F:PRISM.clsFileLogger.mProgramVersion">
            <summary>
            Program version
            </summary>
            <remarks>Auto-determined using Assembly.GetEntryAssembly</remarks>
        </member>
        <member name="M:PRISM.clsFileLogger.#ctor">
            <summary>
            Initializes a new instance of the clsFileLogger class
            </summary>
            <remarks>This constructor (without a file path) is required because clsDBLogger inherits clsFileLogger</remarks>
        </member>
        <member name="M:PRISM.clsFileLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the clsFileLogger class which logs to the specified file
            </summary>
            <remarks>
            The actual log file name changes daily and is of the form "FilePath_mm-dd-yyyy.txt"
            logFileBaseName is allowed to be blank (e.g. if using clsDBLogger and there is no need for a local log file)
            </remarks>
            <param name="logFileBaseName">The name of the file to use for the log (either a filename like UpdateManager, or a relative path, like Logs\UpdateManager</param>
        </member>
        <member name="P:PRISM.clsFileLogger.ArchiveOldLogFiles">
            <summary>
            When true, auto-archive old log files daily
            </summary>
        </member>
        <member name="P:PRISM.clsFileLogger.CurrentLogFilePath">
            <summary>
            Path to the current log file (ReadOnly)
            </summary>
        </member>
        <member name="P:PRISM.clsFileLogger.ExecutableVersion">
            <summary>
            Gets the product version associated with this application
            </summary>
        </member>
        <member name="P:PRISM.clsFileLogger.ExecutableName">
            <summary>
            Gets the name of the executable file that started the application
            </summary>
        </member>
        <member name="P:PRISM.clsFileLogger.LogFileBaseName">
            <summary>
            The base name of the log file, e.g. UpdateManager or Logs\UpdateManager
            </summary>
            <remarks>
            The actual log file name changes daily and is of the form "FilePath_mm-dd-yyyy.txt"
            This property is ReadOnly; define when instantiating the logger using the constructor
            </remarks>
        </member>
        <member name="P:PRISM.clsFileLogger.LogFilePath">
            <summary>
            The base name of the log file, e.g. UpdateManager or Logs\UpdateManager
            </summary>
            <remarks>The actual log file name changes daily and is of the form "FilePath_mm-dd-yyyy.txt"</remarks>
        </member>
        <member name="P:PRISM.clsFileLogger.MostRecentLogMessage">
            <summary>
            Most recent log message
            </summary>
        </member>
        <member name="P:PRISM.clsFileLogger.MostRecentErrorMessage">
            <summary>
            Most recent error message
            </summary>
        </member>
        <member name="M:PRISM.clsFileLogger.ArchiveOldLogs">
            <summary>
            Move log files more than 32 days old into a year-based directory
            </summary>
        </member>
        <member name="M:PRISM.clsFileLogger.LogToFile(System.Collections.Generic.IEnumerable{PRISM.clsLogEntry})">
            <summary>
            Writes a message to the log file
            </summary>
            <param name="messages">List of messages to post</param>
        </member>
        <member name="M:PRISM.clsFileLogger.PostEntries(System.Collections.Generic.List{PRISM.clsLogEntry})">
            <summary>
            Posts a message to the log
            </summary>
            <param name="messages">The messages to post</param>
        </member>
        <member name="M:PRISM.clsFileLogger.PostEntry(System.String,PRISM.logMsgType,System.Boolean)">
            <summary>
            Posts a message to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="entryType">The ILogger error type</param>
            <param name="localOnly">
            Only used by clsDBLogger
            When true, only post the message to the local log file
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="M:PRISM.clsFileLogger.PostError(System.String,System.Exception,System.Boolean)">
            <summary>
            Posts an error to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="ex">The exception associated with the error</param>
            <param name="localOnly">
            Only used by clsDBLogger
            When true, only post the message to the local log file
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="M:PRISM.clsFileLogger.TypeToString(PRISM.logMsgType)">
            <summary>
            Converts enumerated error type to string for logging output
            </summary>
            <param name="errorType">The ILogger error type</param>
        </member>
        <member name="T:PRISM.clsDBLogger">
            <summary>
            Provides logging to a database and local file
            </summary>
            <remarks>The module name identifies the logging process; if not defined, will use MachineName:UserName</remarks>
        </member>
        <member name="F:PRISM.clsDBLogger.mErrorList">
            <summary>
            List of database errors
            </summary>
        </member>
        <member name="F:PRISM.clsDBLogger.mModuleName">
            <summary>
            Module name
            </summary>
        </member>
        <member name="M:PRISM.clsDBLogger.#ctor">
            <summary>
            Initializes a new instance of the clsDBLogger class
            </summary>
        </member>
        <member name="M:PRISM.clsDBLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the clsDBLogger class which logs to the specified database
            </summary>
            <remarks>Only logs to a local file if a file name is defined using LogFilePath</remarks>
            <param name="connectionStr">The connection string used to access the database</param>
        </member>
        <member name="M:PRISM.clsDBLogger.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the clsDBLogger class which logs to the specified database and file
            </summary>
            <param name="connectionStr">The connection string used to access the database</param>
            <param name="filePath">The name of the file to use for the log</param>
        </member>
        <member name="M:PRISM.clsDBLogger.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the clsDBLogger class which logs to the specified database and file
            </summary>
            <remarks>The module name identifies the logging process; if not defined, will use MachineName:UserName</remarks>
            <param name="modName">The string used to identify the posting process</param>
            <param name="connectionStr">The connection string used to access the database</param>
            <param name="filePath">The name of the file to use for the log</param>
        </member>
        <member name="P:PRISM.clsDBLogger.ConnectionString">
            <summary>
            The connection string used to access the database
            </summary>
        </member>
        <member name="P:PRISM.clsDBLogger.DBErrors">
            <summary>
            List of any database errors that occurred while posting the log entry to the database
            </summary>
        </member>
        <member name="P:PRISM.clsDBLogger.MachineName">
            <summary>
            The module name identifies the logging process
            </summary>
        </member>
        <member name="M:PRISM.clsDBLogger.ConstructModuleName">
            <summary>
            Construct the string MachineName:UserName
            </summary>
        </member>
        <member name="P:PRISM.clsDBLogger.ModuleName">
            <summary>
            The module name identifies the logging process
            </summary>
            <remarks>If the module name is not specified, it is filled in as MachineName:UserName</remarks>
        </member>
        <member name="M:PRISM.clsDBLogger.LogToDB(System.String,PRISM.logMsgType)">
            <summary>
            Writes a message to the log table
            </summary>
            <param name="message">The message to post</param>
            <param name="entryType">The ILogger error type</param>
        </member>
        <member name="M:PRISM.clsDBLogger.PostEntries(System.Collections.Generic.List{PRISM.clsLogEntry})">
            <summary>
            Posts a message to the log
            </summary>
            <param name="messages">The messages to post</param>
        </member>
        <member name="M:PRISM.clsDBLogger.PostEntry(System.String,PRISM.logMsgType,System.Boolean)">
            <summary>
            Posts a message to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="entryType">The ILogger error type</param>
            <param name="localOnly">
            When true, only post the message to the local log file;
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="M:PRISM.clsDBLogger.PostError(System.String,System.Exception,System.Boolean)">
            <summary>
            Posts an error to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="ex">The exception associated with the error</param>
            <param name="localOnly">
            When true, only post the message to the local log file;
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="M:PRISM.clsDBLogger.PostLogEntry(System.String,System.String)">
            <summary>
            Writes a message to the log table via the stored procedure
            </summary>
            <param name="type">The ILogger error type</param>
            <param name="message">The message to post</param>
        </member>
        <member name="M:PRISM.clsDBLogger.OnInfoMessage(System.Object,System.Data.SqlClient.SqlInfoMessageEventArgs)">
            <summary>
            Event handler for InfoMessage event
            </summary>
            <remarks>Errors and warnings sent from the SQL Server database engine are caught here</remarks>
        </member>
        <member name="T:PRISM.clsLogEntry">
            <summary>
            A class to hold a log entry
            </summary>
        </member>
        <member name="F:PRISM.clsLogEntry.Message">
            <summary>
            Log message
            </summary>
        </member>
        <member name="F:PRISM.clsLogEntry.EntryType">
            <summary>
            Log message type
            </summary>
        </member>
        <member name="F:PRISM.clsLogEntry.LocalOnly">
            <summary>
            Only used by clsDBLogger
            When true, log to the local file but not to the database
            When false, log to the local log file and the database
            </summary>
        </member>
        <member name="M:PRISM.clsLogEntry.#ctor(System.String,PRISM.logMsgType,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="message">Log message</param>
            <param name="entryType">Message type</param>
            <param name="localOnly">
            Only used by clsDBLogger
            When true, only post the message to the local log file
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="T:PRISM.clsQueLogger">
            <summary>
            Wraps a queuing mechanism around any object that implements ILogger interface
            </summary>
            <remarks>
            <para>
            The posting member methods of this class put the log entry
            onto the end of an internal queue and return very quickly to the caller
            </para>
            <para>
            A separate thread within the class is used to perform the actual output of
            the log entries using the logging object that is specified
            in the constructor for this class
            </para>
            </remarks>
        </member>
        <member name="F:PRISM.clsQueLogger.mQueue">
            <summary>
            queue to hold entries to be output
            </summary>
        </member>
        <member name="F:PRISM.clsQueLogger.mThreadTimer">
            <summary>
            Internal thread for outputting entries from queue
            </summary>
        </member>
        <member name="F:PRISM.clsQueLogger.mLogger">
            <summary>
            logger object to use for outputting entries from queue
            </summary>
        </member>
        <member name="P:PRISM.clsQueLogger.CurrentLogFilePath">
            <summary>
            Path to the current log file
            </summary>
        </member>
        <member name="P:PRISM.clsQueLogger.MostRecentLogMessage">
            <summary>
            Most recent log message
            </summary>
        </member>
        <member name="P:PRISM.clsQueLogger.MostRecentErrorMessage">
            <summary>
            Most recent error message
            </summary>
        </member>
        <member name="M:PRISM.clsQueLogger.#ctor(PRISM.ILogger)">
            <summary>
            Constructor: Initializes a new instance of the clsQueLogger class which logs to the ILogger
            </summary>
            <param name="logger">The target logger object</param>
        </member>
        <member name="M:PRISM.clsQueLogger.LogFromQueue(System.Object)">
            <summary>
            Pull all entries from the queue and output them to the log streams
            </summary>
        </member>
        <member name="M:PRISM.clsQueLogger.PostEntries(System.Collections.Generic.List{PRISM.clsLogEntry})">
            <summary>
            Posts a message to the log
            </summary>
            <param name="messages">The messages to post</param>
        </member>
        <member name="M:PRISM.clsQueLogger.PostEntry(System.String,PRISM.logMsgType,System.Boolean)">
            <summary>
            Writes a message to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="entryType">The ILogger error type</param>
            <param name="localOnly">
            Only used by clsDBLogger
            When true, only post the message to the local log file
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="M:PRISM.clsQueLogger.PostError(System.String,System.Exception,System.Boolean)">
            <summary>
            Posts a message to the log
            </summary>
            <param name="message">The message to post</param>
            <param name="ex">The exception associated with the error</param>
            <param name="localOnly">
            Only used by clsDBLogger
            When true, only post the message to the local log file
            When false, log to the local log file and the database
            </param>
        </member>
        <member name="T:PRISM.Logging.BaseLogger">
            <summary>
            Base class for FileLogger and DatabaseLogger
            </summary>
        </member>
        <member name="T:PRISM.Logging.BaseLogger.LogLevels">
            <summary>
            Log levels
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.LogLevels.NOLOGGING">
            <summary>
            Disables all logging
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.LogLevels.FATAL">
            <summary>
            Fatal error message
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.LogLevels.ERROR">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.LogLevels.WARN">
            <summary>
            Warning message
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.LogLevels.INFO">
            <summary>
            Informational message
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.LogLevels.DEBUG">
            <summary>
            Debug message
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.mLocalLogFileAccessError">
            <summary>
            Set to True if we cannot log to the official log file, we try to log to the local log file, and even that file cannot be written
            </summary>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.mProgramName">
            <summary>
            Program name
            </summary>
            <remarks>Auto-determined using Assembly.GetEntryAssembly</remarks>
        </member>
        <member name="F:PRISM.Logging.BaseLogger.mProgramVersion">
            <summary>
            Program version
            </summary>
            <remarks>Auto-determined using Assembly.GetEntryAssembly</remarks>
        </member>
        <member name="P:PRISM.Logging.BaseLogger.ExecutableVersion">
            <summary>
            Gets the product version associated with this application
            </summary>
        </member>
        <member name="P:PRISM.Logging.BaseLogger.ExecutableName">
            <summary>
            Gets the name of the executable file that started the application
            </summary>
        </member>
        <member name="P:PRISM.Logging.BaseLogger.MostRecentErrorMessage">
            <summary>
            Most recent error message
            </summary>
        </member>
        <member name="P:PRISM.Logging.BaseLogger.TimestampFormat">
            <summary>
            Timestamp format, defaults to year-month-day time (24 hour clock)
            </summary>
        </member>
        <member name="P:PRISM.Logging.BaseLogger.TraceMode">
            <summary>
            When true, show additional debug messages at the console
            </summary>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.AllowLog(PRISM.Logging.BaseLogger.LogLevels,PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Compare message log level to the log threshold level
            </summary>
            <param name="messageLogLevel"></param>
            <param name="logThresholdLevel"></param>
            <returns>True if this message should be logged</returns>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.LogDequeueError(System.Int32,System.Int32)">
            <summary>
            Log a local message regarding a message queue dequeue error
            </summary>
            <param name="failedDequeueEvents"></param>
            <param name="messageQueueCount"></param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.LogLocalMessage(PRISM.Logging.BaseLogger.LogLevels,System.String,System.String)">
            <summary>
            Log a message to the local, generic log file
            </summary>
            <remarks>Used to log errors and warnings when the standard log file (or database) cannot be written to</remarks>
            <param name="logLevel"></param>
            <param name="message"></param>
            <param name="localLogFilePath"></param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.LogLocalMessage(PRISM.Logging.LogMessage,System.String)">
            <summary>
            Log a message to the local, generic log file
            </summary>
            <remarks>Used to log errors and warnings when the standard log file (or database) cannot be written to</remarks>
            <param name="logMessage"></param>
            <param name="localLogFilePath"></param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.LogMessage(PRISM.Logging.BaseLogger.LogLevels,System.String,System.Exception)">
            <summary>
            Log a message (provided logLevel is the log threshold value or lower)
            </summary>
            <param name="logLevel"></param>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.ShowTrace(System.String)">
            <summary>
            Show a trace message at the console if TraceMode is true
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.ShowTraceMessage(System.String,System.Boolean,System.String,System.Int32)">
            <summary>
            Show a trace message at the console, optionally including date
            </summary>
            <remarks>Not dependent on TraceMode</remarks>
            <param name="message">Message to show</param>
            <param name="includeDate">When true, include the date in the prefix; when false, only prefix with time</param>
            <param name="indentChars">Characters to use to indent the message</param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.Debug(System.String,System.Exception)">
            <summary>
            Log a debug message (provided the log threshold is LogLevels.DEBUG)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.Error(System.String,System.Exception)">
            <summary>
            Log an error message (provided the log threshold is LogLevels.ERROR or higher)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.Fatal(System.String,System.Exception)">
            <summary>
            Log a fatal error message (provided the log threshold is LogLevels.FATAL or higher)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.Info(System.String,System.Exception)">
            <summary>
            Log an informational message (provided the log threshold is LogLevels.INFO or higher)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.BaseLogger.Warn(System.String,System.Exception)">
            <summary>
            Log a warning message (provided the log threshold is LogLevels.WARN or higher)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="T:PRISM.Logging.DatabaseLogger">
            <summary>
            Logs messages to a database by calling a stored procedure
            </summary>
        </member>
        <member name="F:PRISM.Logging.DatabaseLogger.LOG_INTERVAL_MILLISECONDS">
            <summary>
            Interval, in milliseconds, between flushing log messages to the database
            </summary>
        </member>
        <member name="F:PRISM.Logging.DatabaseLogger.TIMEOUT_SECONDS">
            <summary>
            Database timeout length, in seconds
            </summary>
        </member>
        <member name="F:PRISM.Logging.DatabaseLogger.mLogThresholdLevel">
            <summary>
            Messages will be sent to the database if they are this value or lower
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.ConnectionString">
            <summary>
            Database connection string
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.EchoMessagesToFileLogger">
            <summary>
            When true, also send any messages to the file logger
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.HasConnectionInfo">
            <summary>
            True if the connection string and stored procedure name are defined
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.InitialCapsLogTypes">
            <summary>
            When true, log type will be changed from all caps to InitialCaps (e.g. INFO to Info)
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.IsDebugEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.DEBUG or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.IsErrorEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.ERROR or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.IsFatalEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.FATAL or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.IsInfoEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.INFO or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.IsWarnEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.WARN or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.LogLevel">
            <summary>
            Get or set the current log threshold level
            </summary>
            <remarks>
            If the LogLevel is DEBUG, all messages are logged
            If the LogLevel is INFO, all messages except DEBUG messages are logged
            If the LogLevel is ERROR, only FATAL and ERROR messages are logged
            </remarks>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.LoggingProcedure">
            <summary>
            Information for the procedure used to store log messages in the database
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.MachineName">
            <summary>
            The module name identifies the logging process
            </summary>
        </member>
        <member name="P:PRISM.Logging.DatabaseLogger.UserName">
            <summary>
            The user name running this program
            </summary>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.ChangeConnectionInfo(System.String,System.String)">
            <summary>
            Update the database connection info
            </summary>
            <remarks>Will append today's date to the base name</remarks>
            <param name="moduleName">Program name to be sent to the PostedBy field when contacting the database</param>
            <param name="connectionString">Database connection string</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.ChangeConnectionInfo(System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update the database connection info
            </summary>
            <remarks>Will append today's date to the base name</remarks>
            <param name="moduleName">Program name to be sent to the PostedBy field when contacting the database</param>
            <param name="connectionString">Database connection string</param>
            <param name="storedProcedure">Stored procedure to call</param>
            <param name="logTypeParamName">LogType parameter name</param>
            <param name="messageParamName">Message parameter name</param>
            <param name="postedByParamName">Log source parameter name</param>
            <param name="logTypeParamSize">LogType parameter size</param>
            <param name="messageParamSize">Message parameter size</param>
            <param name="postedByParamSize">Log source parameter size</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.FlushPendingMessages">
            <summary>
            Immediately write out any queued messages (using the current thread)
            </summary>
            <remarks>
            <para>
            There is no need to call this method if you create an instance of this class
            </para>
            <para>
            On the other hand, if you only call static methods in this class, call this method
            before ending the program to assure that all messages have been logged
            </para>
            </remarks>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.GetDefaultModuleName">
            <summary>
            Construct the string MachineName:UserName
            </summary>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.LogLevelToString(PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Convert log level to a string, optionally changing from all caps to initial caps
            </summary>
            <param name="logLevel"></param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.RemoveConnectionInfo">
            <summary>
            Disable database logging
            </summary>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.SetLogLevel(PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Update the log threshold level
            </summary>
            <param name="logLevel">Log threshold level</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.Debug(System.String,System.Exception)">
            <summary>
            Log a debug message
            (provided the log threshold is LogLevels.DEBUG; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.Error(System.String,System.Exception)">
            <summary>
            Log an error message
            (provided the log threshold is LogLevels.ERROR or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.Fatal(System.String,System.Exception)">
            <summary>
            Log a fatal error message
            (provided the log threshold is LogLevels.FATAL or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.Info(System.String,System.Exception)">
            <summary>
            Log an informational message
            (provided the log threshold is LogLevels.INFO or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.Warn(System.String,System.Exception)">
            <summary>
            Log a warning message
            (provided the log threshold is LogLevels.WARN or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.WriteLog(PRISM.Logging.BaseLogger.LogLevels,System.String,System.Exception)">
            <summary>
            Log a message (regardless of the log threshold level)
            </summary>
            <param name="logLevel"></param>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:PRISM.Logging.DatabaseLogger.WriteLog(PRISM.Logging.LogMessage)">
            <summary>
            Log a message (regardless of the log threshold level)
            </summary>
            <param name="logMessage"></param>
        </member>
        <member name="T:PRISM.Logging.FileLogger">
            <summary>
            Logs messages to a file
            </summary>
            <remarks>
            The filename is date-based, for example DataProcessor_2020-08-02.txt
            If you want year-month-day based names, update your class to inherit ProcessFilesBase or ProcessDirectoriesBase
            </remarks>
        </member>
        <member name="F:PRISM.Logging.FileLogger.DEFAULT_MAX_ROLLED_LOG_FILES">
            <summary>
            Default number of old log files to keep when AppendDateToBaseFileName is false
            </summary>
        </member>
        <member name="F:PRISM.Logging.FileLogger.LOG_INTERVAL_MILLISECONDS">
            <summary>
            Interval, in milliseconds, between flushing log messages to disk
            </summary>
        </member>
        <member name="F:PRISM.Logging.FileLogger.LOG_FILE_DATE_CODE">
            <summary>
            Date format for log file names
            </summary>
            <remarks>
            Prior to January 2022, this was month-day-year based; it is now year-month-day
            Note that abstract classes ProcessFilesBase and ProcessDirectoriesBase create year-month-day log files
            </remarks>
        </member>
        <member name="F:PRISM.Logging.FileLogger.LOG_FILE_EXTENSION">
            <summary>
            Default log file extension
            </summary>
            <remarks>Appended to the log file name if BaseLogFileName does not have an extension</remarks>
        </member>
        <member name="F:PRISM.Logging.FileLogger.OLD_LOG_DIRECTORY_AGE_THRESHOLD_DAYS">
            <summary>
            Directories with old log files (typically named by year) will be zipped this many days after January 1
            </summary>
        </member>
        <member name="F:PRISM.Logging.FileLogger.mFailedDequeueEvents">
            <summary>
            Tracks the number of successive dequeue failures
            </summary>
        </member>
        <member name="F:PRISM.Logging.FileLogger.mNeedToRollLogFiles">
            <summary>
            When true, we need to rename existing log files because
            Only valid if AppendDateToBaseFileName is true
            </summary>
            <remarks>Log files are only renamed if a log message is actually logged</remarks>
        </member>
        <member name="F:PRISM.Logging.FileLogger.mLogThresholdLevel">
            <summary>
            Messages will be written to the log file if they are this value or lower
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.AppendDateToBaseFileName">
            <summary>
            When true, the actual log file name will have today's date appended to it, in the form yyyy-mm-dd.txt
            When false, the actual log file name will be the base name plus .txt (unless the base name already has an extension)
            If a file exists with that name, but was last modified before today, it will be renamed to BaseName.txt.1
            </summary>
            <remarks>
            Other, existing log files will also be renamed, keeping up to MaxRolledLogFiles old log files
            </remarks>
        </member>
        <member name="P:PRISM.Logging.FileLogger.BaseLogFileName">
            <summary>
            Base log file name
            This is updated by ChangeLogFileBaseName or via the constructor
            </summary>
            <remarks>
            If AppendDateToBaseFileName is true, the actual log file name will have today's date appended to it, in the form yyyy-mm-dd.txt
            If AppendDateToBaseFileName is false, the actual log file name will be the base name plus .txt
            (unless the base name already has an extension, then the user-specified extension will be used)
            See also the comments for property AppendDateToBaseFileName
            </remarks>
        </member>
        <member name="P:PRISM.Logging.FileLogger.DefaultLogFileName">
            <summary>
            Default log file name
            </summary>
            <remarks>Used when BaseLogFileName is empty</remarks>
        </member>
        <member name="P:PRISM.Logging.FileLogger.IsDebugEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.DEBUG or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.IsErrorEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.ERROR or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.IsFatalEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.FATAL or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.IsInfoEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.INFO or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.IsWarnEnabled">
            <summary>
            True if info level logging is enabled (LogLevel is LogLevels.WARN or higher)
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.LogFileDate">
            <summary>
            Log file date
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.LogFileDateText">
            <summary>
            Log file date (as a string)
            </summary>
        </member>
        <member name="P:PRISM.Logging.FileLogger.LogFilePath">
            <summary>
            Current log file path
            </summary>
            <remarks>Update using ChangeLogFileBaseName</remarks>
        </member>
        <member name="P:PRISM.Logging.FileLogger.LogLevel">
            <summary>
            Get or set the current log threshold level
            </summary>
            <remarks>
            If the LogLevel is DEBUG, all messages are logged
            If the LogLevel is INFO, all messages except DEBUG messages are logged
            If the LogLevel is ERROR, only FATAL and ERROR messages are logged
            </remarks>
        </member>
        <member name="P:PRISM.Logging.FileLogger.MaxRolledLogFiles">
            <summary>
            Maximum number of old log files to keep
            Ignored if AppendDateToBaseFileName is True
            </summary>
            <remarks>Defaults to 5; minimum value is 1</remarks>
        </member>
        <member name="P:PRISM.Logging.FileLogger.ZipOldLogDirectories">
            <summary>
            When true, ArchiveOldLogFilesNow will also zip subdirectories with old log files
            </summary>
        </member>
        <member name="M:PRISM.Logging.FileLogger.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:PRISM.Logging.FileLogger.#ctor(System.String,System.Boolean,System.Int32)">
            <summary>
            Constructor that takes base log file name and appendDateToBaseName
            </summary>
            <remarks>If baseName is null or empty, the log file name will be named ExecutableName_log.txt</remarks>
            <param name="baseName">Base log file name (or relative path)</param>
            <param name="appendDateToBaseName">
            When true, the actual log file name will have today's date appended to it, in the form yyyy-mm-dd.txt
            When false, the actual log file name will be the base name plus .txt (unless the base name already has an extension)
            </param>
            <param name="maxRolledLogFiles">
            Maximum number of old log files to keep (Ignored if appendDateToBaseName is True)
            </param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.#ctor(System.String,PRISM.Logging.BaseLogger.LogLevels,System.Boolean,System.Int32)">
            <summary>
            Constructor that takes base log file name and log level
            </summary>
            <remarks>If baseName is null or empty, the log file name will be named DefaultLogFileName</remarks>
            <param name="baseName">Base log file name (or relative path)</param>
            <param name="logLevel">Log threshold level</param>
            <param name="appendDateToBaseName">
            When true, the actual log file name will have today's date appended to it, in the form yyyy-mm-dd.txt
            When false, the actual log file name will be the base name plus .txt (unless the base name already has an extension)
            </param>
            <param name="maxRolledLogFiles">
            Maximum number of old log files to keep (Ignored if appendDateToBaseName is True)
            </param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ArchiveOldLogFilesNow">
            <summary>
            Look for log files over 32 days old that can be moved into a subdirectory
            </summary>
            <remarks>
            LogQueuedMessages calls this method every 24 hours
            </remarks>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ArchiveOldLogFilesNow(System.String)">
            <summary>
            Look for log files over 32 days old that can be moved into a subdirectory
            </summary>
            <param name="logFilePath"></param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ArchiveOldLogs(System.IO.DirectoryInfo,System.String,System.String,System.String)">
            <summary>
            Look for log files over 32 days old that can be moved into a subdirectory
            </summary>
            <remarks>
            If logFileMatchSpec is ????-??-?? and logFileExtension is .txt, will find files named *_????-??-??.txt
            </remarks>
            <param name="logDirectory">Path to the directory with log files</param>
            <param name="logFileMatchSpec">Wildcards to use to find date-based log files, for example ????-??-??</param>
            <param name="logFileExtension">Log file extension, for example .txt</param>
            <param name="logFileDateRegEx">
            RegEx pattern for extracting the log file date from the log file name
            The pattern must have named groups Year and Month
            The pattern can optionally have named group Day
            For an example, see constant LOG_FILE_DATE_REGEX
            </param>
            <returns>List of warning messages</returns>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ArchiveOldLogs(System.IO.DirectoryInfo,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Look for log files over 32 days old that can be moved into a subdirectory
            </summary>
            <remarks>
            If logFileMatchSpec is ????-??-?? and logFileExtension is .txt, will find files named *_????-??-??.txt
            </remarks>
            <param name="logDirectory">Path to the directory with log files</param>
            <param name="logFileMatchSpec">Wildcards to use to find date-based log files, for example ????-??-??</param>
            <param name="logFileExtension">Log file extension, for example .txt</param>
            <param name="logFileDateRegEx">
            RegEx pattern for extracting the log file date from the log file name
            The pattern must have named groups Year and Month
            The pattern can optionally have named group Day
            For an example, see constant LOG_FILE_DATE_REGEX
            </param>
            <param name="zipOldDirectories"></param>
            <returns>List of warning messages</returns>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ChangeLogFileBaseName(System.String)">
            <summary>
            Update the log file's base name (or relative path)
            </summary>
            <remarks>
            If AppendDateToBaseFileName is true, will append today's date to the base name
            If baseName is a relative file path (aka is not rooted), the entry assembly's path will be prepended to baseName
            If baseName is null or empty, the log file name will be named DefaultLogFileName
            </remarks>
            <remarks>If baseName is null or empty, the log file name will be named DefaultLogFileName</remarks>
            <param name="baseName">Base log file name (or relative path)</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ChangeLogFileBaseName(System.String,System.Boolean,System.Boolean)">
            <summary>
            Update the log file's base name (or relative path)
            However, if appendDateToBaseName is false, baseName is the full path to the log file
            </summary>
            <remarks>If baseName is null or empty, the log file name will be named DefaultLogFileName</remarks>
            <param name="baseName">Base log file name (or relative path)</param>
            <param name="appendDateToBaseName">
            When true, the actual log file name will have today's date appended to it, in the form yyyy-mm-dd.txt
            When false, the actual log file name will be the base name plus .txt (unless the base name already has an extension)
            </param>
            <param name="relativeToEntryAssembly">
            When true, if baseName is a relative file path (aka is not rooted), the entry assembly's path will be prepended to baseName
            When false, if baseName is a relative file path, the log file will be created in a subdirectory relative to the working directory
            </param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ChangeLogFileName">
            <summary>
            Changes the base log file name
            </summary>
        </member>
        <member name="M:PRISM.Logging.FileLogger.FlushPendingMessages">
            <summary>
            Immediately write out any queued messages (using the current thread)
            </summary>
            <remarks>
            <para>
            There is no need to call this method if you create an instance of this class
            </para>
            <para>
            On the other hand, if you only call static methods in this class, call this method
            before ending the program to assure that all messages have been logged
            </para>
            </remarks>
        </member>
        <member name="M:PRISM.Logging.FileLogger.LogMessagesCallback(System.Object)">
            <summary>
            Callback invoked by the mQueueLogger timer
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ResetLogFileName">
            <summary>
            Reset the base log file name to an empty string and reset the cached log file dates
            </summary>
            <remarks>This method is only intended to be used by unit tests</remarks>
        </member>
        <member name="M:PRISM.Logging.FileLogger.RollLogFiles(System.DateTime,System.String)">
            <summary>
            Rename existing log files if required
            </summary>
            <param name="currentDate">Current date (local time)</param>
            <param name="currentLogFilePath">Current log file name (for today)</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.SetLogLevel(PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Update the log threshold level
            </summary>
            <param name="logLevel">Log threshold level</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ShowStackTraceOnEnter(System.String)">
            <summary>
            Show a stack trace when entering a method
            </summary>
            <param name="callingMethod"></param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.StartLogQueuedMessages">
            <summary>
            Check for queued messages
            If found, try to log them, wrapping then attempt with Monitor.TryEnter and Monitor.Exit
            </summary>
        </member>
        <member name="M:PRISM.Logging.FileLogger.ZipOldLogSubdirectories(System.IO.DirectoryInfo)">
            <summary>
            Zip subdirectories with old log files
            </summary>
            <param name="logDirectory">Path to the directory with log files</param>
            <returns>List of warning messages</returns>
        </member>
        <member name="M:PRISM.Logging.FileLogger.Debug(System.String,System.Exception)">
            <summary>
            Log a debug message
            (provided the log threshold is LogLevels.DEBUG; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.Error(System.String,System.Exception)">
            <summary>
            Log an error message
            (provided the log threshold is LogLevels.ERROR or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.Fatal(System.String,System.Exception)">
            <summary>
            Log a fatal error message
            (provided the log threshold is LogLevels.FATAL or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.Info(System.String,System.Exception)">
            <summary>
            Log an informational message
            (provided the log threshold is LogLevels.INFO or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.Warn(System.String,System.Exception)">
            <summary>
            Log a warning message
            (provided the log threshold is LogLevels.WARN or higher; see this.LogLevel)
            </summary>
            <param name="message">Log message</param>
            <param name="ex">Optional exception; can be null</param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.WriteLog(PRISM.Logging.BaseLogger.LogLevels,System.String,System.Exception)">
            <summary>
            Log a message (regardless of the log threshold level)
            </summary>
            <param name="logLevel">Log level of the message</param>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.WriteLog(PRISM.Logging.LogMessage)">
            <summary>
            Log a message (regardless of the log threshold level)
            </summary>
            <param name="logMessage"></param>
        </member>
        <member name="M:PRISM.Logging.FileLogger.Finalize">
            <summary>
            Class is disposing; write out any queued messages
            </summary>
        </member>
        <member name="T:PRISM.Logging.IEventNotifier">
            <summary>
            Interface for IEventNotifier; primary use is for interfaces whose implementations should inherit from EventNotifier
            </summary>
        </member>
        <member name="E:PRISM.Logging.IEventNotifier.DebugEvent">
            <summary>
            Debug event
            </summary>
        </member>
        <member name="E:PRISM.Logging.IEventNotifier.ErrorEvent">
            <summary>
            Error event
            </summary>
        </member>
        <member name="E:PRISM.Logging.IEventNotifier.ProgressUpdate">
            <summary>
            Progress updated
            </summary>
        </member>
        <member name="E:PRISM.Logging.IEventNotifier.StatusEvent">
            <summary>
            Status event
            </summary>
        </member>
        <member name="E:PRISM.Logging.IEventNotifier.WarningEvent">
            <summary>
            Warning event
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.EmptyLinesBeforeDebugMessages">
            <summary>
            Number of empty lines to write to the console before displaying a debug message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.EmptyLinesBeforeErrorMessages">
            <summary>
            Number of empty lines to write to the console before displaying an error message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.EmptyLinesBeforeStatusMessages">
            <summary>
            Number of empty lines to write to the console before displaying a status message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.EmptyLinesBeforeWarningMessages">
            <summary>
            Number of empty lines to write to the console before displaying a warning message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.SkipConsoleWriteIfNoDebugListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write debug messages to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.SkipConsoleWriteIfNoErrorListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write errors to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.SkipConsoleWriteIfNoProgressListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write progress updates to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.SkipConsoleWriteIfNoStatusListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write status messages to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.SkipConsoleWriteIfNoWarningListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write warnings to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.Logging.IEventNotifier.WriteToConsoleIfNoListener">
            <summary>
            If true, and if an event does not have a listener, display the message at the console
            </summary>
            <remarks>Defaults to true. Silence individual event types using the SkipConsoleWrite properties</remarks>
        </member>
        <member name="T:PRISM.Logging.LogMessage">
            <summary>
            Class for tracking individual messages to log
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.DEFAULT_TIMESTAMP_FORMAT">
            <summary>
            Default timestamp format mode
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.DATE_TIME_FORMAT_MONTH_DAY_YEAR_24H">
            <summary>
            Month/day/year Time (24 hour clock)
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.DATE_TIME_FORMAT_MONTH_DAY_YEAR_12H">
            <summary>
            Month/day/year Time am/pm
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.DATE_TIME_FORMAT_YEAR_MONTH_DAY_24H">
            <summary>
            Year-month-day Time (24 hour clock)
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.DATE_TIME_FORMAT_YEAR_MONTH_DAY_12H">
            <summary>
            Year-month-day Time am/pm
            </summary>
        </member>
        <member name="T:PRISM.Logging.LogMessage.TimestampFormatMode">
            <summary>
            Timestamp format mode
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.TimestampFormatMode.MonthDayYear24hr">
            <summary>
            Month/day/year Time (24 hour clock)
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.TimestampFormatMode.MonthDayYear12hr">
            <summary>
            Month/day/year Time am/pm
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.TimestampFormatMode.YearMonthDay24hr">
            <summary>
            Year-month-day Time (24 hour clock)
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogMessage.TimestampFormatMode.YearMonthDay12hr">
            <summary>
            Year-month-day Time am/pm
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogMessage.LogLevel">
            <summary>
            Log level (aka log message type)
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogMessage.Message">
            <summary>
            Log message
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogMessage.MessageException">
            <summary>
            Exception associated with the message (may be null)
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogMessage.MessageDateUTC">
            <summary>
            Message date (UTC-based time)
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogMessage.MessageDateLocal">
            <summary>
            Message date (Local time)
            </summary>
        </member>
        <member name="M:PRISM.Logging.LogMessage.#ctor(PRISM.Logging.BaseLogger.LogLevels,System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="logLevel"></param>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:PRISM.Logging.LogMessage.GetFormattedMessage(PRISM.Logging.LogMessage.TimestampFormatMode)">
            <summary>
            Get the log message, formatted in the form Date, Message, LogType
            </summary>
            <param name="timestampFormat">Timestamp format mode</param>
            <returns>Formatted message (does not include anything regarding MessageException)</returns>
        </member>
        <member name="M:PRISM.Logging.LogMessage.GetFormattedMessage(System.Boolean,PRISM.Logging.LogMessage.TimestampFormatMode)">
            <summary>
            Get the log message, formatted as Date, Message, LogType
            </summary>
            <param name="useLocalTime">When true, use the local time, otherwise use UTC time</param>
            <param name="timestampFormat">Timestamp format mode</param>
            <returns>Formatted message (does not include anything regarding MessageException)</returns>
        </member>
        <member name="M:PRISM.Logging.LogMessage.ToString">
            <summary>
            The log message and log type, separated by a comma
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.ProcedureName">
            <summary>
            Procedure used to store log messages
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.LogTypeParamName">
            <summary>
            LogType parameter name
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.LogTypeParamSize">
            <summary>
            LogType parameter size
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.MessageParamName">
            <summary>
            Message parameter name
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.MessageParamSize">
            <summary>
            Message parameter size
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.LogSourceParamName">
            <summary>
            Log source parameter name
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogProcedureInfo.LogSourceParamSize">
            <summary>
            Log source parameter size
            </summary>
        </member>
        <member name="M:PRISM.Logging.LogProcedureInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.Logging.LogProcedureInfo.UpdateProcedureInfo(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update the logging procedure info
            </summary>
            <param name="procedureName"></param>
            <param name="logTypeParamName"></param>
            <param name="messageParamName"></param>
            <param name="postedByParamName"></param>
            <param name="logTypeParamSize"></param>
            <param name="messageParamSize"></param>
            <param name="postedByParamSize"></param>
        </member>
        <member name="T:PRISM.Logging.LogTools">
            <summary>
            Class for handling logging via the FileLogger and
            a class derived from DatabaseLogger:
              SqlServerDatabaseLogger,
              ODBCDatabaseLogger, or
              PostgresDatabaseLogger (defined in PRISM-DatabaseUtils, https://www.nuget.org/packages/PRISM-DatabaseUtils/)
            </summary>
            <remarks>
            <para>
            Call method CreateFileLogger to define the log file name
            </para>
            <para>
            Call method CreateDbLogger or SetDbLogger to define the database connection info
            </para>
            <para>
            Log files have date-based names, for example DataProcessor_2020-08-02.txt
            </para>
            </remarks>
            <remarks>
            Warnings and errors are logged to the database if parameter logToDatabase is set to true when the log method is called
            </remarks>
        </member>
        <member name="T:PRISM.Logging.LogTools.LoggerTypes">
            <summary>
            Log types
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogTools.LoggerTypes.LogFile">
            <summary>
            Log to a log file
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogTools.LoggerTypes.LogDb">
            <summary>
            Log to the database and to the log file
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogTools.mFileLogger">
            <summary>
            File Logger
            </summary>
        </member>
        <member name="F:PRISM.Logging.LogTools.mDbLogger">
            <summary>
            Database logger
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogTools.CurrentLogFilePath">
            <summary>
            File path for the current log file used by the FileLogger
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogTools.FileLogDebugEnabled">
            <summary>
            Tells calling program file debug status
            </summary>
            <returns>True if debug level enabled for file logger; false otherwise</returns>
        </member>
        <member name="P:PRISM.Logging.LogTools.OfflineMode">
            <summary>
            When true, never try to log to a database
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogTools.MostRecentErrorMessage">
            <summary>
            Most recent error message
            </summary>
        </member>
        <member name="P:PRISM.Logging.LogTools.WorkDirPath">
            <summary>
            Working directory path
            </summary>
        </member>
        <member name="M:PRISM.Logging.LogTools.ChangeLogFileBaseName(System.String,System.Boolean)">
            <summary>
            Update the log file's base name (or relative path)
            However, if appendDateToBaseName is false, baseName is the full path to the log file
            </summary>
            <remarks>If baseName is null or empty, the log file name will be named DefaultLogFileName</remarks>
            <param name="baseName">Base log file name (or relative path)</param>
            <param name="appendDateToBaseName">
            When true, the actual log file name will have today's date appended to it, in the form yyyy-mm-dd.txt
            When false, the actual log file name will be the base name plus .txt (unless the base name already has an extension)
            </param>
        </member>
        <member name="M:PRISM.Logging.LogTools.CreateFileLogger(System.String,System.Boolean)">
            <summary>
            Configures the file logger
            </summary>
            <param name="logFileNameBase">Base name for log file</param>
            <param name="traceMode">When true, show additional debug messages at the console</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.CreateFileLogger(System.String,PRISM.Logging.BaseLogger.LogLevels,System.Boolean)">
            <summary>
            Configures the file logger
            </summary>
            <param name="logFileNameBase">Base name for log file</param>
            <param name="logLevel">Log threshold level</param>
            <param name="traceMode">When true, show additional debug messages at the console</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.CreateDbLogger(System.String,System.String,System.Boolean)">
            <summary>
            Configures the database logger using a SQL Server style connection string
            </summary>
            <remarks>For PostgreSQL databases, use SetDbLogger</remarks>
            <param name="connectionString">System.Data.SqlClient style connection string</param>
            <param name="moduleName">Module name used by logger</param>
            <param name="traceMode">When true, show additional debug messages at the console</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.CreateDbLogger(System.String,System.String,PRISM.Logging.BaseLogger.LogLevels,System.Boolean)">
            <summary>
            Configures the database logger using a SQL Server style connection string
            </summary>
            <remarks>For PostgreSQL databases, use SetDbLogger</remarks>
            <param name="connectionString">System.Data.SqlClient style connection string</param>
            <param name="moduleName">Module name used by logger</param>
            <param name="logLevel">Log threshold level</param>
            <param name="traceMode">When true, show additional debug messages at the console</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.SetDbLogger(PRISM.Logging.DatabaseLogger,PRISM.Logging.BaseLogger.LogLevels,System.Boolean)">
            <summary>
            Sets the databases logger
            </summary>
            <param name="dbLogger">Instance of DatabaseLogger</param>
            <param name="logLevel"></param>
            <param name="traceMode"></param>
        </member>
        <member name="M:PRISM.Logging.LogTools.ErrorWritingToLog(System.String,System.Exception)">
            <summary>
            Notify the user at console that an error occurred while writing to a log file or posting a log message to the database
            </summary>
            <param name="logMessage"></param>
            <param name="ex"></param>
        </member>
        <member name="M:PRISM.Logging.LogTools.FlushPendingMessages">
            <summary>
            Immediately write out any queued messages (using the current thread)
            </summary>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogDebug(System.String,System.Boolean)">
            <summary>
            Show a status message at the console and optionally include in the log file, tagging it as a debug message
            </summary>
            <remarks>The message is shown in dark gray in the console</remarks>
            <param name="statusMessage">Status message</param>
            <param name="writeToLog">True to write to the log file; false to only display at console</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogDebug(System.String,System.Object[])">
            <summary>
            Show a status message at the console and in the log file, tagging it as a debug message
            </summary>
            <remarks>The message is shown in dark gray in the console</remarks>
            <param name="format">Status message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogError(System.String,System.Exception,System.Boolean)">
            <summary>
            Log an error message and exception
            </summary>
            <remarks>The error is shown in red in the console.  The exception stack trace is shown in cyan</remarks>
            <param name="errorMessage">Error message (do not include ex.message)</param>
            <param name="ex">Exception to log (allowed to be null)</param>
            <param name="logToDatabase">When true, log to the database (and to the file)</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogError(System.String,System.Object[])">
            <summary>
            Log an error message and exception
            </summary>
            <remarks>The error is shown in red in the console.</remarks>
            <param name="format">Error message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogError(System.Exception,System.String,System.Object[])">
            <summary>
            Log an error message and exception
            </summary>
            <remarks>The error is shown in red in the console.  The exception stack trace is shown in cyan</remarks>
            <param name="ex">Exception to log</param>
            <param name="format">Error message format string (do not include ex.message)</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogFatalError(System.String,System.Exception,System.Boolean)">
            <summary>
            Log a fatal error message and exception
            </summary>
            <remarks>The error is shown in red in the console.  The exception stack trace is shown in cyan</remarks>
            <param name="errorMessage">Error message (do not include ex.message)</param>
            <param name="ex">Exception to log (allowed to be null)</param>
            <param name="logToDatabase">When true, log to the database (and to the file)</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogFatalError(System.String,System.Object[])">
            <summary>
            Log a fatal error message and exception
            </summary>
            <remarks>The error is shown in red in the console.</remarks>
            <param name="format">Error message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogFatalError(System.Exception,System.String,System.Object[])">
            <summary>
            Log a fatal error message and exception
            </summary>
            <remarks>The error is shown in red in the console.  The exception stack trace is shown in cyan</remarks>
            <param name="ex">Exception to log</param>
            <param name="format">Error message format string (do not include ex.message)</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogMessage(System.String,System.Boolean,System.Boolean)">
            <summary>
            Show a status message at the console and optionally include in the log file
            </summary>
            <param name="statusMessage">Status message</param>
            <param name="isError">True if this is an error</param>
            <param name="writeToLog">True to write to the log file; false to only display at console</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogMessage(System.String,System.Object[])">
            <summary>
            Show a status message at the console and optionally include in the log file
            </summary>
            <param name="format">Status message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogWarning(System.String,System.Boolean)">
            <summary>
            Display a warning message at the console and write to the log file
            </summary>
            <param name="warningMessage">Warning message</param>
            <param name="logToDatabase">When true, log to the database (and to the file)</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.LogWarning(System.String,System.Object[])">
            <summary>
            Display a warning message at the console and write to the log file
            </summary>
            <param name="format">Warning message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.RemoveDefaultDbLogger">
            <summary>
            Remove the default database logger that was created when the program first started
            </summary>
        </member>
        <member name="M:PRISM.Logging.LogTools.SetFileLogLevel(System.Int32)">
            <summary>
            Sets the file logging log threshold via an integer
            </summary>
            <param name="logLevel">Integer corresponding to log threshold level (1-5, 5 being most verbose)</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.SetFileLogLevel(PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Sets the file logging log threshold via an enum
            </summary>
            <param name="logLevel">LogLevels value defining log threshold level (Debug is most verbose)</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.WriteLog(PRISM.Logging.LogTools.LoggerTypes,PRISM.Logging.BaseLogger.LogLevels,System.String)">
            <summary>
            Write a message to the logging system
            </summary>
            <param name="loggerType">Type of logger to use</param>
            <param name="logLevel">Level of log reporting</param>
            <param name="message">Message to be logged</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.WriteLog(PRISM.Logging.LogTools.LoggerTypes,PRISM.Logging.BaseLogger.LogLevels,System.String,System.Exception)">
            <summary>
            Write a message and exception to the logging system
            </summary>
            <param name="loggerType">Type of logger to use</param>
            <param name="logLevel">Level of log reporting</param>
            <param name="message">Message to be logged</param>
            <param name="ex">Exception to be logged</param>
        </member>
        <member name="M:PRISM.Logging.LogTools.WriteLogWork(PRISM.Logging.LogTools.LoggerTypes,PRISM.Logging.BaseLogger.LogLevels,System.String,System.Exception)">
            <summary>
            Write a message and possibly an exception to the logging system
            </summary>
            <remarks>Log message will not be written if logLevel is LogLevel or higher)</remarks>
            <param name="loggerType">Type of logger to use</param>
            <param name="logLevel">Level of log reporting</param>
            <param name="message">Message to be logged</param>
            <param name="ex">Exception to be logged; null if no exception</param>
        </member>
        <member name="T:PRISM.Logging.LogTools.MessageLoggedEventHandler">
            <summary>
            Delegate for event MessageLogged
            </summary>
        </member>
        <member name="E:PRISM.Logging.LogTools.MessageLogged">
            <summary>
            This event is raised when a message is logged
            </summary>
        </member>
        <member name="T:PRISM.Logging.ODBCDatabaseLogger">
            <summary>
            Logs messages to a database by calling a stored procedure
            Connect using an ODBC driver
            </summary>
            <remarks>Connect using an ODBC driver</remarks>
        </member>
        <member name="F:PRISM.Logging.ODBCDatabaseLogger.mFailedDequeueEvents">
            <summary>
            Tracks the number of successive dequeue failures
            </summary>
        </member>
        <member name="F:PRISM.Logging.ODBCDatabaseLogger.mModuleName">
            <summary>
            Module name
            </summary>
        </member>
        <member name="P:PRISM.Logging.ODBCDatabaseLogger.ModuleName">
            <summary>
            Program name to pass to the PostedBy field when contacting the database
            </summary>
            <remarks>Will be auto-defined in LogQueuedMessages if blank</remarks>
        </member>
        <member name="P:PRISM.Logging.ODBCDatabaseLogger.StoredProcedureName">
            <summary>
            Stored procedure used to store log messages
            </summary>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.#ctor(PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Constructor when the connection info is unknown
            </summary>
            <remarks>
            No database logging will occur until ChangeConnectionInfo is called (to define the connection string and stored procedure)
            </remarks>
            <param name="logLevel">Log threshold level</param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.#ctor(System.String,System.String,PRISM.Logging.BaseLogger.LogLevels,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="moduleName">
            Program name to pass to the postedByParamName field when contacting the database
            (will be auto-defined later if blank)
            </param>
            <param name="connectionString">ODBC-style connection string</param>
            <param name="logLevel">Log threshold level</param>
            <param name="storedProcedure">Stored procedure to call</param>
            <param name="logTypeParamName">LogType parameter name (string representation of logLevel)</param>
            <param name="messageParamName">Message parameter name</param>
            <param name="postedByParamName">Log source parameter name</param>
            <param name="logTypeParamSize">LogType parameter size</param>
            <param name="messageParamSize">Message parameter size</param>
            <param name="postedByParamSize">Log source parameter size</param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.ChangeConnectionInfo(System.String,System.String)">
            <summary>
            Update the database connection info
            </summary>
            <param name="moduleName">
            Program name to pass to the postedByParamName field when contacting the database
            (will be auto-defined later if blank)
            </param>
            <param name="connectionString">ODBC-style connection string</param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.ChangeConnectionInfo(System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update the database connection info
            </summary>
            <param name="moduleName">
            Program name to pass to the postedByParamName field when contacting the database
            (will be auto-defined later if blank)
            </param>
            <param name="connectionString">ODBC-style connection string</param>
            <param name="storedProcedure">Stored procedure used to store the log message</param>
            <param name="logTypeParamName">LogType parameter name</param>
            <param name="messageParamName">Message parameter name</param>
            <param name="postedByParamName">Log source parameter name</param>
            <param name="logTypeParamSize">LogType parameter size</param>
            <param name="messageParamSize">Message parameter size</param>
            <param name="postedByParamSize">Log source parameter size</param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.ConvertSqlServerConnectionStringToODBC(System.String,System.String)">
            <summary>
            Convert a .NET framework SQL Server connection string to an ODBC-style connection string
            </summary>
            <param name="sqlServerConnectionString">SQL Server connection string</param>
            <param name="odbcDriverName">
            Typical values are:
              "SQL Server Native Client 11.0" for SQL Server 2012
              "SQL Server Native Client 10.0" for SQL Server 2008
              "SQL Native Client"             for SQL Server 2005
              "SQL Server"                    for SQL Server 2000
            </param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.FlushPendingMessages">
            <summary>
            Immediately write out any queued messages (using the current thread)
            </summary>
            <remarks>
            <para>
            There is no need to call this method if you create an instance of this class
            </para>
            <para>
            On the other hand, if you only call static methods in this class, call this method
            before ending the program to assure that all messages have been logged
            </para>
            </remarks>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.LogMessagesCallback(System.Object)">
            <summary>
            Callback invoked by the mQueueLogger timer
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.RemoveConnectionInfo">
            <summary>
            Disable database logging
            </summary>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.StartLogQueuedMessages">
            <summary>
            Check for queued messages
            If found, try to log them, wrapping then attempt with Monitor.TryEnter and Monitor.Exit
            </summary>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.WriteLog(PRISM.Logging.LogMessage)">
            <summary>
            Log a message (regardless of this.LogLevel)
            </summary>
            <param name="logMessage"></param>
        </member>
        <member name="M:PRISM.Logging.ODBCDatabaseLogger.Finalize">
            <summary>
            Class is disposing; write out any queued messages
            </summary>
        </member>
        <member name="T:PRISM.Logging.SQLServerDatabaseLogger">
            <summary>
            Logs messages to a SQL Server database by calling a stored procedure
            Connect using System.Data.SqlClient
            </summary>
            <remarks>Can only log to a single database at a time</remarks>
        </member>
        <member name="F:PRISM.Logging.SQLServerDatabaseLogger.mFailedDequeueEvents">
            <summary>
            Tracks the number of successive dequeue failures
            </summary>
        </member>
        <member name="F:PRISM.Logging.SQLServerDatabaseLogger.mModuleName">
            <summary>
            Module name
            </summary>
        </member>
        <member name="P:PRISM.Logging.SQLServerDatabaseLogger.ModuleName">
            <summary>
            Program name to pass to the PostedBy field when contacting the database
            </summary>
            <remarks>Will be auto-defined in LogQueuedMessages if blank</remarks>
        </member>
        <member name="P:PRISM.Logging.SQLServerDatabaseLogger.StoredProcedureName">
            <summary>
            Stored procedure used to store log messages
            </summary>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.#ctor(PRISM.Logging.BaseLogger.LogLevels)">
            <summary>
            Constructor when the connection info is unknown
            </summary>
            <remarks>
            No database logging will occur until ChangeConnectionInfo is called (to define the connection string and stored procedure)
            </remarks>
            <param name="logLevel">Log threshold level</param>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.#ctor(System.String,System.String,PRISM.Logging.BaseLogger.LogLevels,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="moduleName">
            Program name to pass to the postedByParamName field when contacting the database
            (will be auto-defined later if blank)
            </param>
            <param name="connectionString">SQL Server style connection string</param>
            <param name="logLevel">Log threshold level</param>
            <param name="storedProcedure">Stored procedure used to store the log message</param>
            <param name="logTypeParamName">LogType parameter name (string representation of logLevel)</param>
            <param name="messageParamName">Message parameter name</param>
            <param name="postedByParamName">Log source parameter name</param>
            <param name="logTypeParamSize">LogType parameter size</param>
            <param name="messageParamSize">Message parameter size</param>
            <param name="postedByParamSize">Log source parameter size</param>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.ChangeConnectionInfo(System.String,System.String)">
            <summary>
            Update the database connection info
            </summary>
            <param name="moduleName">
            Program name to pass to the postedByParamName field when contacting the database
            (will be auto-defined later if blank)
            </param>
            <param name="connectionString">SQL Server style connection string</param>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.ChangeConnectionInfo(System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update the database connection info
            </summary>
            <param name="moduleName">
            Program name to pass to the postedByParamName field when contacting the database
            (will be auto-defined later if blank)
            </param>
            <param name="connectionString">SQL Server style connection string</param>
            <param name="storedProcedure">Stored procedure used to store the log message</param>
            <param name="logTypeParamName">LogType parameter name</param>
            <param name="messageParamName">Message parameter name</param>
            <param name="postedByParamName">Log source parameter name</param>
            <param name="logTypeParamSize">LogType parameter size</param>
            <param name="messageParamSize">Message parameter size</param>
            <param name="postedByParamSize">Log source parameter size</param>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.FlushPendingMessages">
            <summary>
            Immediately write out any queued messages (using the current thread)
            </summary>
            <remarks>
            <para>
            There is no need to call this method if you create an instance of this class
            </para>
            <para>
            On the other hand, if you only call static methods in this class, call this method
            before ending the program to assure that all messages have been logged
            </para>
            </remarks>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.LogMessagesCallback(System.Object)">
            <summary>
            Callback invoked by the mQueueLogger timer
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.RemoveConnectionInfo">
            <summary>
            Disable database logging
            </summary>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.StartLogQueuedMessages">
            <summary>
            Check for queued messages
            If found, try to log them, wrapping then attempt with Monitor.TryEnter and Monitor.Exit
            </summary>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.WriteLog(PRISM.Logging.LogMessage)">
            <summary>
            Log a message (regardless of this.LogLevel)
            </summary>
            <param name="logMessage"></param>
        </member>
        <member name="M:PRISM.Logging.SQLServerDatabaseLogger.Finalize">
            <summary>
            Class is disposing; write out any queued messages
            </summary>
        </member>
        <member name="T:PRISM.EventNotifier">
            <summary>
            This class implements various status events, including status, debug, error, and warning
            </summary>
        </member>
        <member name="E:PRISM.EventNotifier.DebugEvent">
            <summary>
            Debug event
            </summary>
        </member>
        <member name="T:PRISM.EventNotifier.DebugEventEventHandler">
            <summary>
            Debug event
            </summary>
            <param name="message">Debug message</param>
        </member>
        <member name="E:PRISM.EventNotifier.ErrorEvent">
            <summary>
            Error event
            </summary>
        </member>
        <member name="T:PRISM.EventNotifier.ErrorEventEventHandler">
            <summary>
            Error event
            </summary>
            <param name="message">Error message</param>
            <param name="ex">Exception</param>
        </member>
        <member name="E:PRISM.EventNotifier.ProgressUpdate">
            <summary>
            Progress updated
            </summary>
        </member>
        <member name="T:PRISM.EventNotifier.ProgressUpdateEventHandler">
            <summary>
            Progress updated
            </summary>
            <param name="progressMessage"></param>
            <param name="percentComplete">Value between 0 and 100</param>
        </member>
        <member name="E:PRISM.EventNotifier.StatusEvent">
            <summary>
            Status event
            </summary>
        </member>
        <member name="T:PRISM.EventNotifier.StatusEventEventHandler">
            <summary>
            Status event
            </summary>
            <param name="message">Status message</param>
        </member>
        <member name="E:PRISM.EventNotifier.WarningEvent">
            <summary>
            Warning event
            </summary>
        </member>
        <member name="T:PRISM.EventNotifier.WarningEventEventHandler">
            <summary>
            Warning event
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="P:PRISM.EventNotifier.EmptyLinesBeforeDebugMessages">
            <summary>
            Number of empty lines to write to the console before displaying a debug message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.EmptyLinesBeforeErrorMessages">
            <summary>
            Number of empty lines to write to the console before displaying an error message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.EmptyLinesBeforeStatusMessages">
            <summary>
            Number of empty lines to write to the console before displaying a status message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.EmptyLinesBeforeWarningMessages">
            <summary>
            Number of empty lines to write to the console before displaying a warning message
            This is only applicable if WriteToConsoleIfNoListener is true and the event has no listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.SkipConsoleWriteIfNoDebugListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write debug messages to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.SkipConsoleWriteIfNoErrorListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write errors to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.SkipConsoleWriteIfNoProgressListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write progress updates to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.SkipConsoleWriteIfNoStatusListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write status messages to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.SkipConsoleWriteIfNoWarningListener">
            <summary>
            If WriteToConsoleIfNoListener is true, optionally set this to true to not write warnings to the console if no listener
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.WriteToConsoleIfNoListener">
            <summary>
            If true, and if an event does not have a listener, display the message at the console
            </summary>
            <remarks>Defaults to true. Silence individual event types using the SkipConsoleWrite properties</remarks>
        </member>
        <member name="P:PRISM.EventNotifier.HasEventListenerDebug">
            <summary>
            True if the Debug event has any listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.HasEventListenerError">
            <summary>
            True if the Error event has any listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.HasEventListenerProgressUpdate">
            <summary>
            True if the ProgressUpdate event has any listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.HasEventListenerStatusEvent">
            <summary>
            True if the StatusEvent event has any listeners
            </summary>
        </member>
        <member name="P:PRISM.EventNotifier.HasEventListenerWarningEvent">
            <summary>
            True if the WarningEvent event has any listeners
            </summary>
        </member>
        <member name="M:PRISM.EventNotifier.OnDebugEvent(System.String)">
            <summary>
            Report a debug message
            </summary>
            <param name="message">Debug message</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnDebugEvent(System.String,System.Object[])">
            <summary>
            Report a debug message
            </summary>
            <param name="format">Debug message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnErrorEvent(System.String)">
            <summary>
            Report an error
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnErrorEvent(System.String,System.Object[])">
            <summary>
            Report an error
            </summary>
            <param name="format">Error message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnErrorEvent(System.String,System.Exception)">
            <summary>
            Report an error
            </summary>
            <param name="message">Error message</param>
            <param name="ex">Exception (allowed to be null)</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnErrorEvent(System.Exception,System.String,System.Object[])">
            <summary>
            Report an error
            </summary>
            <param name="ex">Exception</param>
            <param name="format">Error message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnProgressUpdate(System.String,System.Single)">
            <summary>
            Progress update
            </summary>
            <param name="progressMessage">Progress message</param>
            <param name="percentComplete">Value between 0 and 100</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnProgressUpdate(System.Single,System.String,System.Object[])">
            <summary>
            Progress update
            </summary>
            <param name="percentComplete">Value between 0 and 100</param>
            <param name="format">Progress message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnStatusEvent(System.String)">
            <summary>
            Report a status message
            </summary>
            <param name="message">Status message</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnStatusEvent(System.String,System.Object[])">
            <summary>
            Report a status message
            </summary>
            <param name="format">Status message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnWarningEvent(System.String)">
            <summary>
            Report a warning
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="M:PRISM.EventNotifier.OnWarningEvent(System.String,System.Object[])">
            <summary>
            Report a warning
            </summary>
            <param name="format">Warning message format string</param>
            <param name="args">string format arguments</param>
        </member>
        <member name="M:PRISM.EventNotifier.RegisterEvents(PRISM.EventNotifier)">
            <summary>
            Use this method to chain events between classes
            </summary>
            <param name="sourceClass"></param>
        </member>
        <member name="M:PRISM.EventNotifier.RegisterEvents(PRISM.Logging.IEventNotifier)">
            <summary>
            Use this method to chain events between classes
            </summary>
            <param name="sourceClass"></param>
        </member>
        <member name="T:PRISM.ConsoleMsgUtils">
            <summary>
            This class includes methods to be used when displaying messages at the console while monitoring a class that inherits EventNotifier
            </summary>
        </member>
        <member name="P:PRISM.ConsoleMsgUtils.DebugFontColor">
            <summary>
            Debug message font color
            </summary>
        </member>
        <member name="P:PRISM.ConsoleMsgUtils.ErrorFontColor">
            <summary>
            Error message font color
            </summary>
        </member>
        <member name="P:PRISM.ConsoleMsgUtils.StackTraceFontColor">
            <summary>
            Stack trace font color
            </summary>
        </member>
        <member name="P:PRISM.ConsoleMsgUtils.WarningFontColor">
            <summary>
            Warning message font color
            </summary>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ConsoleWriteEmptyLines(System.Int32)">
            <summary>
            Call Console.WriteLine() the specified number of times
            </summary>
            <param name="emptyLineCount"></param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowError(System.String)">
            <summary>
            Display an error message at the console with color ErrorFontColor (defaults to red)
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowError(System.String,System.Object[])">
            <summary>
            Display an error message at the console with color ErrorFontColor (defaults to red)
            </summary>
            <param name="format">Message format string</param>
            <param name="args">Arguments to use with formatString</param>
            <returns>Error message</returns>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowError(System.Exception,System.String,System.Object[])">
            <summary>
            Display an error message at the console with color ErrorFontColor (defaults to red)
            If an exception is included, the stack trace is shown using StackTraceFontColor
            </summary>
            <param name="ex">Exception (can be null)</param>
            <param name="format">Message format string (do not include ex.Message)</param>
            <param name="args">Arguments to use with formatString</param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowError(System.String,System.Exception,System.Boolean)">
            <summary>
            Display an error message at the console with color ErrorFontColor (defaults to red)
            If an exception is included, the stack trace is shown using StackTraceFontColor
            </summary>
            <param name="message">Error message (do not include ex.Message)</param>
            <param name="ex">Exception (can be null)</param>
            <param name="writeToErrorStream">When true, also send the error to the standard error stream</param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowErrorCustom(System.String,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Display an error message at the console with color ErrorFontColor (defaults to red)
            </summary>
            <param name="message">Error message</param>
            <param name="includeSeparator">When true, add a separator line before and after the error</param>
            <param name="writeToErrorStream">When true, also send the error to the standard error stream</param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
            <returns>Error message, with the exception message appended, provided ex is not null and provided message does not end with ex.Message</returns>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowErrorCustom(System.String,System.Exception,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Display an error message at the console with color ErrorFontColor (defaults to red)
            If an exception is included, the stack trace is shown using StackTraceFontColor
            </summary>
            <param name="message">Error message (do not include ex.Message)</param>
            <param name="ex">Exception (can be null)</param>
            <param name="includeSeparator">When true, add a separator line before and after the error</param>
            <param name="writeToErrorStream">When true, also send the error to the standard error stream</param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
            <returns>Error message, with the exception message appended, provided ex is not null and provided message does not end with ex.Message</returns>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowErrors(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String,System.Int32)">
            <summary>
            Display a set of error messages at the console with color ErrorFontColor (defaults to Red)
            </summary>
            <param name="title">Title text to be shown before the errors; can be null or blank</param>
            <param name="errorMessages">Error messages to show</param>
            <param name="writeToErrorStream">When true, also send the error to the standard error stream</param>
            <param name="indentChars">Characters to add before each error message; defaults to 3 spaces</param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
            <returns>The first error message</returns>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowDebug(System.String)">
            <summary>
            Display a debug message at the console with color DebugFontColor (defaults to dark gray)
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowDebug(System.String,System.Object[])">
            <summary>
            Display a debug message at the console with color DebugFontColor (defaults to dark gray)
            </summary>
            <param name="format">Message format string</param>
            <param name="args">Arguments to use with formatString</param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowDebugCustom(System.String,System.String,System.Int32)">
            <summary>
            Display a debug message at the console with color DebugFontColor (defaults to dark gray)
            </summary>
            <param name="message">Debug message</param>
            <param name="indentChars">Characters to use to indent the message</param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowWarning(System.String)">
            <summary>
            Display a warning message at the console with color WarningFontColor (defaults to yellow)
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowWarning(System.String,System.Object[])">
            <summary>
            Display a warning message at the console with color WarningFontColor (defaults to yellow)
            </summary>
            <param name="format">Message format string</param>
            <param name="args">Arguments to use with formatString</param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.ShowWarningCustom(System.String,System.Int32)">
            <summary>
            Display a warning message at the console with color WarningFontColor (defaults to yellow)
            </summary>
            <param name="message">Warning message</param>
            <param name="emptyLinesBeforeMessage">Number of empty lines to display before showing the message</param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.SleepSeconds(System.Double)">
            <summary>
            Sleep for the specified number of seconds
            </summary>
            <remarks>Sleeps for 10 second chunks until waitTimeSeconds has elapsed</remarks>
            <param name="waitTimeSeconds"></param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.WrapParagraph(System.String,System.Int32)">
            <summary>
            Wraps the words in textToWrap to the set width (where possible)
            </summary>
            <remarks>Use the 'alert' character ('\a') to create a non-breaking space</remarks>
            <param name="textToWrap">Text to wrap</param>
            <param name="wrapWidth">Max length per line</param>
            <returns>Wrapped paragraph</returns>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.WrapParagraphAsList(System.String,System.Int32)">
            <summary>
            Wraps the words in textToWrap to the set width (where possible)
            </summary>
            <remarks>Use the 'alert' character ('\a') to create a non-breaking space</remarks>
            <param name="textToWrap">Text to wrap</param>
            <param name="wrapWidth">Max length per line</param>
            <returns>Wrapped paragraph as a list of strings</returns>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.WriteToErrorStream(System.String)">
            <summary>
            Write a message to the error stream
            </summary>
            <param name="errorMessage"></param>
        </member>
        <member name="M:PRISM.ConsoleMsgUtils.PauseAtConsole(System.Int32,System.Int32)">
            <summary>
            Pause the program for the specified number of milliseconds, displaying a period at a set interval while paused
            </summary>
            <param name="millisecondsToPause">Milliseconds to pause; default 5 seconds</param>
            <param name="millisecondsBetweenDots">Seconds between each period; default 1 second</param>
        </member>
        <member name="T:PRISM.StackTraceFormatter">
            <summary>
            This class produces an easier-to read stack trace for an exception
            See the descriptions for methods <see cref="M:PRISM.StackTraceFormatter.GetExceptionStackTrace(System.Exception,System.Boolean)"/> and
            <see cref="M:PRISM.StackTraceFormatter.GetExceptionStackTraceMultiLine(System.Exception,System.Boolean,System.Boolean)"/> for example text
            </summary>
        </member>
        <member name="F:PRISM.StackTraceFormatter.STACK_TRACE_TITLE">
            <summary>
            Stack trace label string
            </summary>
        </member>
        <member name="F:PRISM.StackTraceFormatter.STACK_CHAIN_SEPARATOR">
            <summary>
            String interpolated between parts of the stack trace
            </summary>
        </member>
        <member name="F:PRISM.StackTraceFormatter.FINAL_FILE_PREFIX">
            <summary>
            Prefix added before the final file is listed in the stack trace
            </summary>
        </member>
        <member name="M:PRISM.StackTraceFormatter.GetCurrentStackTrace">
            <summary>
            Get a string listing the methods leading to the calling method
            </summary>
            <returns>
            String of the form:
            Stack trace: TestApp.exe.InnerMethod-:-TestApp.exe.TestMethod-:-TestApp.exe.Main
            </returns>
        </member>
        <member name="M:PRISM.StackTraceFormatter.GetCurrentStackTraceMultiLine">
            <summary>
            Get a multiline string listing the methods leading to the calling method
            </summary>
            <returns>
            String of the form:
            Stack trace:
                TestApp.exe: Bool InnerMethod(string, int out)
                TestApp.exe: Void TestMethod()
                TestApp.exe: Int32 Main()
            </returns>
        </member>
        <member name="M:PRISM.StackTraceFormatter.GetExceptionStackTrace(System.Exception,System.Boolean)">
            <summary>
            Parses the StackTrace text of the given exception to return a compact description of the current stack
            </summary>
            <remarks>Useful for removing the full file paths included in the default stack trace</remarks>
            <param name="ex">Exception</param>
            <param name="includeInnerExceptionMessages">When true, also append details of any inner exceptions</param>
            <returns>
            String of the form:
            Stack trace: clsCodeTest.Test-:-clsCodeTest.TestException-:-clsCodeTest.InnerTestException in clsCodeTest.vb:line 86
            </returns>
        </member>
        <member name="M:PRISM.StackTraceFormatter.GetExceptionStackTraceMultiLine(System.Exception,System.Boolean,System.Boolean)">
            <summary>
            Parses the StackTrace text of the given exception to return a cleaned up description of the current stack,
            with one line for each method in the call tree
            </summary>
            <remarks>Useful for removing the full file paths included in the default stack trace</remarks>
            <param name="ex">Exception</param>
            <param name="includeInnerExceptionMessages">When true, also append details of any inner exceptions</param>
            <param name="includeMethodParams">When true, also include the parameters of each method</param>
            <returns>
            Stack trace:
              clsCodeTest.Test
              clsCodeTest.TestException
              clsCodeTest.InnerTestException
               in clsCodeTest.vb:line 86
            </returns>
        </member>
        <member name="M:PRISM.StackTraceFormatter.GetExceptionStackTraceData(System.Exception,System.Boolean)">
            <summary>
            Parses the StackTrace text of the given exception to return a cleaned up description of the current stack
            </summary>
            <param name="ex">Exception</param>
            <param name="includeMethodParams">When true, also include the parameters of each method</param>
            <returns>
            List of method names; for example:
              clsCodeTest.Test
              clsCodeTest.TestException
              clsCodeTest.InnerTestException
               in clsCodeTest.vb:line 86
            </returns>
        </member>
        <member name="M:PRISM.StackTraceFormatter.GetExceptionStackTraceData(System.String,System.Boolean)">
            <summary>
            Parses the given StackTrace text to return a cleaned up description of the current stack
            </summary>
            <param name="stackTraceText">Exception.StackTrace data</param>
            <param name="includeMethodParams">When true, also include the parameters of each method</param>
            <returns>
            List of method names; for example:
              clsCodeTest.Test
              clsCodeTest.TestException
              clsCodeTest.InnerTestException
               in clsCodeTest.vb:line 86
            </returns>
        </member>
        <member name="T:PRISM.StringUtilities">
            <summary>
            Utilities for advanced output formatting of doubles
            </summary>
        </member>
        <member name="F:PRISM.StringUtilities.mFormatStrings">
            <summary>
            Dictionary that tracks the format string used for each digitsOfPrecision value
            </summary>
            <remarks>
            Keys are the number of digits of precision
            Values are strings like "0.0", "0.0#", "0.0##", etc.
            </remarks>
        </member>
        <member name="F:PRISM.StringUtilities.mFormatStringsScientific">
            <summary>
            Dictionary that tracks the format string used for each digitsOfPrecision value displayed with scientific notation
            </summary>
            <remarks>
            Keys are the number of digits of precision and
              "false" if the format string is of the form 0.00E+00 or
              "true"  if the format string is of the form 0.00E+000
            Values are strings like "0.0E+00", "0.0#E+00", "0.0##E+00", "0.0#E+000", or "0.0##E+000"
            </remarks>
        </member>
        <member name="M:PRISM.StringUtilities.GetFormatString(System.Int32)">
            <summary>
            Get the format string for the given number of digits after the decimal
            </summary>
            <param name="digitsAfterDecimal"></param>
            <returns>Strings like "0.0", "0.0#", "0.0##"</returns>
        </member>
        <member name="M:PRISM.StringUtilities.GetFormatStringScientific(System.Double,System.Int32)">
            <summary>
            Get the format string for the given number of digits after the decimal
            </summary>
            <param name="value">Value being formatted</param>
            <param name="digitsAfterDecimal"></param>
            <returns>Strings like "0.0E+00", "0.0#E+00", "0.0##E+00", "0.0#E+000", or "0.0##E+000"</returns>
        </member>
        <member name="M:PRISM.StringUtilities.ValueToString(System.Double)">
            <summary>
            Convert value to a string with 5 total digits of precision
            </summary>
            <remarks>Numbers larger than 1000000 or smaller than 0.000001 will be in scientific notation</remarks>
            <param name="value">Number to convert to text</param>
            <returns>Number as text</returns>
        </member>
        <member name="M:PRISM.StringUtilities.ValueToString(System.Double,System.Byte)">
            <summary>
            Convert value to a string with the specified total digits of precision
            </summary>
            <remarks>Numbers larger than 1000000 or smaller than 0.000001 will be in scientific notation</remarks>
            <param name="value">Number to convert to text</param>
            <param name="digitsOfPrecision">Total digits of precision (before and after the decimal point)</param>
            <returns>Number as text</returns>
        </member>
        <member name="M:PRISM.StringUtilities.ValueToString(System.Double,System.Byte,System.Double)">
            <summary>
            Convert value to a string with the specified total digits of precision and customized scientific notation threshold
            </summary>
            <remarks>
            This method differs from DblToString in that here digitsOfPrecision is the total digits while DblToString focuses on the number of digits after the decimal point
            </remarks>
            <param name="value">Number to convert to text</param>
            <param name="digitsOfPrecision">Total digits of precision (before and after the decimal point)</param>
            <param name="scientificNotationThreshold">
            Values larger than this threshold (positive or negative) will be converted to scientific notation
            Also, values less than "1 / scientificNotationThreshold" will be converted to scientific notation
            Thus, if this threshold is 1000000, numbers larger than 1000000 or smaller than 0.000001 will be in scientific notation
            </param>
            <returns>Number as text</returns>
        </member>
        <member name="M:PRISM.StringUtilities.DblToString(System.Double,System.Byte,System.Double)">
            <summary>
            Format the value to a string with a fixed number of decimal points
            </summary>
            <remarks>If digitsOfPrecision is 0, will round the number to the nearest integer</remarks>
            <param name="value">Value to format</param>
            <param name="digitsAfterDecimal">Digits to show after the decimal place (0 or higher)</param>
            <param name="thresholdScientific">Numbers below this level will be displayed using Scientific notation</param>
            <returns>String representation of the value</returns>
        </member>
        <member name="M:PRISM.StringUtilities.DblToString(System.Double,System.Byte,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Format the value to a string with a fixed number of decimal points
            </summary>
            <remarks>If digitsOfPrecision is 0, will round the number to the nearest integer</remarks>
            <param name="value">Value to format</param>
            <param name="digitsAfterDecimal">Digits to show after the decimal place (0 or higher)</param>
            <param name="limitDecimalsForLargeValues">When true, will limit the number of decimal points shown for values over 1</param>
            <param name="thresholdScientific">Numbers below this level will be displayed using Scientific notation</param>
            <param name="invariantCulture">
            When true (default) numbers will always use a period for the decimal point.
            When false, the decimal point symbol will depend on the current system's culture settings.
            </param>
            <returns>String representation of the value</returns>
        </member>
        <member name="M:PRISM.StringUtilities.DblToStringScientific(System.Double,System.Byte,System.Boolean)">
            <summary>
            Format the value to a string using scientific notation
            </summary>
            <remarks>If digitsOfPrecision is 0, will round the number to the nearest integer</remarks>
            <param name="value">Value to format</param>
            <param name="digitsAfterDecimal">Digits to show after the decimal place (0 or higher)</param>
            <param name="invariantCulture">
            When true (default) numbers will always use a period for the decimal point.
            When false, the decimal point symbol will depend on the current system's culture settings.
            </param>
            <returns>String representation of the value</returns>
        </member>
        <member name="T:PRISM.ParallelPreprocessing">
            <summary>
            Static class to contain an extension method for limited parallel processing of an IEnumerable and the class containing all of the implementation details
            </summary>
        </member>
        <member name="M:PRISM.ParallelPreprocessing.ParallelPreprocess``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Int32,System.Int32,System.Double,System.Threading.CancellationToken)">
            <summary>
            Performs pre-processing using parallelization. Up to <paramref name="maxThreads"/> threads will be used to process data prior to it being requested by (and simultaneous with) the enumerable consumer. Backed by a producer-consumer queue pattern
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="sourceEnum">source enumerable; preferably something like a list of file that need to be loaded</param>
            <param name="processFunction">Method to transform from <paramref name="sourceEnum"/> to return type; should involve heavy processing (if x => x, you may see a performance penalty)</param>
            <param name="maxThreads">Max number of <paramref name="sourceEnum"/> items to process simultaneously</param>
            <param name="maxPreprocessed">Max number of items to allow being preprocessed or completed-but-not-consumed at any time; defaults to <paramref name="maxThreads"/></param>
            <param name="checkIntervalSeconds">How often to check for completion of the preprocessing</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>IEnumerable of items that have been processed via <paramref name="processFunction"/></returns>
        </member>
        <member name="T:PRISM.ParallelPreprocessing.ParallelPreprocessor`2">
            <summary>
            Implementation details for the extension method; implements a producer-consumer pattern with 1 consumer and x producers
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="F:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.buffer">
            <summary>
            Target and source collection for the producer-consumer pattern; backed by a queue
            </summary>
        </member>
        <member name="F:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.preprocessedLimiter">
            <summary>
            Semaphore to limit the number of items that are being/have been preprocessed. Incremented by the producer(s), decremented by the consumer
            </summary>
        </member>
        <member name="F:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.producerThreads">
            <summary>
            List of thread to monitor the producers and determine when they are done, to properly mark the target block as completed
            </summary>
        </member>
        <member name="F:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.threadsDone">
            <summary>
            Count of threads that have exited
            </summary>
        </member>
        <member name="F:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.cancelToken">
            <summary>
            Cancellation token to support early cancellation
            </summary>
        </member>
        <member name="M:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.ConsumeAll">
            <summary>
            Return a processed item one at a time, as they are requested and become available, until done
            </summary>
        </member>
        <member name="M:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.Start(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Int32,System.Double)">
            <summary>
            Setup for and start the producers
            </summary>
            <param name="sourceEnum"></param>
            <param name="processFunction"></param>
            <param name="numThreads"></param>
            <param name="checkIntervalSeconds">How often to check for completion of the preprocessing</param>
        </member>
        <member name="F:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.threadMonitor">
            <summary>
            Timer used to monitor the producers
            </summary>
        </member>
        <member name="M:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.ThreadMonitorCheck(System.Object)">
            <summary>
            Timer callback method: check on the producer threads, if they are no longer alive, then mark the target block as complete
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.Producer(System.Collections.Generic.IEnumerator{`0},System.Func{`0,`1},System.Object,System.Int32)">
            <summary>
            Producer method: process the source enumerable in parallel, with limits and checks
            </summary>
            <param name="sourceEnumerator"></param>
            <param name="processFunction"></param>
            <param name="accessLock"></param>
            <param name="threadId">A 'threadID' for debugging purposes</param>
        </member>
        <member name="M:PRISM.ParallelPreprocessing.ParallelPreprocessor`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Int32,System.Int32,System.Double,System.Threading.CancellationToken)">
            <summary>
            Performs pre-processing using parallelization. Up to <paramref name="maxThreads"/> threads will be used to process data prior to it being requested by (and simultaneous with) the enumerable consumer
            </summary>
            <param name="source">source enumerable; preferably something like a list of file that need to be loaded</param>
            <param name="processFunction">Method to transform from <paramref name="source"/> to return type; should involve heavy processing (if x => x, you may see a performance penalty)</param>
            <param name="maxThreads">Max number of <paramref name="source"/> items to process simultaneously</param>
            <param name="maxPreprocessed">Max number of items to allow being preprocessed or completed-but-not-consumed at any time; defaults to <paramref name="maxThreads"/></param>
            <param name="checkIntervalSeconds">How often to check for completion of the preprocessing</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>IEnumerable of items that have been processed via <paramref name="processFunction"/></returns>
        </member>
        <member name="T:PRISM.ProgRunner">
            <summary>
            This class runs a single program as an external process and monitors it with an internal thread
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.DEFAULT_MONITOR_INTERVAL_MSEC">
            <summary>
            Default monitoring interval, in milliseconds
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.MINIMUM_MONITOR_INTERVAL_MSEC">
            <summary>
            Minimum monitoring interval, in milliseconds
            </summary>
        </member>
        <member name="T:PRISM.ProgRunner.States">
            <summary>
            ProgRunner states
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.States.NotMonitoring">
            <summary>
            Not Monitoring
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.States.Monitoring">
            <summary>
            Monitoring
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.States.Waiting">
            <summary>
            Waiting
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.States.CleaningUp">
            <summary>
            Cleaning up
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.States.Initializing">
            <summary>
            Initializing
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.States.StartingProcess">
            <summary>
            Starting the process
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mLogger">
            <summary>
            Log class
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mExceptionLogger">
            <summary>
            Interface used for logging exceptions
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mEventLogger">
            <summary>
            Interface used for logging errors and health related messages
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mProcess">
            <summary>
            Used to start and monitor the external program
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mCancellationToken">
            <summary>
            Thread cancellation token
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mDoCleanup">
            <summary>
            Flag that tells internal thread to quit monitoring external program and exit
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mMonitorInterval">
            <summary>
            The interval, in milliseconds, for monitoring the thread to wake up and check mDoCleanup
            </summary>
            <remarks>Default is 5000 msec</remarks>
        </member>
        <member name="F:PRISM.ProgRunner.mExitCode">
            <summary>
            Exit code returned by completed process
            </summary>
            <remarks>Initially set to -123454321</remarks>
        </member>
        <member name="F:PRISM.ProgRunner.mCachedConsoleOutput">
            <summary>
            Caches the text written to the Console by the external program
            </summary>
        </member>
        <member name="F:PRISM.ProgRunner.mCachedConsoleError">
            <summary>
            Caches the text written to the Error buffer by the external program
            </summary>
        </member>
        <member name="E:PRISM.ProgRunner.ProgChanged">
            <summary>
            This event is raised at regular intervals while monitoring the program
            </summary>
            <remarks>Raised every mMonitorInterval milliseconds</remarks>
        </member>
        <member name="T:PRISM.ProgRunner.ProgChangedEventHandler">
            <summary>
            Progress changed event delegate
            </summary>
            <param name="obj"></param>
        </member>
        <member name="E:PRISM.ProgRunner.ConsoleOutputEvent">
            <summary>
            This event is raised when new text is written to the console
            </summary>
        </member>
        <member name="T:PRISM.ProgRunner.ConsoleOutputEventEventHandler">
            <summary>
            Console output event delegate
            </summary>
            <param name="message"></param>
        </member>
        <member name="E:PRISM.ProgRunner.ConsoleErrorEvent">
            <summary>
            This event is raised when the external program writes text to the console's error stream
            </summary>
        </member>
        <member name="T:PRISM.ProgRunner.ConsoleErrorEventEventHandler">
            <summary>
            Console error event delegate
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:PRISM.ProgRunner.Arguments">
            <summary>
            Arguments supplied to external program when it is run
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.CachedConsoleOutput">
            <summary>
            Text written to the Console by the external program (including carriage returns)
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.CachedConsoleError">
            <summary>
            Any text written to the Error buffer by the external program
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.CacheStandardOutput">
            <summary>
            When true then will cache the text the external program writes to the console
            Can retrieve using the CachedConsoleOutput ReadOnly property
            Will also fire event ConsoleOutputEvent as new text is written to the console
            </summary>
            <remarks>If this is true, no window will be shown, even if CreateNoWindow=False</remarks>
        </member>
        <member name="P:PRISM.ProgRunner.ConsoleOutputFileIncludesCommandLine">
            <summary>
            When true, the program name and command line arguments will be added to the top of the console output file
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.ConsoleOutputFilePath">
            <summary>
            File path to which the console output will be written if WriteConsoleOutputToFile is true
            If blank, the file path will be auto-defined to use the WorkDir when program execution starts
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.CreateNoWindow">
            <summary>
            Determine if window should be displayed
            Will be forced to True if CacheStandardOutput = True
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.EchoOutputToConsole">
            <summary>
            When true, echoes, in real time, text written to the Console by the external program
            Ignored if CreateNoWindow = False
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.ExitCode">
            <summary>
            Exit code when process completes
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.MonitoringInterval">
            <summary>
            How often (milliseconds) internal monitoring thread checks status of external program
            </summary>
            <remarks>Minimum allowed value is 100 milliseconds</remarks>
        </member>
        <member name="P:PRISM.ProgRunner.Name">
            <summary>
            Name of this program runner
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.NotifyOnEvent">
            <summary>
            When true, raises event ProgChanged
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.NotifyOnException">
            <summary>
            When true, and if mLogger or mExceptionLogger is defined, re-throws the exception
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.PID">
            <summary>
            Process id of the currently running external program's process
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.Program">
            <summary>
            External program that the program runner will execute
            This is the full path to the program file
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.Repeat">
            <summary>
            Whether the program runner will restart the external program after it exits
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.RepeatHoldOffTime">
            <summary>
            Time (in seconds) that the program runner waits to restart the external program after it exits
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.State">
            <summary>
            Current state of the program runner (as number)
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.StateName">
            <summary>
            Current state of the program runner (as descriptive name)
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.WindowStyle">
            <summary>
            Window style to use when CreateNoWindow is False
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.WorkDir">
            <summary>
            Working directory for process execution
            Not necessarily the same as the directory that contains the program we're running
            </summary>
        </member>
        <member name="P:PRISM.ProgRunner.WriteConsoleOutputToFile">
            <summary>
            When true then will write the standard output to a file in real-time
            Will also fire event ConsoleOutputEvent as new text is written to the console
            Define the path to the file using property ConsoleOutputFilePath; if not defined, the file will be created in the WorkDir
            </summary>
            <remarks>If this is true, no window will be shown, even if CreateNoWindow=False</remarks>
        </member>
        <member name="M:PRISM.ProgRunner.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.ClearCachedConsoleOutput">
            <summary>
            Clears any console output text that is currently cached
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.ClearCachedConsoleError">
            <summary>
            Clears any console error text that is currently cached
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.ConsoleErrorHandler(System.Object,System.Diagnostics.DataReceivedEventArgs)">
            <summary>
            Asynchronously handles the error stream from mProcess
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.ConsoleOutputHandler(System.Object,System.Diagnostics.DataReceivedEventArgs)">
            <summary>
            Asynchronously handles the console output from mProcess
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.GarbageCollectNow">
            <summary>
            Force the garbage collector to run, waiting up to 1 second for it to finish
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.GarbageCollectNow(System.Int32)">
            <summary>
            Force the garbage collector to run
            </summary>
            <param name="maxWaitTimeMSec"></param>
        </member>
        <member name="M:PRISM.ProgRunner.GetConsoleOutputFilePath">
            <summary>
            Returns the full path to the console output file that will be created if WriteConsoleOutputToFile is true
            </summary>
            <remarks>
            Before calling this method, define WorkDir (working directory) and Program (full path to the .exe to run)
            </remarks>
        </member>
        <member name="M:PRISM.ProgRunner.JoinThreadNow">
            <summary>
            Attempt to re-join the thread running the external process
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.RegisterEventLogger(PRISM.Logging.BaseLogger)">
            <summary>
            Associate a logger with this class
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.RegisterEventLogger(PRISM.ILogger)">
            <summary>
            Associate an event logger with this class
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.RegisterExceptionLogger(PRISM.ILogger)">
            <summary>
            Sets the name of the exception logger
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.SleepMilliseconds(System.Int32)">
            <summary>
            Pause program execution for the specific number of milliseconds (maximum 10 seconds)
            </summary>
            <param name="sleepTimeMsec">Value between 10 and 10000 (i.e. between 10 msec and 10 seconds)</param>
        </member>
        <member name="M:PRISM.ProgRunner.SleepMillisecondsAsync(System.Int32)">
            <summary>
            Pause program execution for the specific number of milliseconds (maximum 10 seconds)
            </summary>
            <param name="sleepTimeMsec">Value between 10 and 10000 (i.e. between 10 msec and 10 seconds)</param>
        </member>
        <member name="M:PRISM.ProgRunner.StartProcess(System.Object)">
            <summary>
            Start program as external process and monitor its state
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.StartAndMonitorProgram">
            <summary>
            Creates a new thread and starts code that runs and monitors a program in it
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.StartingOrMonitoring">
            <summary>
            Return True if the program is starting or running
            </summary>
        </member>
        <member name="M:PRISM.ProgRunner.StopMonitoringProgram(System.Boolean)">
            <summary>
            Causes monitoring thread to exit on its next monitoring cycle
            </summary>
        </member>
        <member name="T:PRISM.ISystemInfo">
            <summary>
            Interface for OS-specific classes for accessing Hardware Information
            </summary>
        </member>
        <member name="M:PRISM.ISystemInfo.GetCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if Hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.ISystemInfo.GetLogicalCoreCount">
            <summary>
            Report the number of logical cores on this system
            </summary>
            <remarks>
            Will be affected by hyperthreading, so a computer with two 8-core chips will report 32 cores if Hyperthreading is enabled
            </remarks>
            <returns>The number of logical cores on this computer</returns>
        </member>
        <member name="M:PRISM.ISystemInfo.GetProcessorPackageCount">
            <summary>
            Report the number of processor packages on this system
            </summary>
            <returns>The number of processor packages on this computer</returns>
        </member>
        <member name="M:PRISM.ISystemInfo.GetNumaNodeCount">
            <summary>
            Report the number of NUMA Nodes on this system
            </summary>
            <returns>The number of NUMA Nodes on this computer</returns>
        </member>
        <member name="M:PRISM.ISystemInfo.GetFreeMemoryMB">
            <summary>
            Determine the free system memory, in MB
            </summary>
            <returns>Free memory, or -1 if an error</returns>
        </member>
        <member name="M:PRISM.ISystemInfo.GetProcesses(System.Boolean)">
            <summary>
            Look for currently active processes
            </summary>
            <remarks>Command line lookup can be slow on Windows because it uses WMI</remarks>
            <param name="lookupCommandLineInfo">When true, the process info dictionary will include the exe path and command line arguments</param>
            <returns>Dictionary where keys are process ID and values are ProcessInfo</returns>
        </member>
        <member name="M:PRISM.ISystemInfo.GetTotalMemoryMB">
            <summary>
            Determine the total system memory, in MB
            </summary>
            <returns>Total memory, or -1 if an error</returns>
        </member>
        <member name="T:PRISM.LinuxSystemInfo">
            <summary>
            Methods to determine memory usage, CPU usage, and Linux system version
            </summary>
        </member>
        <member name="F:PRISM.LinuxSystemInfo.ROOT_PROC_DIRECTORY">
            <summary>
            Path to proc virtual file system
            </summary>
        </member>
        <member name="F:PRISM.LinuxSystemInfo.CPUINFO_FILE">
            <summary>
            Name of cpuinfo file
            </summary>
        </member>
        <member name="F:PRISM.LinuxSystemInfo.MEMINFO_FILE">
            <summary>
            name of meminfo file
            </summary>
        </member>
        <member name="P:PRISM.LinuxSystemInfo.TraceEnabled">
            <summary>
            When true, additional debug messages are reported using DebugEvent
            </summary>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <remarks>
            To view debug events raised by this class, either subscribe to event DebugEvent
            or set SkipConsoleWriteIfNoDebugListener to false
            </remarks>
            <param name="limitLoggingByTimeOfDay">When true, only log errors between 12 am and 12:30 am</param>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.ComputeTotalCPUTime">
            <summary>
            Compute total CPU time (sum of processing times, idle times, wait times, etc.)
            </summary>
            <returns>Total CPU time, in jiffies</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.ComputeTotalCPUTime(System.Int64@)">
            <summary>
            Compute total CPU time (sum of processing times, idle times, wait times, etc.)
            </summary>
            <param name="idleTime">Idle time, in jiffies (sum of idle and iowait times)</param>
            <returns>Total CPU time, in jiffies</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.ExtractCPUTimes(System.IO.FileSystemInfo,System.Int64@,System.Int64@)">
            <summary>
            Parse utime and stime from a stat file for a given process
            </summary>
            <remarks>
            For multi-threaded applications, the task directory below the ProcessID directory will have
            separate ProcessID directories for each thread. Those directories could be parsed to determine
            the processing time for each thread. However, the stat file in the base ProcessID directory
            has the combined processing time for all threads, so parsing of individual thread stat times
            is not necessary to determine overall processing time.
            </remarks>
            <param name="statFile"></param>
            <param name="utime">Amount of time that the process has been scheduled in user mode, in jiffies</param>
            <param name="stime">Amount of time that the process has been scheduled in kernel mode, in jiffies</param>
            <returns>True if success, false if an error</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.ExtractID(System.Text.RegularExpressions.Regex,System.String,System.Int32@)">
            <summary>
            Match the data line with the RegEx matcher
            If success, extract the ID group, returning the integer via parameter id
            </summary>
            <param name="reIdMatcher"></param>
            <param name="dataLine"></param>
            <param name="id">Output: matched ID, or 0 if no match</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if Hyperthreading is enabled
            The computed core count is cached to avoid needing to re-parse /proc/cpuinfo repeatedly
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetLogicalCoreCount">
            <inheritdoc />
            <summary>
            Report the number of logical cores on this system
            </summary>
            <remarks>
            Will be affected by hyperthreading, so a computer with two 8-core chips will report 32 cores if Hyperthreading is enabled
            </remarks>
            <returns>The number of logical cores on this computer</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetProcessorPackageCount">
            <inheritdoc />
            <summary>
            Report the number of processor packages on this system
            </summary>
            <returns>The number of processor packages on this computer</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetNumaNodeCount">
            <inheritdoc />
            <summary>
            Report the number of NUMA Nodes on this system
            </summary>
            <returns>The number of NUMA Nodes on this computer</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetCoreUsageByProcessName(System.String,System.String,System.Collections.Generic.List{System.Int32}@,System.Single)">
            <summary>
            Reports the number of cores in use by the given process
            This method takes at least 1000 msec to execute
            </summary>
            <remarks>
            Core count is typically an integer, but can be a fractional number if not using a core 100%
            If multiple processes are running with the given name, returns the total core usage for all of them
            </remarks>
            <param name="processName">
            Process name, for example mono (full matches only; partial matches are ignored)
            Can either be just a program name like mono, or the full path to the program (e.g. /usr/local/bin/mono)</param>
            <param name="argumentText">Optional text to require is contained in one of the command line arguments passed to the program</param>
            <param name="processIDs">Output: list of matching process IDs</param>
            <param name="samplingTimeSeconds">Time (in seconds) to wait while determining CPU usage; default 1, minimum 0.1, maximum 10</param>
            <returns>Number of cores in use; -1 if process not found or if a problem</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetCoreUsageByProcessID(System.Int32,System.Single@,System.Single)">
            <summary>
            Determine the core usage for a given process
            </summary>
            <remarks>If a single core was 100% utilized, this method returns 1</remarks>
            <param name="processID"></param>
            <param name="cpuUsageTotal">Output: Total CPU usage (value between 0 and 100)</param>
            <param name="samplingTimeSeconds">Time (in seconds) to wait while determining CPU usage; default 1, minimum 0.1, maximum 10</param>
            <returns>Core usage, or 0 if process not found</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetCoreUsageByProcessID(System.Collections.Generic.List{System.Int32},System.Single@,System.Single)">
            <summary>
            Determine the total core usage for a list of Process IDs
            </summary>
            <remarks>If a single core was 100% utilized, this method returns 1</remarks>
            <param name="processIDs">List of Process IDs to examine</param>
            <param name="cpuUsageTotal">Output: Total CPU usage (value between 0 and 100)</param>
            <param name="samplingTimeSeconds">Time (in seconds) to wait while determining CPU usage; default 1, minimum 0.1, maximum 10</param>
            <returns>Core usage, or 0 if process not found</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetCPUUtilization(System.Single)">
            <summary>
            Returns the CPU usage
            </summary>
            <remarks>
            <param name="samplingTimeSeconds">Time (in seconds) to wait while determining CPU usage; default 1, minimum 0.1, maximum 10</param>
            This is CPU usage for all running applications, not just this application
            For CPU usage of a single application use GetCoreUsageByProcessID()
            </remarks>
            <returns>Value between 0 and 100</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetFreeMemoryMB">
            <summary>
            Determine the free system memory, in MB, on Linux
            </summary>
            <returns>Free memory, or -1 if an error</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetProcesses(System.Boolean)">
            <summary>
            Look for currently active processes
            </summary>
            <param name="lookupCommandLineInfo">Ignored on Linux, but required due to this class implementing ISystemInfo</param>
            <returns>Dictionary where keys are process ID and values are ProcessInfo</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetTotalMemoryMB">
            <summary>
            Determine the total system memory, in MB
            </summary>
            <returns>Total memory, or -1 if an error</returns>
        </member>
        <member name="M:PRISM.LinuxSystemInfo.GetLinuxVersion">
            <summary>
            Determine the version of Linux that we're running
            </summary>
            <returns>String describing the OS version</returns>
        </member>
        <member name="T:PRISM.OSVersionInfo">
            <summary>
            Class for determining the currently running operating system
            Based on https://code.msdn.microsoft.com/windowsapps/How-to-determine-the-263b1850
            </summary>
            <remarks>For Windows and Linux, reports details about the OS version</remarks>
        </member>
        <member name="M:PRISM.OSVersionInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetOSVersion">
            <summary>
            Determine the operating system version
            For Windows and Linux, reports details about the OS version
            </summary>
            <remarks>
            For this to work properly on Windows 10, you must add an app.manifest file
            and uncomment the versions of Windows listed below
            compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"
            See https://stackoverflow.com/a/36158739/1179467
            </remarks>
            <returns>Human-readable description of the OS version</returns>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetLinuxVersion">
            <summary>
            Determine the version of Linux that we're running
            </summary>
            <remarks>
            If run on Windows, will look for files in the \etc directory on the current drive
            If that directory does not exist, will return "Unknown Windows OS"
            </remarks>
            <returns>String describing the OS version</returns>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetFirstLineVersion(System.String,System.String)">
            <summary>
            Return the first line of an operating system version file
            </summary>
            <param name="versionFilePath"></param>
            <param name="osName">Operating system name (empty by default); if non-blank, the version returned is guaranteed to contain this text</param>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetOSReleaseVersion(System.String)">
            <summary>
            Parse version information from an os-release file
            </summary>
            <param name="osReleaseFilePath"></param>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetUbuntuVersion(System.String)">
            <summary>
            Parse version information from an Ubuntu lsb-release file
            </summary>
            <param name="lsbReleaseFilePath"></param>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetWin32Version(System.OperatingSystem)">
            <summary>
            For old windows kernel
            </summary>
            <param name="osInfo"></param>
        </member>
        <member name="M:PRISM.OSVersionInfo.GetWinNTVersion(System.OperatingSystem)">
            <summary>
            For NT kernel
            </summary>
            <param name="osInfo"></param>
        </member>
        <member name="M:PRISM.OSVersionInfo.ReadReleaseFile(System.IO.StreamReader)">
            <summary>
            Read a Linux os-release file or similar release file
            where the contents are expected to be in the form KEY=Value
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:PRISM.OSVersionInfo.StripQuotes(System.String)">
            <summary>
            Remove leading and trailing double quotes
            </summary>
            <param name="dataLine"></param>
        </member>
        <member name="T:PRISM.ProcessInfo">
            <summary>
            Track basic process info metadata
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.Arguments">
            <summary>
            Command line arguments as a single string
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.ArgumentList">
            <summary>
            Command line arguments as a list of strings
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.CommandLine">
            <summary>
            Full command line, including the ExePath and arguments
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.ExePath">
            <summary>
            Executable name or path
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.ExeName">
            <summary>
            Executable name only
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.ProcessID">
            <summary>
            Process ID
            </summary>
        </member>
        <member name="P:PRISM.ProcessInfo.ProcessName">
            <summary>
            Process name
            </summary>
            <remarks>
            Windows processes have names; Linux processes do not
            On Linux will be equivalent to ExeName
            </remarks>
        </member>
        <member name="M:PRISM.ProcessInfo.#ctor(System.Int32)">
            <summary>
            Constructor that takes process ID only
            </summary>
            <param name="processId"></param>
        </member>
        <member name="M:PRISM.ProcessInfo.#ctor(System.Int32,System.String)">
            <summary>
            Constructor that takes process ID and the process name
            </summary>
            <remarks>
            Assumes that the executable path is everything before the first space and arguments are everything after the first space
            </remarks>
            <param name="processId"></param>
            <param name="processName">Command line</param>
        </member>
        <member name="M:PRISM.ProcessInfo.#ctor(System.Int32,System.String,System.String,System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Constructor that takes process ID, process name, executable path, a list of arguments, and optionally the full command line
            </summary>
            <param name="processId"></param>
            <param name="processName"></param>
            <param name="exePath"></param>
            <param name="argumentList"></param>
            <param name="cmdLine"></param>
        </member>
        <member name="M:PRISM.ProcessInfo.ToString">
            <summary>
            Returns process name and process ID
            </summary>
        </member>
        <member name="M:PRISM.ProcessInfo.ToStringVerbose">
            <summary>
            Returns process name, process ID, exe path, exe name, arguments, and the full command line
            </summary>
        </member>
        <member name="P:PRISM.ProcessorCoreInfo.ProcessorID">
            <summary>
            Processor ID for this core
            </summary>
        </member>
        <member name="P:PRISM.ProcessorCoreInfo.PhysicalID">
            <summary>
            Physical ID of the core
            </summary>
        </member>
        <member name="P:PRISM.ProcessorCoreInfo.CoreID">
            <summary>
            Core ID of the core
            </summary>
        </member>
        <member name="M:PRISM.ProcessorCoreInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="processorID"></param>
        </member>
        <member name="T:PRISM.SystemInfo">
            <summary>
            Class for streamlined access to system processor and memory information
            </summary>
            <remarks>Supports both Windows and Linux (uses <see cref="T:PRISM.OSVersionInfo"/> to determine the OS at runtime)</remarks>
        </member>
        <member name="P:PRISM.SystemInfo.IsLinux">
            <summary>
            True if this is a Linux system
            </summary>
        </member>
        <member name="M:PRISM.SystemInfo.#cctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:PRISM.SystemInfo.SystemInfoObject">
            <summary>
            Get the implementation of <see cref="T:PRISM.ISystemInfo"/> that is providing the data
            </summary>
        </member>
        <member name="M:PRISM.SystemInfo.GetCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if Hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.SystemInfo.GetLogicalCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Will be affected by hyperthreading, so a computer with two 8-core chips will report 32 cores if Hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.SystemInfo.GetProcessorPackageCount">
            <summary>
            Report the number of processor packages on this system
            </summary>
            <returns>The number of processor packages on this computer</returns>
        </member>
        <member name="M:PRISM.SystemInfo.GetNumaNodeCount">
            <summary>
            Report the number of NUMA Nodes on this system
            </summary>
            <returns>The number of NUMA Nodes on this computer</returns>
        </member>
        <member name="M:PRISM.SystemInfo.GetFreeMemoryMB">
            <summary>
            Determine the free system memory, in MB
            </summary>
            <returns>Free memory, or -1 if an error</returns>
        </member>
        <member name="M:PRISM.SystemInfo.GetProcesses(System.Boolean)">
            <summary>
            Look for currently active processes
            </summary>
            <remarks>Command line lookup can be slow on Windows because it uses WMI</remarks>
            <param name="lookupCommandLineInfo">When true, the process info dictionary will include the exe path and command line arguments</param>
            <returns>Dictionary where keys are process ID and values are ProcessInfo</returns>
        </member>
        <member name="M:PRISM.SystemInfo.GetTotalMemoryMB">
            <summary>
            Determine the total system memory, in MB
            </summary>
            <returns>Total memory, or -1 if an error</returns>
        </member>
        <member name="T:PRISM.WindowsSystemInfo">
            <summary>
            System information for Windows; obtained via P/Invoke
            </summary>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetCoreCount">
            <inheritdoc />
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetLogicalCoreCount">
            <inheritdoc />
            <summary>
            Report the number of logical cores on this system
            </summary>
            <remarks>
            Will be affected by hyperthreading, so a computer with two 8-core chips will report 32 cores if hyperthreading is enabled
            </remarks>
            <returns>The number of logical cores on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetPhysicalCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetProcessorPackageCount">
            <inheritdoc />
            <summary>
            Report the number of processor packages on this system
            </summary>
            <returns>The number of processor packages on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetNumaNodeCount">
            <inheritdoc />
            <summary>
            Report the number of NUMA Nodes on this system
            </summary>
            <returns>The number of NUMA Nodes on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetFreeMemoryMB">
            <inheritdoc />
            <summary>
            Determine the free system memory, in MB
            </summary>
            <returns>Free memory, or -1 if an error</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetProcesses(System.Boolean)">
            <summary>
            Look for currently active processes
            </summary>
            <remarks>Command line lookup can be slow because it uses WMI; set lookupCommandLineInfo to false to speed things up</remarks>
            <param name="lookupCommandLineInfo">When true, the process info dictionary will include the exe path and command line arguments</param>
            <returns>Dictionary where keys are process ID and values are ProcessInfo</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfo.GetTotalMemoryMB">
            <inheritdoc />
            <summary>
            Determine the total system memory, in MB
            </summary>
            <returns>Total memory, or -1 if an error</returns>
        </member>
        <member name="T:PRISM.WindowsSystemInfoInternal">
            <summary>
            Internal implementation of WindowsSystemInfo
            </summary>
            <remarks>
            Internal to avoid big errors when trying to instantiate
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.mQuotedStringMatcher">
            <summary>
            Matches strings surrounded by double quotes
            </summary>
        </member>
        <member name="T:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX">
            <summary>
            Contains information about the current state of both physical and virtual memory, including extended memory
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.dwLength">
            <summary>
            Size of the structure, in bytes
            </summary>
            <remarks>
            You must set this value before calling GlobalMemoryStatusEx
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.dwMemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical memory that is in use
            </summary>
            <remarks>
            0 indicates no memory use; 100 indicates full memory use
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullTotalPhys">
            <summary>
            Total size of physical memory, in bytes
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullAvailPhys">
            <summary>
            Size of physical memory available, in bytes
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullTotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes
            </summary>
            <remarks>
            This is physical memory plus the size of the page file, minus a small overhead
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullAvailPageFile">
            <summary>
            Size of available memory to commit, in bytes
            </summary>
            <remarks>
            The limit is <see cref="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullTotalPageFile"/>
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullTotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullAvailVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual address space of the calling process, in bytes
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.MEMORYSTATUSEX.ullAvailExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual address space of the calling process, in bytes
            </summary>
        </member>
        <member name="T:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP">
            <summary>
            Possible relationships between logical processors
            </summary>
            <remarks>
            See https://msdn.microsoft.com/en-us/library/windows/desktop/dd405488(v=vs.85).aspx
            and https://msdn.microsoft.com/en-us/library/windows/desktop/ms684197(v=vs.85).aspx
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore">
            <summary>
            The specified logical processors share a single processor core
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP.RelationNumaNode">
            <summary>
            The specified logical processors are part of the same NUMA node
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP.RelationCache">
            <summary>
            The specified logical processors share a cache
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorPackage">
            <summary>
            The specified logical processors share a physical package
            (a single package socketed or soldered onto a motherboard may
            contain multiple processor cores or threads, each of which is
            treated as a separate processor by the operating system)
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup">
            <summary>
            The specified logical processors share a single processor group
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.LOGICAL_PROCESSOR_RELATIONSHIP.RelationAll">
            <summary>
            On input, retrieves information about all possible relationship types. This value is not used on output
            </summary>
        </member>
        <member name="P:PRISM.WindowsSystemInfoInternal.GROUP_AFFINITY.Mask">
            <summary>
            A bitmap that specifies the affinity for zero or more processors within the specified group
            </summary>
            <remarks>
            Platform-specific: needs to be 32 for 32-bit systems and 64 for 64-bit systems
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_AFFINITY.MaskPtr">
            <summary>
            A platform-dependent method to get the Mask
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_AFFINITY.Group">
            <summary>
            The processor group number
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_AFFINITY.Reserved0">
            <summary>
            This field is reserved; array of size 3
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.Flags">
            <summary>
            <para>
            If the Relationship field of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is RelationProcessorCore,
            this field is LTP_PC_SMT if the core has more than one logical processor, or 0 if the core has one logical processor
            </para>
            <para>
            If the Relationship field of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is RelationProcessorPackage,
            this field is always 0
            </para>
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.EfficiencyClass">
            <summary>
            <para>
            If the Relationship field of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is RelationProcessorCore,
            EfficiencyClass specifies the intrinsic tradeoff between performance and power for the applicable core.
            A core with a higher value for the efficiency class has intrinsically greater performance and less efficiency than a core with a lower value for the efficiency class.
            EfficiencyClass is only nonzero on systems with a heterogeneous set of cores.
            </para>
            <para>
            If the Relationship field of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is RelationProcessorPackage,
            EfficiencyClass is always 0
            </para>
            </summary>
            <remarks>
            The minimum operating system version that supports this field is Windows 10
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.Reserved0_7">
            <summary>
            This field is reserved; array of size 21
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.GroupCount">
            <summary>
            This field specifies the number of entries in the GroupMask array
            </summary>
        </member>
        <member name="P:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.GroupMask">
            <summary>
            An array of GROUP_AFFINITY structures
            </summary>
            <remarks>
            <para>
            The <see cref="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.GroupCount"/> field specifies the number of structures in this array
            </para>
            <para>
            Each structure in the array specifies a group number and processor affinity within the group
            </para>
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_RELATIONSHIP.GroupMaskPtr">
            <summary>
            Pointer to the array of GroupMasks
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.NUMA_NODE_RELATIONSHIP.NodeNumber">
            <summary>
            The number of the NUMA node
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.NUMA_NODE_RELATIONSHIP.Reserved0_7">
            <summary>
            This field is reserved; array of size 20
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.NUMA_NODE_RELATIONSHIP.GroupMask">
            <summary>
            A GROUP_AFFINITY structure that specifies a group number and processor affinity within the group
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_CACHE_TYPE.CacheUnified">
            <summary>
            The cache is unified
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_CACHE_TYPE.CacheInstruction">
            <summary>
            The cache is for processor instructions
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_CACHE_TYPE.CacheData">
            <summary>
            The cache is for data
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_CACHE_TYPE.CacheTrace">
            <summary>
            The cache is for traces
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.Level">
            <summary>
            The cache level
            </summary>
            <remarks>
            Allowed values: 1 for L1, 2 for L2, 3 for L3
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.Associativity">
            <summary>
            The cache associativity
            </summary>
            <remarks>
            If the value is CACHE_FULLY_ASSOCIATIVE (0xFF), the cache is fully associative
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.LineSize">
            <summary>
            The cache line size, in bytes
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.CacheSize">
            <summary>
            The cache size, in bytes
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.Type">
            <summary>
            The cache type
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.Reserved0_7">
            <summary>
            This field is reserved; array of size 20
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.CACHE_RELATIONSHIP.GroupMask">
            <summary>
            A GROUP_AFFINITY structure that specifies a group number and processor affinity within the group
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_GROUP_INFO.MaximumProcessorCount">
            <summary>
            The maximum number of processors in the group
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_GROUP_INFO.ActiveProcessorCount">
            <summary>
            The number of active processors in the group
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_GROUP_INFO.Reserved0_7">
            <summary>
            This field is reserved; array of size 38
            </summary>
        </member>
        <member name="P:PRISM.WindowsSystemInfoInternal.PROCESSOR_GROUP_INFO.ActiveProcessorMask">
            <summary>
            A bitmap that specifies the affinity for zero or more active processors within the group
            </summary>
            <remarks>
            Platform-specific: needs to be 32 for 32-bit systems and 64 for 64-bit systems
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.PROCESSOR_GROUP_INFO.ActiveProcessorMaskPtr">
            <summary>
            A platform-dependent method to get the Mask
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_RELATIONSHIP.MaximumGroupCount">
            <summary>
            The maximum number of processor groups on the system
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_RELATIONSHIP.ActiveGroupCount">
            <summary>
            The number of active groups on the system
            </summary>
            <remarks>
            This field indicates the number of PROCESSOR_GROUP_INFO structures in the <see cref="P:PRISM.WindowsSystemInfoInternal.GROUP_RELATIONSHIP.GroupInfo"/> array
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_RELATIONSHIP.Reserved0_7">
            <summary>
            This field is reserved; array of size 20
            </summary>
        </member>
        <member name="P:PRISM.WindowsSystemInfoInternal.GROUP_RELATIONSHIP.GroupInfo">
            <summary>
            An array of PROCESSOR_GROUP_INFO structures
            </summary>
            <remarks>
            Each structure represents the number and affinity of processors in an active group on the system
            </remarks>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.GROUP_RELATIONSHIP.GroupInfoPtr">
            <summary>
            Pointer to the array of GroupInfos
            </summary>
        </member>
        <member name="P:PRISM.WindowsSystemInfoInternal.ISYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.ProcRelationship">
            <summary>
            The type of relationship between the logical processors
            </summary>
        </member>
        <member name="P:PRISM.WindowsSystemInfoInternal.ISYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.StructSize">
            <summary>
            The size of the structure
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_PROCESSOR_RELATIONSHIP.Relationship">
            <summary>
            The type of relationship between the logical processors
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_PROCESSOR_RELATIONSHIP.Size">
            <summary>
            The size of the structure
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_NUMA_NODE_RELATIONSHIP.Relationship">
            <summary>
            The type of relationship between the logical processors
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_NUMA_NODE_RELATIONSHIP.Size">
            <summary>
            The size of the structure
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_CACHE_RELATIONSHIP.Relationship">
            <summary>
            The type of relationship between the logical processors
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_CACHE_RELATIONSHIP.Size">
            <summary>
            The size of the structure
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_GROUP_RELATIONSHIP.Relationship">
            <summary>
            The type of relationship between the logical processors
            </summary>
        </member>
        <member name="F:PRISM.WindowsSystemInfoInternal.SLPI_GROUP_RELATIONSHIP.Size">
            <summary>
            The size of the structure
            </summary>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetCommandLine(System.Diagnostics.Process,System.String@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Determine the command line of a process by ProcessID
            </summary>
            <param name="process"></param>
            <param name="exePath"></param>
            <param name="argumentList"></param>
            <returns>Full command line: exePath (surrounded in double quotes if a space), then a space, then the arguments</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetLogicalCoreCount">
            <summary>
            Report the number of logical cores on this system
            </summary>
            <remarks>
            Will be affected by hyperthreading, so a computer with two 8-core chips will report 32 cores if hyperthreading is enabled
            </remarks>
            <returns>The number of logical cores on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetPhysicalCoreCount">
            <summary>
            Report the number of cores on this system
            </summary>
            <remarks>
            Should not be affected by hyperthreading, so a computer with two 8-core chips will report 16 cores, even if hyperthreading is enabled
            </remarks>
            <returns>The number of cores on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetProcessorPackageCount">
            <summary>
            Report the number of processor packages on this system
            </summary>
            <returns>The number of processor packages on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetNumaNodeCount">
            <summary>
            Report the number of NUMA Nodes on this system
            </summary>
            <returns>The number of NUMA Nodes on this computer</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetFreeMemoryMB">
            <summary>
            Determine the free system memory, in MB
            </summary>
            <remarks>This uses kernel32.dll and is very fast</remarks>
            <returns>Free memory, or -1 if an error</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetProcesses(System.Boolean)">
            <summary>
            Look for currently active processes
            </summary>
            <remarks>Command line lookup can be slow because it uses WMI; set lookupCommandLineInfo to false to speed things up</remarks>
            <param name="lookupCommandLineInfo">When true, the process info dictionary will include the exe path and command line arguments</param>
            <returns>Dictionary where keys are process ID and values are ProcessInfo</returns>
        </member>
        <member name="M:PRISM.WindowsSystemInfoInternal.GetTotalMemoryMB">
            <summary>
            Determine the total system memory, in MB
            </summary>
            <returns>Total memory, or -1 if an error</returns>
        </member>
        <member name="T:PRISM.WindowsUpdateStatus">
            <summary>
            Utility methods for checking whether Windows updates are likely to be applied close to the current time
            Windows desktop computers have Windows updates applied around 3 am on the first Thursday after the third Tuesday of the month
            Windows servers have Windows updates applied around 3 am or 10 am on the first Sunday after the second Tuesday of the month
            </summary>
        </member>
        <member name="M:PRISM.WindowsUpdateStatus.UpdatesArePending">
            <summary>
            Checks whether Windows Updates are expected to occur close to the current time of day
            </summary>
            <returns>True if Windows updates are likely pending on this computer or the Windows servers</returns>
        </member>
        <member name="M:PRISM.WindowsUpdateStatus.UpdatesArePending(System.String@)">
            <summary>
            Checks whether Windows Updates are expected to occur close to the current time of day
            </summary>
            <param name="pendingWindowsUpdateMessage">Output: description of the pending or recent Windows updates</param>
            <returns>True if Windows updates are likely pending on this computer or the Windows servers</returns>
        </member>
        <member name="M:PRISM.WindowsUpdateStatus.UpdatesArePending(System.DateTime,System.String@)">
            <summary>
            Checks whether Windows Updates are expected to occur close to currentTime
            </summary>
            <param name="currentTime">Current time of day</param>
            <param name="pendingWindowsUpdateMessage">Output: description of the pending or recent Windows updates</param>
            <returns>True if Windows updates are likely pending on this computer or the Windows servers</returns>
        </member>
        <member name="M:PRISM.WindowsUpdateStatus.ServerUpdatesArePending">
            <summary>
            Checks whether Windows Updates are expected to occur on Windows Server machines close to the current time of day
            </summary>
            <returns>True if Windows updates are likely pending on the Windows servers</returns>
        </member>
        <member name="M:PRISM.WindowsUpdateStatus.ServerUpdatesArePending(System.DateTime,System.String@)">
            <summary>
            Checks whether Windows Updates are expected to occur on Windows Server machines close currentTime
            </summary>
            <param name="currentTime">Current time of day</param>
            <param name="pendingWindowsUpdateMessage">Output: description of the pending or recent Windows updates</param>
            <returns>True if Windows updates are likely pending on the Windows servers</returns>
        </member>
        <member name="M:PRISM.WindowsUpdateStatus.GetNthTuesdayInMonth(System.DateTime,System.Int32)">
            <summary>
            Return the first, second, third, fourth, or fifth Tuesday in the month
            </summary>
            <param name="currentTime"></param>
            <param name="occurrence">1 for the first Tuesday, 2 for the second, etc.</param>
        </member>
    </members>
</doc>
